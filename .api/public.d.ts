declare module "@cocos/ccbuild" {
    /**
     * @group Merged Types
     */
    export function buildEngine(options: buildEngine.Options): Promise<buildEngine.Result>;
    export namespace buildEngine {
        function transform(code: string, moduleOption: ModuleFormat, loose?: boolean): Promise<{
            code: string;
        }>;
        function isSourceChanged(incrementalFile: string): Promise<boolean>;
        /**
         * Enumerates all chunk files that used by specified feature units.
         * @param meta Metadata of build result.
         * @param featureUnits Feature units.
         */
        function enumerateDependentChunks(meta: buildEngine.Result, featureUnits: string[]): string[];
        /**
         * Enumerates all asset files that used by specified feature units.
         * @param meta Metadata of build result.
         * @param featureUnits Feature units.
         */
        function enumerateDependentAssets(meta: buildEngine.Result, featureUnits: string[]): string[];
        /**
         * Enumerates all chunk files and asset files that used by specified feature units.
         * @param meta Metadata of build result.
         * @param featureUnits Feature units.
         */
        function enumerateAllDependents(meta: buildEngine.Result, featureUnits: string[]): string[];
        export type ModuleFormat = "esm" | "cjs" | "system" | "iife";
        export interface Options {
            /**
             * 引擎仓库目录。
             */
            engine: string;
            /**
             * 输出目录。
             */
            out: string;
            mode: StatsQuery.ConstantManager.ModeType;
            platform: StatsQuery.ConstantManager.PlatformType;
            flags?: Partial<StatsQuery.ConstantManager.IFlagConfig>;
            /**
             * 包含的功能。
             */
            features?: string[];
            /**
             * 输出模块格式。
             * @default 'system'
             */
            moduleFormat?: ModuleFormat;
            /**
             * 是否对生成结果进行压缩。
             * @default false
             */
            compress?: boolean;
            /**
             * 是否生成 source map。
             * 若为 `inline` 则生成内联的 source map。
             * @default false
             */
            sourceMap?: boolean | "inline";
            /**
             * 若 `sourceMap` 为 `true`，此选项指定了 source map 的路径。
             * @default `${outputPath.map}`
             */
            sourceMapFile?: string;
            /**
             * 若为 `true`，分割出 **所有** 引擎子模块。
             * 否则，`.moduleEntries` 指定的所有子模块将被合并成一个单独的 `"cc"` 模块。
             * @default false
             */
            split?: boolean;
            /**
             * 使用的 ammo.js 版本，也即 `@cocos/ammo` 映射到的版本。
             * - 为 `true` 时使用 WebAssembly 版本的 ammo.js；
             * - 为 `false` 时使用 asm.js 版本的 ammo.js；
             * - 为 `'fallback` 时同时在结果中包含两个版本的 ammo.js，并自动根据环境 fallback 选择。
             *
             * 注意，`'fallback'` 只有在 SystemJS 和 Async functions 同时支持时才有效。
             * @default true
             *
             * @deprecated 从 1.1.5 版本开始，该选项只会影响 FORCE_BANNING_BULLET_WASM 宏的值
             * - 为 `true` 时，FORCE_BANNING_BULLET_WASM 为 false
             * - 为 `false` 时，FORCE_BANNING_BULLET_WASM 为 true
             * - 为 `'fallback'` 时, FORCE_BANNING_BULLET_WASM 为 false
             */
            ammoJsWasm?: boolean | "fallback";
            /**
             * If true, all deprecated features/API are excluded.
             * You can also specify a version range(in semver range) to exclude deprecations in specified version(s).
             * @default false
             */
            noDeprecatedFeatures?: string | boolean;
            /**
             * Experimental.
             */
            incremental?: string;
            /**
             * BrowsersList targets.
             */
            targets?: string | string[] | Record<string, string>;
            /**
             * Enable loose compilation.
             *
             * @deprecated since 1.1.20, we force using true internal.
             */
            loose?: boolean;
            /**
             * How to generate the reference to external assets:
             * - `'relative-from-out'`
             * Generate the path relative from `out` directory, does not contain the leading './'.
             *
             * - `'relative-from-chunk'`
             * Generate the path relative from the referencing output chunk.
             *
             * - `'dynamic'`(default)
             * Use runtime `URL` API to resolve the absolute URL.
             * This requires `URL` and `import.meta.url` to be valid.
             */
            assetURLFormat?: "relative-from-out" | "relative-from-chunk" | "runtime-resolved";
            /**
             * Preserve engine type info, this options will build a TS engine to the output directory.
             * It's useful when we need to take a step towards the AOT optimization.
             * This options is only supported on Open Harmony platform for now.
             * @default false
             */
            preserveType?: boolean;
        }
        export interface Result {
            /**
             * Mappings between feature unit name and their actual chunk file, for example:
             * ```js
             * {
             *   "core": "./core.js",
             *   "gfx-webgl": "./gfx-webgl.js",
             * }
             * ```
             */
            exports: Record<string, string>;
            /**
             * The compulsory import mappings that should be applied.
             */
            chunkAliases: Record<string, string>;
            /**
             * The dependency graph, only including dependency chunks.
             *
             * @deprecated please use `chunkDepGraph` instead.
             */
            dependencyGraph?: Record<string, string[]>;
            chunkDepGraph: Record<string, string[]>;
            assetDepGraph: Record<string, string[]>;
            hasCriticalWarns: boolean;
        }
    }
    /**
     * Query any any stats of the engine.
     * @group Merged Types
     */
    export class StatsQuery {
        /**
         * @param engine Path to the engine root.
         */
        static create(engine: string): Promise<StatsQuery>;
        /**
         * Constant manager for engine and user.
         */
        constantManager: StatsQuery.ConstantManager;
        /**
         * Gets the path to the engine root.
         */
        get path(): string;
        /**
         * Gets the path to tsconfig.
         */
        get tsConfigPath(): string;
        /**
         * Gets all optimzie decorators
         */
        getOptimizeDecorators(): ConfigInterface.IOptimizeDecorators;
        /**
         * Gets all features defined.
         */
        getFeatures(): string[];
        /**
         * Returns if the specified feature is defined.
         * @param feature Feature ID.
         */
        hasFeature(feature: string): boolean;
        /**
         * Gets all feature units included in specified features.
         * @param featureIds Feature ID.
         */
        getUnitsOfFeatures(featureIds: string[]): string[];
        getIntrinsicFlagsOfFeatures(featureIds: string[]): Record<string, number | boolean | string>;
        /**
         * Gets all feature units in their names.
         */
        getFeatureUnits(): string[];
        /**
         * Gets the path to source file of the feature unit.
         * @param moduleId Name of the feature unit.
         */
        getFeatureUnitFile(featureUnit: string): string;
        /**
         * Gets all editor public modules in their names.
         */
        getEditorPublicModules(): string[];
        /**
         * Gets the path to source file of the editor-public module.
         * @param moduleName Name of the public module.
         */
        getEditorPublicModuleFile(moduleName: string): string;
        /**
         * Gets the source of `'cc'`.
         * @param featureUnits Involved feature units.
         * @param mapper If exists, map the feature unit name into another module request.
         */
        evaluateIndexModuleSource(featureUnits: string[], mapper?: (featureUnit: string) => string): string;
        /**
         * Evaluates the source of `'internal-constants'`(`'cc/env'`),
         * @param context
         */
        evaluateEnvModuleSourceFromRecord(record: Record<string, unknown>): string;
        /**
         * Evaluates module overrides under specified context.
         * @param context
         */
        evaluateModuleOverrides(context: ConfigInterface.Context): Record<string, string>;
    }
    export namespace StatsQuery {
        export class ConstantManager {
            constructor(engineRoot: string);
            exportDynamicConstants({ mode, platform, flags, }: ConstantManager.ConstantOptions): string;
            genBuildTimeConstants(options: ConstantManager.ConstantOptions): ConstantManager.BuildTimeConstants;
            genCCEnvConstants(options: ConstantManager.ConstantOptions): ConstantManager.CCEnvConstants;
            exportStaticConstants({ mode, platform, flags, }: ConstantManager.ConstantOptions): string;
            genInternalConstants(): string;
            genCCEnv(): string;
        }
        export namespace ConstantManager {
            export type PlatformType = Modularize.PlatformType;
            export type IPlatformConfig = {
                [key in PlatformType]: boolean;
            };
            export interface IInternalFlagConfig {
                SERVER_MODE: boolean;
                NOT_PACK_PHYSX_LIBS: boolean;
                WEBGPU: boolean;
                WASM_SUPPORT_MODE: number;
                FORCE_BANNING_BULLET_WASM: boolean;
                /**
                 * Whether cull the asm.js module.
                 * If this is true, the external modules ending with '.asm.js' or 'js.mem' will be culled.
                 *
                 * @default false
                 */
                CULL_ASM_JS_MODULE: boolean;
                /**
                 * An internal constant to indicate whether need a fallback of wasm.
                 * If true, we build a wasm fallback module for the compatibility of wasm files compiled by different version of emscripten.
                 * This is useful when we use wasm on different version of Safari browsers.
                 *
                 * @default false
                 */
                WASM_FALLBACK: boolean;
                /**
                 * An internal constant to indicate whether we use wasm assets as minigame subpackage.
                 * This is useful when we need to reduce code size.
                 */
                WASM_SUBPACKAGE: boolean;
            }
            export interface IPublicFlagConfig {
                DEBUG: boolean;
                NET_MODE: number;
            }
            export interface IFlagConfig extends IInternalFlagConfig, IPublicFlagConfig {
            }
            export interface IModeConfig {
                EDITOR: boolean;
                PREVIEW: boolean;
                BUILD: boolean;
                TEST: boolean;
            }
            export interface IConstantOptions {
                platform: PlatformType;
                flagConfig: IFlagConfig;
            }
            export type ModeType = keyof IModeConfig;
            export type FlagType = keyof IFlagConfig;
            export interface BuildTimeConstants extends IPlatformConfig, IFlagConfig, IModeConfig {
            }
            export interface CCEnvConstants extends IPlatformConfig, IPublicFlagConfig, IModeConfig {
            }
            export type ValueType = boolean | number;
            export interface ConstantOptions {
                mode: ModeType;
                platform: PlatformType;
                flags: Partial<Record<FlagType, ValueType>>;
            }
        }
    }
    export namespace ConfigInterface {
        export interface Config {
            /**
             * Engine features. Keys are feature IDs.
             */
            features: Record<string, Feature>;
            /**
             * Describe how to generate the index module `'cc'`.
             * Currently not used.
             */
            index?: IndexConfig;
            moduleOverrides?: Array<{
                test: Test;
                overrides: Record<string, string>;
                isVirtualModule: boolean;
            }>;
            /**
             * Included files for quick-compiler.
             */
            includes: Array<string>;
            /**
             * The constants config for engine and user.
             */
            constants: IConstantConfig;
            /**
             * The decorators to be optimize when build engine.
             */
            optimizeDecorators: IOptimizeDecorators;
        }
        export interface IndexConfig {
            modules?: Record<string, {
                /**
                 * If specified, export contents of the module into a namespace specified by `ns`
                 * and then export that namespace into `'cc'`.
                 * If not specified, contents of the module will be directly exported into `'cc'`.
                 */
                ns?: string;
                /**
                 * If `true`, accesses the exports of this module from `'cc'` will be marked as deprecated.
                 */
                deprecated?: boolean;
            }>;
        }
        export type Test = string;
        /**
         * An engine feature.
         */
        export interface Feature {
            /**
             * Modules to be included in this feature in their IDs.
             * The ID of a module is its relative path(no extension) under /exports/.
             */
            modules: string[];
            /**
             * Flags to set when this feature is enabled.
             */
            intrinsicFlags?: Record<string, unknown>;
            /**
             * List of uuid that the feature depend on.
             */
            dependentAssets?: string[];
            /**
             * List of module that the feature depend on.
             */
            dependentModules?: string[];
            /**
             * Whether it is a native only feature, default is false.
             * @default false
             */
            isNativeOnly?: boolean;
        }
        export interface Context {
            mode?: string;
            platform?: string;
            buildTimeConstants?: object;
        }
        export type ConstantTypeName = "boolean" | "number";
        export interface IConstantInfo {
            /**
             * The comment of the constant.
             * Which is used to generate the consts.d.ts file.
             */
            readonly comment: string;
            /**
             * The type of the constant for generating consts.d.ts file.
             */
            readonly type: ConstantTypeName;
            /**
             * The default value of the constant.
             * It can be a boolean, number or string.
             * When it's a string type, the value is the result of eval().
             */
            value: boolean | string | number;
            /**
             * Whether exported to global as a `CC_XXXX` constant.
             * eg. WECHAT is exported to global.CC_WECHAT
             * NOTE: this is a feature of compatibility with Cocos 2.x engine.
             * Default is false.
             *
             * @default false
             */
            ccGlobal?: boolean;
            /**
             * Whether exported to developer.
             * If true, it's only exported to engine.
             */
            readonly internal: boolean;
            /**
             * Some constant can't specify the value in the Editor, Preview or Test environment,
             * so we need to dynamically judge them in runtime.
             * These values are specified in a helper called `helper-dynamic-constants.ts`.
             * Default is false.
             *
             * @default false
             */
            dynamic?: boolean;
        }
        export interface IConstantConfig {
            [ConstantName: string]: IConstantInfo;
        }
        export interface IOptimizeDecorators {
            /**
             * The decorators which should be optimized when they only decorate class fields.
             */
            fieldDecorators: string[];
            /**
             * The decorators which should be removed directly when they only work in Cocos Creator editor.
             */
            editorDecorators: string[];
        }
    }
    export namespace Transformer {
        export namespace babel {
            export namespace core {
                /**
                 * Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.
                 */
                export function transform(code: string, callback: FileResultCallback): void;
                /**
                 * Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.
                 */
                export function transform(code: string, opts: TransformOptions | undefined, callback: FileResultCallback): void;
                /**
                 * Here for backward-compatibility. Ideally use `transformSync` if you want a synchronous API.
                 */
                export function transform(code: string, opts?: TransformOptions): BabelFileResult | null;
                /**
                 * Transforms the passed in code. Returning an object with the generated code, source map, and AST.
                 */
                export function transformSync(code: string, opts?: TransformOptions): BabelFileResult | null;
                /**
                 * Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.
                 */
                export function transformAsync(code: string, opts?: TransformOptions): Promise<BabelFileResult | null>;
                /**
                 * Asynchronously transforms the entire contents of a file.
                 */
                export function transformFile(filename: string, callback: FileResultCallback): void;
                /**
                 * Asynchronously transforms the entire contents of a file.
                 */
                export function transformFile(filename: string, opts: TransformOptions | undefined, callback: FileResultCallback): void;
                /**
                 * Synchronous version of `babel.transformFile`. Returns the transformed contents of the `filename`.
                 */
                export function transformFileSync(filename: string, opts?: TransformOptions): BabelFileResult | null;
                /**
                 * Asynchronously transforms the entire contents of a file.
                 */
                export function transformFileAsync(filename: string, opts?: TransformOptions): Promise<BabelFileResult | null>;
                /**
                 * Given an AST, transform it.
                 */
                export function transformFromAst(ast: Node, code: string | undefined, callback: FileResultCallback): void;
                /**
                 * Given an AST, transform it.
                 */
                export function transformFromAst(ast: Node, code: string | undefined, opts: TransformOptions | undefined, callback: FileResultCallback): void;
                /**
                 * Here for backward-compatibility. Ideally use ".transformSync" if you want a synchronous API.
                 */
                export function transformFromAstSync(ast: Node, code?: string, opts?: TransformOptions): BabelFileResult | null;
                /**
                 * Given an AST, transform it.
                 */
                export function transformFromAstAsync(ast: Node, code?: string, opts?: TransformOptions): Promise<BabelFileResult | null>;
                /**
                 * Given some code, parse it using Babel's standard behavior.
                 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
                 */
                export function parse(code: string, callback: FileParseCallback): void;
                /**
                 * Given some code, parse it using Babel's standard behavior.
                 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
                 */
                export function parse(code: string, options: TransformOptions | undefined, callback: FileParseCallback): void;
                /**
                 * Given some code, parse it using Babel's standard behavior.
                 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
                 */
                export function parse(code: string, options?: TransformOptions): ParseResult | null;
                /**
                 * Given some code, parse it using Babel's standard behavior.
                 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
                 */
                export function parseSync(code: string, options?: TransformOptions): ParseResult | null;
                /**
                 * Given some code, parse it using Babel's standard behavior.
                 * Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.
                 */
                export function parseAsync(code: string, options?: TransformOptions): Promise<ParseResult | null>;
                /**
                 * Resolve Babel's options fully, resulting in an options object where:
                 *
                 * * opts.plugins is a full list of Plugin instances.
                 * * opts.presets is empty and all presets are flattened into opts.
                 * * It can be safely passed back to Babel. Fields like babelrc have been set to false so that later calls to Babel
                 * will not make a second attempt to load config files.
                 *
                 * Plugin instances aren't meant to be manipulated directly, but often callers will serialize this opts to JSON to
                 * use it as a cache key representing the options Babel has received. Caching on this isn't 100% guaranteed to
                 * invalidate properly, but it is the best we have at the moment.
                 */
                export function loadOptions(options?: TransformOptions): object | null;
                /**
                 * To allow systems to easily manipulate and validate a user's config, this function resolves the plugins and
                 * presets and proceeds no further. The expectation is that callers will take the config's .options, manipulate it
                 * as then see fit and pass it back to Babel again.
                 *
                 * * `babelrc: string | void` - The path of the `.babelrc` file, if there was one.
                 * * `babelignore: string | void` - The path of the `.babelignore` file, if there was one.
                 * * `options: ValidatedOptions` - The partially resolved options, which can be manipulated and passed back
                 * to Babel again.
                 *  * `plugins: Array<ConfigItem>` - See below.
                 *  * `presets: Array<ConfigItem>` - See below.
                 *  * It can be safely passed back to Babel. Fields like `babelrc` have been set to false so that later calls to
                 * Babel will not make a second attempt to load config files.
                 *
                 * `ConfigItem` instances expose properties to introspect the values, but each item should be treated as
                 * immutable. If changes are desired, the item should be removed from the list and replaced with either a normal
                 * Babel config value, or with a replacement item created by `babel.createConfigItem`. See that function for
                 * information about `ConfigItem` fields.
                 */
                export function loadPartialConfig(options?: TransformOptions): Readonly<PartialConfig> | null;
                export function loadPartialConfigAsync(options?: TransformOptions): Promise<Readonly<PartialConfig> | null>;
                export function resolvePlugin(name: string, dirname: string): string | null;
                export function resolvePreset(name: string, dirname: string): string | null;
                /**
                 * Allows build tooling to create and cache config items up front. If this function is called multiple times for a
                 * given plugin, Babel will call the plugin's function itself multiple times. If you have a clear set of expected
                 * plugins and presets to inject, pre-constructing the config items would be recommended.
                 */
                export function createConfigItem(value: PluginTarget | [
                    PluginTarget,
                    PluginOptions
                ] | [
                    PluginTarget,
                    PluginOptions,
                    string | undefined
                ], options?: CreateConfigItemOptions): ConfigItem;
                export interface ParserOptions {
                    /**
                     * By default, import and export declarations can only appear at a program's top level.
                     * Setting this option to true allows them anywhere where a statement is allowed.
                     */
                    allowImportExportEverywhere?: boolean;
                    /**
                     * By default, await use is not allowed outside of an async function.
                     * Set this to true to accept such code.
                     */
                    allowAwaitOutsideFunction?: boolean;
                    /**
                     * By default, a return statement at the top level raises an error.
                     * Set this to true to accept such code.
                     */
                    allowReturnOutsideFunction?: boolean;
                    /**
                     * By default, new.target use is not allowed outside of a function or class.
                     * Set this to true to accept such code.
                     */
                    allowNewTargetOutsideFunction?: boolean;
                    allowSuperOutsideMethod?: boolean;
                    /**
                     * By default, exported identifiers must refer to a declared variable.
                     * Set this to true to allow export statements to reference undeclared variables.
                     */
                    allowUndeclaredExports?: boolean;
                    /**
                     * By default, Babel parser JavaScript code according to Annex B syntax.
                     * Set this to `false` to disable such behavior.
                     */
                    annexB?: boolean;
                    /**
                     * By default, Babel attaches comments to adjacent AST nodes.
                     * When this option is set to false, comments are not attached.
                     * It can provide up to 30% performance improvement when the input code has many comments.
                     * @babel/eslint-parser will set it for you.
                     * It is not recommended to use attachComment: false with Babel transform,
                     * as doing so removes all the comments in output code, and renders annotations such as
                     * /* istanbul ignore next *\/ nonfunctional.
                     */
                    attachComment?: boolean;
                    /**
                     * By default, Babel always throws an error when it finds some invalid code.
                     * When this option is set to true, it will store the parsing error and
                     * try to continue parsing the invalid input file.
                     */
                    errorRecovery?: boolean;
                    /**
                     * Indicate the mode the code should be parsed in.
                     * Can be one of "script", "module", or "unambiguous". Defaults to "script".
                     * "unambiguous" will make @babel/parser attempt to guess, based on the presence
                     * of ES6 import or export statements.
                     * Files with ES6 imports and exports are considered "module" and are otherwise "script".
                     */
                    sourceType?: "script" | "module" | "unambiguous";
                    /**
                     * Correlate output AST nodes with their source filename.
                     * Useful when generating code and source maps from the ASTs of multiple input files.
                     */
                    sourceFilename?: string;
                    /**
                     * By default, the first line of code parsed is treated as line 1.
                     * You can provide a line number to alternatively start with.
                     * Useful for integration with other source tools.
                     */
                    startLine?: number;
                    /**
                     * By default, the parsed code is treated as if it starts from line 1, column 0.
                     * You can provide a column number to alternatively start with.
                     * Useful for integration with other source tools.
                     */
                    startColumn?: number;
                    /**
                     * Array containing the plugins that you want to enable.
                     */
                    plugins?: parser.ParserPlugin[];
                    /**
                     * Should the parser work in strict mode.
                     * Defaults to true if sourceType === 'module'. Otherwise, false.
                     */
                    strictMode?: boolean;
                    /**
                     * Adds a ranges property to each node: [node.start, node.end]
                     */
                    ranges?: boolean;
                    /**
                     * Adds all parsed tokens to a tokens property on the File node.
                     */
                    tokens?: boolean;
                    /**
                     * By default, the parser adds information about parentheses by setting
                     * `extra.parenthesized` to `true` as needed.
                     * When this option is `true` the parser creates `ParenthesizedExpression`
                     * AST nodes instead of using the `extra` property.
                     */
                    createParenthesizedExpressions?: boolean;
                }
                export interface GeneratorOptions {
                    /**
                     * Optional string to add as a block comment at the start of the output file.
                     */
                    auxiliaryCommentBefore?: string | undefined;
                    /**
                     * Optional string to add as a block comment at the end of the output file.
                     */
                    auxiliaryCommentAfter?: string | undefined;
                    /**
                     * Function that takes a comment (as a string) and returns true if the comment should be included in the output.
                     * By default, comments are included if `opts.comments` is `true` or if `opts.minifed` is `false` and the comment
                     * contains `@preserve` or `@license`.
                     */
                    shouldPrintComment?(comment: string): boolean;
                    /**
                     * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).
                     * Defaults to `false`.
                     */
                    retainLines?: boolean | undefined;
                    /**
                     * Retain parens around function expressions (could be used to change engine parsing behavior)
                     * Defaults to `false`.
                     */
                    retainFunctionParens?: boolean | undefined;
                    /**
                     * Should comments be included in output? Defaults to `true`.
                     */
                    comments?: boolean | undefined;
                    /**
                     * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.
                     */
                    compact?: boolean | "auto" | undefined;
                    /**
                     * Should the output be minified. Defaults to `false`.
                     */
                    minified?: boolean | undefined;
                    /**
                     * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.
                     */
                    concise?: boolean | undefined;
                    /**
                     * Used in warning messages
                     */
                    filename?: string | undefined;
                    /**
                     * Enable generating source maps. Defaults to `false`.
                     */
                    sourceMaps?: boolean | undefined;
                    /**
                     * A root for all relative URLs in the source map.
                     */
                    sourceRoot?: string | undefined;
                    /**
                     * The filename for the source code (i.e. the code in the `code` argument).
                     * This will only be used if `code` is a string.
                     */
                    sourceFileName?: string | undefined;
                    /**
                     * Set to true to run jsesc with "json": true to print "\u00A9" vs. "©";
                     */
                    jsonCompatibleStrings?: boolean | undefined;
                    /**
                     * Set to true to enable support for experimental decorators syntax before module exports.
                     * Defaults to `false`.
                     */
                    decoratorsBeforeExport?: boolean | undefined;
                    /**
                     * Options for outputting jsesc representation.
                     */
                    jsescOption?: {
                        /**
                         * The default value for the quotes option is 'single'. This means that any occurrences of ' in the input
                         * string are escaped as \', so that the output can be used in a string literal wrapped in single quotes.
                         */
                        quotes?: "single" | "double" | "backtick" | undefined;
                        /**
                         * The default value for the numbers option is 'decimal'. This means that any numeric values are represented
                         * using decimal integer literals. Other valid options are binary, octal, and hexadecimal, which result in
                         * binary integer literals, octal integer literals, and hexadecimal integer literals, respectively.
                         */
                        numbers?: "binary" | "octal" | "decimal" | "hexadecimal" | undefined;
                        /**
                         * The wrap option takes a boolean value (true or false), and defaults to false (disabled). When enabled, the
                         * output is a valid JavaScript string literal wrapped in quotes. The type of quotes can be specified through
                         * the quotes setting.
                         */
                        wrap?: boolean | undefined;
                        /**
                         * The es6 option takes a boolean value (true or false), and defaults to false (disabled). When enabled, any
                         * astral Unicode symbols in the input are escaped using ECMAScript 6 Unicode code point escape sequences
                         * instead of using separate escape sequences for each surrogate half. If backwards compatibility with ES5
                         * environments is a concern, don’t enable this setting. If the json setting is enabled, the value for the es6
                         * setting is ignored (as if it was false).
                         */
                        es6?: boolean | undefined;
                        /**
                         * The escapeEverything option takes a boolean value (true or false), and defaults to false (disabled). When
                         * enabled, all the symbols in the output are escaped — even printable ASCII symbols.
                         */
                        escapeEverything?: boolean | undefined;
                        /**
                         * The minimal option takes a boolean value (true or false), and defaults to false (disabled). When enabled,
                         * only a limited set of symbols in the output are escaped: \0, \b, \t, \n, \f, \r, \\, \u2028, \u2029.
                         */
                        minimal?: boolean | undefined;
                        /**
                         * The isScriptContext option takes a boolean value (true or false), and defaults to false (disabled). When
                         * enabled, occurrences of </script and </style in the output are escaped as <\/script and <\/style, and <!--
                         * is escaped as \x3C!-- (or \u003C!-- when the json option is enabled). This setting is useful when jsesc’s
                         * output ends up as part of a <script> or <style> element in an HTML document.
                         */
                        isScriptContext?: boolean | undefined;
                        /**
                         * The compact option takes a boolean value (true or false), and defaults to true (enabled). When enabled,
                         * the output for arrays and objects is as compact as possible; it’s not formatted nicely.
                         */
                        compact?: boolean | undefined;
                        /**
                         * The indent option takes a string value, and defaults to '\t'. When the compact setting is enabled (true),
                         * the value of the indent option is used to format the output for arrays and objects.
                         */
                        indent?: string | undefined;
                        /**
                         * The indentLevel option takes a numeric value, and defaults to 0. It represents the current indentation level,
                         * i.e. the number of times the value of the indent option is repeated.
                         */
                        indentLevel?: number | undefined;
                        /**
                         * The json option takes a boolean value (true or false), and defaults to false (disabled). When enabled, the
                         * output is valid JSON. Hexadecimal character escape sequences and the \v or \0 escape sequences are not used.
                         * Setting json: true implies quotes: 'double', wrap: true, es6: false, although these values can still be
                         * overridden if needed — but in such cases, the output won’t be valid JSON anymore.
                         */
                        json?: boolean | undefined;
                        /**
                         * The lowercaseHex option takes a boolean value (true or false), and defaults to false (disabled). When enabled,
                         * any alphabetical hexadecimal digits in escape sequences as well as any hexadecimal integer literals (see the
                         * numbers option) in the output are in lowercase.
                         */
                        lowercaseHex?: boolean | undefined;
                    } | undefined;
                }
                export namespace types {
                    export const ACCESSOR_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const ALIAS_KEYS: Partial<Record<NodeTypesWithoutComment, string[]>>;
                    export const ASSIGNMENT_OPERATORS: string[];
                    export type Accessor = ClassAccessorProperty;
                    export interface Aliases {
                        Standardized: Standardized;
                        Expression: Expression;
                        Binary: Binary;
                        Scopable: Scopable;
                        BlockParent: BlockParent;
                        Block: Block;
                        Statement: Statement;
                        Terminatorless: Terminatorless;
                        CompletionStatement: CompletionStatement;
                        Conditional: Conditional;
                        Loop: Loop;
                        While: While;
                        ExpressionWrapper: ExpressionWrapper;
                        For: For;
                        ForXStatement: ForXStatement;
                        Function: Function;
                        FunctionParent: FunctionParent;
                        Pureish: Pureish;
                        Declaration: Declaration;
                        PatternLike: PatternLike;
                        LVal: LVal;
                        TSEntityName: TSEntityName;
                        Literal: Literal;
                        Immutable: Immutable;
                        UserWhitespacable: UserWhitespacable;
                        Method: Method;
                        ObjectMember: ObjectMember;
                        Property: Property;
                        UnaryLike: UnaryLike;
                        Pattern: Pattern;
                        Class: Class;
                        ImportOrExportDeclaration: ImportOrExportDeclaration;
                        ExportDeclaration: ExportDeclaration;
                        ModuleSpecifier: ModuleSpecifier;
                        Accessor: Accessor;
                        Private: Private;
                        Flow: Flow;
                        FlowType: FlowType;
                        FlowBaseAnnotation: FlowBaseAnnotation;
                        FlowDeclaration: FlowDeclaration;
                        FlowPredicate: FlowPredicate;
                        EnumBody: EnumBody;
                        EnumMember: EnumMember;
                        JSX: JSX;
                        Miscellaneous: Miscellaneous;
                        TypeScript: TypeScript;
                        TSTypeElement: TSTypeElement;
                        TSType: TSType;
                        TSBaseType: TSBaseType;
                        ModuleDeclaration: ModuleDeclaration;
                    }
                    export interface AnyTypeAnnotation extends BaseNode {
                        type: "AnyTypeAnnotation";
                    }
                    export interface ArgumentPlaceholder extends BaseNode {
                        type: "ArgumentPlaceholder";
                    }
                    export interface ArrayExpression extends BaseNode {
                        type: "ArrayExpression";
                        elements: Array<null | Expression | SpreadElement>;
                    }
                    export interface ArrayPattern extends BaseNode {
                        type: "ArrayPattern";
                        elements: Array<null | PatternLike | LVal>;
                        decorators?: Array<Decorator> | null;
                        optional?: boolean | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                    }
                    export interface ArrayTypeAnnotation extends BaseNode {
                        type: "ArrayTypeAnnotation";
                        elementType: FlowType;
                    }
                    export interface ArrowFunctionExpression extends BaseNode {
                        type: "ArrowFunctionExpression";
                        params: Array<Identifier | Pattern | RestElement>;
                        body: BlockStatement | Expression;
                        async: boolean;
                        expression: boolean;
                        generator?: boolean;
                        predicate?: DeclaredPredicate | InferredPredicate | null;
                        returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export interface AssignmentExpression extends BaseNode {
                        type: "AssignmentExpression";
                        operator: string;
                        left: LVal;
                        right: Expression;
                    }
                    export interface AssignmentPattern extends BaseNode {
                        type: "AssignmentPattern";
                        left: Identifier | ObjectPattern | ArrayPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
                        right: Expression;
                        decorators?: Array<Decorator> | null;
                        optional?: boolean | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                    }
                    export interface AwaitExpression extends BaseNode {
                        type: "AwaitExpression";
                        argument: Expression;
                    }
                    export const BINARY_OPERATORS: string[];
                    export const BINARY_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const BLOCKPARENT_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const BLOCK_SCOPED_SYMBOL: unique symbol;
                    export const BLOCK_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const BOOLEAN_BINARY_OPERATORS: string[];
                    export const BOOLEAN_NUMBER_BINARY_OPERATORS: string[];
                    export const BOOLEAN_UNARY_OPERATORS: string[];
                    export const BUILDER_KEYS: Record<string, string[]>;
                    export interface BigIntLiteral extends BaseNode {
                        type: "BigIntLiteral";
                        value: string;
                    }
                    export type Binary = BinaryExpression | LogicalExpression;
                    export interface BinaryExpression extends BaseNode {
                        type: "BinaryExpression";
                        operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=" | "|>";
                        left: Expression | PrivateName;
                        right: Expression;
                    }
                    export interface BindExpression extends BaseNode {
                        type: "BindExpression";
                        object: Expression;
                        callee: Expression;
                    }
                    export type Block = BlockStatement | Program | TSModuleBlock;
                    export type BlockParent = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
                    export interface BlockStatement extends BaseNode {
                        type: "BlockStatement";
                        body: Array<Statement>;
                        directives: Array<Directive>;
                    }
                    export interface BooleanLiteral extends BaseNode {
                        type: "BooleanLiteral";
                        value: boolean;
                    }
                    export interface BooleanLiteralTypeAnnotation extends BaseNode {
                        type: "BooleanLiteralTypeAnnotation";
                        value: boolean;
                    }
                    export interface BooleanTypeAnnotation extends BaseNode {
                        type: "BooleanTypeAnnotation";
                    }
                    export interface BreakStatement extends BaseNode {
                        type: "BreakStatement";
                        label?: Identifier | null;
                    }
                    export const CLASS_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const COMMENT_KEYS: readonly [
                        "leadingComments",
                        "trailingComments",
                        "innerComments"
                    ];
                    export const COMPARISON_BINARY_OPERATORS: string[];
                    export const COMPLETIONSTATEMENT_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const CONDITIONAL_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface CallExpression extends BaseNode {
                        type: "CallExpression";
                        callee: Expression | Super | V8IntrinsicIdentifier;
                        arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
                        optional?: true | false | null;
                        typeArguments?: TypeParameterInstantiation | null;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export interface CatchClause extends BaseNode {
                        type: "CatchClause";
                        param?: Identifier | ArrayPattern | ObjectPattern | null;
                        body: BlockStatement;
                    }
                    export type Class = ClassExpression | ClassDeclaration;
                    export interface ClassAccessorProperty extends BaseNode {
                        type: "ClassAccessorProperty";
                        key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression | PrivateName;
                        value?: Expression | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        decorators?: Array<Decorator> | null;
                        computed: boolean;
                        static: boolean;
                        abstract?: boolean | null;
                        accessibility?: "public" | "private" | "protected" | null;
                        declare?: boolean | null;
                        definite?: boolean | null;
                        optional?: boolean | null;
                        override?: boolean;
                        readonly?: boolean | null;
                        variance?: Variance | null;
                    }
                    export interface ClassBody extends BaseNode {
                        type: "ClassBody";
                        body: Array<ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | ClassAccessorProperty | TSDeclareMethod | TSIndexSignature | StaticBlock>;
                    }
                    export interface ClassDeclaration extends BaseNode {
                        type: "ClassDeclaration";
                        id: Identifier;
                        superClass?: Expression | null;
                        body: ClassBody;
                        decorators?: Array<Decorator> | null;
                        abstract?: boolean | null;
                        declare?: boolean | null;
                        implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
                        mixins?: InterfaceExtends | null;
                        superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export interface ClassExpression extends BaseNode {
                        type: "ClassExpression";
                        id?: Identifier | null;
                        superClass?: Expression | null;
                        body: ClassBody;
                        decorators?: Array<Decorator> | null;
                        implements?: Array<TSExpressionWithTypeArguments | ClassImplements> | null;
                        mixins?: InterfaceExtends | null;
                        superTypeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export interface ClassImplements extends BaseNode {
                        type: "ClassImplements";
                        id: Identifier;
                        typeParameters?: TypeParameterInstantiation | null;
                    }
                    export interface ClassMethod extends BaseNode {
                        type: "ClassMethod";
                        kind: "get" | "set" | "method" | "constructor";
                        key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression;
                        params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
                        body: BlockStatement;
                        computed: boolean;
                        static: boolean;
                        generator: boolean;
                        async: boolean;
                        abstract?: boolean | null;
                        access?: "public" | "private" | "protected" | null;
                        accessibility?: "public" | "private" | "protected" | null;
                        decorators?: Array<Decorator> | null;
                        optional?: boolean | null;
                        override?: boolean;
                        returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export interface ClassPrivateMethod extends BaseNode {
                        type: "ClassPrivateMethod";
                        kind: "get" | "set" | "method";
                        key: PrivateName;
                        params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
                        body: BlockStatement;
                        static: boolean;
                        abstract?: boolean | null;
                        access?: "public" | "private" | "protected" | null;
                        accessibility?: "public" | "private" | "protected" | null;
                        async?: boolean;
                        computed?: boolean;
                        decorators?: Array<Decorator> | null;
                        generator?: boolean;
                        optional?: boolean | null;
                        override?: boolean;
                        returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export interface ClassPrivateProperty extends BaseNode {
                        type: "ClassPrivateProperty";
                        key: PrivateName;
                        value?: Expression | null;
                        decorators?: Array<Decorator> | null;
                        static: boolean;
                        definite?: boolean | null;
                        readonly?: boolean | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        variance?: Variance | null;
                    }
                    export interface ClassProperty extends BaseNode {
                        type: "ClassProperty";
                        key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression;
                        value?: Expression | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        decorators?: Array<Decorator> | null;
                        computed: boolean;
                        static: boolean;
                        abstract?: boolean | null;
                        accessibility?: "public" | "private" | "protected" | null;
                        declare?: boolean | null;
                        definite?: boolean | null;
                        optional?: boolean | null;
                        override?: boolean;
                        readonly?: boolean | null;
                        variance?: Variance | null;
                    }
                    export type Comment = CommentBlock | CommentLine;
                    export interface CommentBlock extends BaseComment {
                        type: "CommentBlock";
                    }
                    export interface CommentLine extends BaseComment {
                        type: "CommentLine";
                    }
                    export type CommentTypeShorthand = "leading" | "inner" | "trailing";
                    export type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement;
                    export type Conditional = ConditionalExpression | IfStatement;
                    export interface ConditionalExpression extends BaseNode {
                        type: "ConditionalExpression";
                        test: Expression;
                        consequent: Expression;
                        alternate: Expression;
                    }
                    export interface ContinueStatement extends BaseNode {
                        type: "ContinueStatement";
                        label?: Identifier | null;
                    }
                    export const DECLARATION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const DEPRECATED_ALIASES: {
                        ModuleDeclaration: string;
                    };
                    export const DEPRECATED_KEYS: Record<string, NodeTypesWithoutComment>;
                    export interface DebuggerStatement extends BaseNode {
                        type: "DebuggerStatement";
                    }
                    export interface DecimalLiteral extends BaseNode {
                        type: "DecimalLiteral";
                        value: string;
                    }
                    export type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration;
                    export interface DeclareClass extends BaseNode {
                        type: "DeclareClass";
                        id: Identifier;
                        typeParameters?: TypeParameterDeclaration | null;
                        extends?: Array<InterfaceExtends> | null;
                        body: ObjectTypeAnnotation;
                        implements?: Array<ClassImplements> | null;
                        mixins?: Array<InterfaceExtends> | null;
                    }
                    export interface DeclareExportAllDeclaration extends BaseNode {
                        type: "DeclareExportAllDeclaration";
                        source: StringLiteral;
                        exportKind?: "type" | "value" | null;
                    }
                    export interface DeclareExportDeclaration extends BaseNode {
                        type: "DeclareExportDeclaration";
                        declaration?: Flow | null;
                        specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null;
                        source?: StringLiteral | null;
                        default?: boolean | null;
                    }
                    export interface DeclareFunction extends BaseNode {
                        type: "DeclareFunction";
                        id: Identifier;
                        predicate?: DeclaredPredicate | null;
                    }
                    export interface DeclareInterface extends BaseNode {
                        type: "DeclareInterface";
                        id: Identifier;
                        typeParameters?: TypeParameterDeclaration | null;
                        extends?: Array<InterfaceExtends> | null;
                        body: ObjectTypeAnnotation;
                    }
                    export interface DeclareModule extends BaseNode {
                        type: "DeclareModule";
                        id: Identifier | StringLiteral;
                        body: BlockStatement;
                        kind?: "CommonJS" | "ES" | null;
                    }
                    export interface DeclareModuleExports extends BaseNode {
                        type: "DeclareModuleExports";
                        typeAnnotation: TypeAnnotation;
                    }
                    export interface DeclareOpaqueType extends BaseNode {
                        type: "DeclareOpaqueType";
                        id: Identifier;
                        typeParameters?: TypeParameterDeclaration | null;
                        supertype?: FlowType | null;
                        impltype?: FlowType | null;
                    }
                    export interface DeclareTypeAlias extends BaseNode {
                        type: "DeclareTypeAlias";
                        id: Identifier;
                        typeParameters?: TypeParameterDeclaration | null;
                        right: FlowType;
                    }
                    export interface DeclareVariable extends BaseNode {
                        type: "DeclareVariable";
                        id: Identifier;
                    }
                    export interface DeclaredPredicate extends BaseNode {
                        type: "DeclaredPredicate";
                        value: Flow;
                    }
                    export interface Decorator extends BaseNode {
                        type: "Decorator";
                        expression: Expression;
                    }
                    export type DeprecatedAliases = NumberLiteral | RegexLiteral | RestProperty | SpreadProperty;
                    export interface Directive extends BaseNode {
                        type: "Directive";
                        value: DirectiveLiteral;
                    }
                    export interface DirectiveLiteral extends BaseNode {
                        type: "DirectiveLiteral";
                        value: string;
                    }
                    export interface DoExpression extends BaseNode {
                        type: "DoExpression";
                        body: BlockStatement;
                        async: boolean;
                    }
                    export interface DoWhileStatement extends BaseNode {
                        type: "DoWhileStatement";
                        test: Expression;
                        body: Statement;
                    }
                    export const ENUMBODY_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const ENUMMEMBER_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const EQUALITY_BINARY_OPERATORS: string[];
                    export const EXPORTDECLARATION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const EXPRESSIONWRAPPER_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const EXPRESSION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface EmptyStatement extends BaseNode {
                        type: "EmptyStatement";
                    }
                    export interface EmptyTypeAnnotation extends BaseNode {
                        type: "EmptyTypeAnnotation";
                    }
                    export type EnumBody = EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
                    export interface EnumBooleanBody extends BaseNode {
                        type: "EnumBooleanBody";
                        members: Array<EnumBooleanMember>;
                        explicitType: boolean;
                        hasUnknownMembers: boolean;
                    }
                    export interface EnumBooleanMember extends BaseNode {
                        type: "EnumBooleanMember";
                        id: Identifier;
                        init: BooleanLiteral;
                    }
                    export interface EnumDeclaration extends BaseNode {
                        type: "EnumDeclaration";
                        id: Identifier;
                        body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
                    }
                    export interface EnumDefaultedMember extends BaseNode {
                        type: "EnumDefaultedMember";
                        id: Identifier;
                    }
                    export type EnumMember = EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember;
                    export interface EnumNumberBody extends BaseNode {
                        type: "EnumNumberBody";
                        members: Array<EnumNumberMember>;
                        explicitType: boolean;
                        hasUnknownMembers: boolean;
                    }
                    export interface EnumNumberMember extends BaseNode {
                        type: "EnumNumberMember";
                        id: Identifier;
                        init: NumericLiteral;
                    }
                    export interface EnumStringBody extends BaseNode {
                        type: "EnumStringBody";
                        members: Array<EnumStringMember | EnumDefaultedMember>;
                        explicitType: boolean;
                        hasUnknownMembers: boolean;
                    }
                    export interface EnumStringMember extends BaseNode {
                        type: "EnumStringMember";
                        id: Identifier;
                        init: StringLiteral;
                    }
                    export interface EnumSymbolBody extends BaseNode {
                        type: "EnumSymbolBody";
                        members: Array<EnumDefaultedMember>;
                        hasUnknownMembers: boolean;
                    }
                    export interface ExistsTypeAnnotation extends BaseNode {
                        type: "ExistsTypeAnnotation";
                    }
                    export interface ExportAllDeclaration extends BaseNode {
                        type: "ExportAllDeclaration";
                        source: StringLiteral;
                        assertions?: Array<ImportAttribute> | null;
                        attributes?: Array<ImportAttribute> | null;
                        exportKind?: "type" | "value" | null;
                    }
                    export type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;
                    export interface ExportDefaultDeclaration extends BaseNode {
                        type: "ExportDefaultDeclaration";
                        declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Expression;
                        exportKind?: "value" | null;
                    }
                    export interface ExportDefaultSpecifier extends BaseNode {
                        type: "ExportDefaultSpecifier";
                        exported: Identifier;
                    }
                    export interface ExportNamedDeclaration extends BaseNode {
                        type: "ExportNamedDeclaration";
                        declaration?: Declaration | null;
                        specifiers: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>;
                        source?: StringLiteral | null;
                        assertions?: Array<ImportAttribute> | null;
                        attributes?: Array<ImportAttribute> | null;
                        exportKind?: "type" | "value" | null;
                    }
                    export interface ExportNamespaceSpecifier extends BaseNode {
                        type: "ExportNamespaceSpecifier";
                        exported: Identifier;
                    }
                    export interface ExportSpecifier extends BaseNode {
                        type: "ExportSpecifier";
                        local: Identifier;
                        exported: Identifier | StringLiteral;
                        exportKind?: "type" | "value" | null;
                    }
                    export type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression | ConditionalExpression | FunctionExpression | Identifier | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | ObjectExpression | SequenceExpression | ParenthesizedExpression | ThisExpression | UnaryExpression | UpdateExpression | ArrowFunctionExpression | ClassExpression | MetaProperty | Super | TaggedTemplateExpression | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | OptionalMemberExpression | OptionalCallExpression | TypeCastExpression | JSXElement | JSXFragment | BindExpression | DoExpression | RecordExpression | TupleExpression | DecimalLiteral | ModuleExpression | TopicReference | PipelineTopicExpression | PipelineBareFunction | PipelinePrimaryTopicReference | TSInstantiationExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
                    export interface ExpressionStatement extends BaseNode {
                        type: "ExpressionStatement";
                        expression: Expression;
                    }
                    export type ExpressionWrapper = ExpressionStatement | ParenthesizedExpression | TypeCastExpression;
                    export const FLATTENABLE_KEYS: string[];
                    export const FLIPPED_ALIAS_KEYS: Record<string, NodeTypesWithoutComment[]>;
                    export const FLOWBASEANNOTATION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FLOWDECLARATION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FLOWPREDICATE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FLOWTYPE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FLOW_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FORXSTATEMENT_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FOR_INIT_KEYS: string[];
                    export const FOR_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FUNCTIONPARENT_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const FUNCTION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export type FieldOptions = {
                        default?: string | number | boolean | [
                        ];
                        optional?: boolean;
                        deprecated?: boolean;
                        validate?: Validator;
                    };
                    export interface File extends BaseNode {
                        type: "File";
                        program: Program;
                        comments?: Array<CommentBlock | CommentLine> | null;
                        tokens?: Array<any> | null;
                    }
                    export type Flow = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ClassImplements | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | DeclaredPredicate | ExistsTypeAnnotation | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | InferredPredicate | InterfaceExtends | InterfaceDeclaration | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | QualifiedTypeIdentifier | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | UnionTypeAnnotation | Variance | VoidTypeAnnotation | EnumDeclaration | EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody | EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember | IndexedAccessType | OptionalIndexedAccessType;
                    export type FlowBaseAnnotation = AnyTypeAnnotation | BooleanTypeAnnotation | NullLiteralTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NumberTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | VoidTypeAnnotation;
                    export type FlowDeclaration = DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias;
                    export type FlowPredicate = DeclaredPredicate | InferredPredicate;
                    export type FlowType = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ExistsTypeAnnotation | FunctionTypeAnnotation | GenericTypeAnnotation | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | UnionTypeAnnotation | VoidTypeAnnotation | IndexedAccessType | OptionalIndexedAccessType;
                    export type For = ForInStatement | ForStatement | ForOfStatement;
                    export interface ForInStatement extends BaseNode {
                        type: "ForInStatement";
                        left: VariableDeclaration | LVal;
                        right: Expression;
                        body: Statement;
                    }
                    export interface ForOfStatement extends BaseNode {
                        type: "ForOfStatement";
                        left: VariableDeclaration | LVal;
                        right: Expression;
                        body: Statement;
                        await: boolean;
                    }
                    export interface ForStatement extends BaseNode {
                        type: "ForStatement";
                        init?: VariableDeclaration | Expression | null;
                        test?: Expression | null;
                        update?: Expression | null;
                        body: Statement;
                    }
                    export type ForXStatement = ForInStatement | ForOfStatement;
                    export type Function = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod;
                    export interface FunctionDeclaration extends BaseNode {
                        type: "FunctionDeclaration";
                        id?: Identifier | null;
                        params: Array<Identifier | Pattern | RestElement>;
                        body: BlockStatement;
                        generator: boolean;
                        async: boolean;
                        declare?: boolean | null;
                        predicate?: DeclaredPredicate | InferredPredicate | null;
                        returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export interface FunctionExpression extends BaseNode {
                        type: "FunctionExpression";
                        id?: Identifier | null;
                        params: Array<Identifier | Pattern | RestElement>;
                        body: BlockStatement;
                        generator: boolean;
                        async: boolean;
                        predicate?: DeclaredPredicate | InferredPredicate | null;
                        returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export type FunctionParent = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
                    export interface FunctionTypeAnnotation extends BaseNode {
                        type: "FunctionTypeAnnotation";
                        typeParameters?: TypeParameterDeclaration | null;
                        params: Array<FunctionTypeParam>;
                        rest?: FunctionTypeParam | null;
                        returnType: FlowType;
                        this?: FunctionTypeParam | null;
                    }
                    export interface FunctionTypeParam extends BaseNode {
                        type: "FunctionTypeParam";
                        name?: Identifier | null;
                        typeAnnotation: FlowType;
                        optional?: boolean | null;
                    }
                    export interface GenericTypeAnnotation extends BaseNode {
                        type: "GenericTypeAnnotation";
                        id: Identifier | QualifiedTypeIdentifier;
                        typeParameters?: TypeParameterInstantiation | null;
                    }
                    export const IMMUTABLE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const IMPORTOREXPORTDECLARATION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const INHERIT_KEYS: {
                        readonly optional: readonly [
                            "typeAnnotation",
                            "typeParameters",
                            "returnType"
                        ];
                        readonly force: readonly [
                            "start",
                            "loc",
                            "end"
                        ];
                    };
                    export interface Identifier extends BaseNode {
                        type: "Identifier";
                        name: string;
                        decorators?: Array<Decorator> | null;
                        optional?: boolean | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                    }
                    export interface IfStatement extends BaseNode {
                        type: "IfStatement";
                        test: Expression;
                        consequent: Statement;
                        alternate?: Statement | null;
                    }
                    export type Immutable = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | BigIntLiteral | JSXAttribute | JSXClosingElement | JSXElement | JSXExpressionContainer | JSXSpreadChild | JSXOpeningElement | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment | DecimalLiteral;
                    export interface Import extends BaseNode {
                        type: "Import";
                    }
                    export interface ImportAttribute extends BaseNode {
                        type: "ImportAttribute";
                        key: Identifier | StringLiteral;
                        value: StringLiteral;
                    }
                    export interface ImportDeclaration extends BaseNode {
                        type: "ImportDeclaration";
                        specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>;
                        source: StringLiteral;
                        assertions?: Array<ImportAttribute> | null;
                        attributes?: Array<ImportAttribute> | null;
                        importKind?: "type" | "typeof" | "value" | null;
                        module?: boolean | null;
                    }
                    export interface ImportDefaultSpecifier extends BaseNode {
                        type: "ImportDefaultSpecifier";
                        local: Identifier;
                    }
                    export interface ImportNamespaceSpecifier extends BaseNode {
                        type: "ImportNamespaceSpecifier";
                        local: Identifier;
                    }
                    export type ImportOrExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;
                    export interface ImportSpecifier extends BaseNode {
                        type: "ImportSpecifier";
                        local: Identifier;
                        imported: Identifier | StringLiteral;
                        importKind?: "type" | "typeof" | "value" | null;
                    }
                    export interface IndexedAccessType extends BaseNode {
                        type: "IndexedAccessType";
                        objectType: FlowType;
                        indexType: FlowType;
                    }
                    export interface InferredPredicate extends BaseNode {
                        type: "InferredPredicate";
                    }
                    export interface InterfaceDeclaration extends BaseNode {
                        type: "InterfaceDeclaration";
                        id: Identifier;
                        typeParameters?: TypeParameterDeclaration | null;
                        extends?: Array<InterfaceExtends> | null;
                        body: ObjectTypeAnnotation;
                    }
                    export interface InterfaceExtends extends BaseNode {
                        type: "InterfaceExtends";
                        id: Identifier | QualifiedTypeIdentifier;
                        typeParameters?: TypeParameterInstantiation | null;
                    }
                    export interface InterfaceTypeAnnotation extends BaseNode {
                        type: "InterfaceTypeAnnotation";
                        extends?: Array<InterfaceExtends> | null;
                        body: ObjectTypeAnnotation;
                    }
                    export interface InterpreterDirective extends BaseNode {
                        type: "InterpreterDirective";
                        value: string;
                    }
                    export interface IntersectionTypeAnnotation extends BaseNode {
                        type: "IntersectionTypeAnnotation";
                        types: Array<FlowType>;
                    }
                    export type JSX = JSXAttribute | JSXClosingElement | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXSpreadChild | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXSpreadAttribute | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment;
                    export interface JSXAttribute extends BaseNode {
                        type: "JSXAttribute";
                        name: JSXIdentifier | JSXNamespacedName;
                        value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null;
                    }
                    export interface JSXClosingElement extends BaseNode {
                        type: "JSXClosingElement";
                        name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
                    }
                    export interface JSXClosingFragment extends BaseNode {
                        type: "JSXClosingFragment";
                    }
                    export interface JSXElement extends BaseNode {
                        type: "JSXElement";
                        openingElement: JSXOpeningElement;
                        closingElement?: JSXClosingElement | null;
                        children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
                        selfClosing?: boolean | null;
                    }
                    export interface JSXEmptyExpression extends BaseNode {
                        type: "JSXEmptyExpression";
                    }
                    export interface JSXExpressionContainer extends BaseNode {
                        type: "JSXExpressionContainer";
                        expression: Expression | JSXEmptyExpression;
                    }
                    export interface JSXFragment extends BaseNode {
                        type: "JSXFragment";
                        openingFragment: JSXOpeningFragment;
                        closingFragment: JSXClosingFragment;
                        children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>;
                    }
                    export interface JSXIdentifier extends BaseNode {
                        type: "JSXIdentifier";
                        name: string;
                    }
                    export interface JSXMemberExpression extends BaseNode {
                        type: "JSXMemberExpression";
                        object: JSXMemberExpression | JSXIdentifier;
                        property: JSXIdentifier;
                    }
                    export interface JSXNamespacedName extends BaseNode {
                        type: "JSXNamespacedName";
                        namespace: JSXIdentifier;
                        name: JSXIdentifier;
                    }
                    export interface JSXOpeningElement extends BaseNode {
                        type: "JSXOpeningElement";
                        name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName;
                        attributes: Array<JSXAttribute | JSXSpreadAttribute>;
                        selfClosing: boolean;
                        typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
                    }
                    export interface JSXOpeningFragment extends BaseNode {
                        type: "JSXOpeningFragment";
                    }
                    export interface JSXSpreadAttribute extends BaseNode {
                        type: "JSXSpreadAttribute";
                        argument: Expression;
                    }
                    export interface JSXSpreadChild extends BaseNode {
                        type: "JSXSpreadChild";
                        expression: Expression;
                    }
                    export interface JSXText extends BaseNode {
                        type: "JSXText";
                        value: string;
                    }
                    export const JSX_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const LITERAL_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const LOGICAL_OPERATORS: string[];
                    export const LOOP_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const LVAL_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export type LVal = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
                    export interface LabeledStatement extends BaseNode {
                        type: "LabeledStatement";
                        label: Identifier;
                        body: Statement;
                    }
                    export type Literal = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | TemplateLiteral | BigIntLiteral | DecimalLiteral;
                    export interface LogicalExpression extends BaseNode {
                        type: "LogicalExpression";
                        operator: "||" | "&&" | "??";
                        left: Expression;
                        right: Expression;
                    }
                    export type Loop = DoWhileStatement | ForInStatement | ForStatement | WhileStatement | ForOfStatement;
                    export const METHOD_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const MISCELLANEOUS_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    /**
                     * @deprecated migrate to IMPORTOREXPORTDECLARATION_TYPES.
                     */
                    export const MODULEDECLARATION_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const MODULESPECIFIER_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface MemberExpression extends BaseNode {
                        type: "MemberExpression";
                        object: Expression | Super;
                        property: Expression | Identifier | PrivateName;
                        computed: boolean;
                        optional?: true | false | null;
                    }
                    export interface MetaProperty extends BaseNode {
                        type: "MetaProperty";
                        meta: Identifier;
                        property: Identifier;
                    }
                    export type Method = ObjectMethod | ClassMethod | ClassPrivateMethod;
                    export type Miscellaneous = Noop | Placeholder | V8IntrinsicIdentifier;
                    export interface MixedTypeAnnotation extends BaseNode {
                        type: "MixedTypeAnnotation";
                    }
                    export type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;
                    export interface ModuleExpression extends BaseNode {
                        type: "ModuleExpression";
                        body: Program;
                    }
                    export type ModuleSpecifier = ExportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ExportNamespaceSpecifier | ExportDefaultSpecifier;
                    export const NODE_FIELDS: Record<string, FieldDefinitions>;
                    export const NODE_PARENT_VALIDATIONS: Record<string, Validator>;
                    export const NOT_LOCAL_BINDING: unique symbol;
                    export const NUMBER_BINARY_OPERATORS: string[];
                    export const NUMBER_UNARY_OPERATORS: string[];
                    export interface NewExpression extends BaseNode {
                        type: "NewExpression";
                        callee: Expression | Super | V8IntrinsicIdentifier;
                        arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
                        optional?: true | false | null;
                        typeArguments?: TypeParameterInstantiation | null;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export type Node = AnyTypeAnnotation | ArgumentPlaceholder | ArrayExpression | ArrayPattern | ArrayTypeAnnotation | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BigIntLiteral | BinaryExpression | BindExpression | BlockStatement | BooleanLiteral | BooleanLiteralTypeAnnotation | BooleanTypeAnnotation | BreakStatement | CallExpression | CatchClause | ClassAccessorProperty | ClassBody | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | ContinueStatement | DebuggerStatement | DecimalLiteral | DeclareClass | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | DeclaredPredicate | Decorator | Directive | DirectiveLiteral | DoExpression | DoWhileStatement | EmptyStatement | EmptyTypeAnnotation | EnumBooleanBody | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumNumberBody | EnumNumberMember | EnumStringBody | EnumStringMember | EnumSymbolBody | ExistsTypeAnnotation | ExportAllDeclaration | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamedDeclaration | ExportNamespaceSpecifier | ExportSpecifier | ExpressionStatement | File | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | Identifier | IfStatement | Import | ImportAttribute | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | IndexedAccessType | InferredPredicate | InterfaceDeclaration | InterfaceExtends | InterfaceTypeAnnotation | InterpreterDirective | IntersectionTypeAnnotation | JSXAttribute | JSXClosingElement | JSXClosingFragment | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXFragment | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXOpeningFragment | JSXSpreadAttribute | JSXSpreadChild | JSXText | LabeledStatement | LogicalExpression | MemberExpression | MetaProperty | MixedTypeAnnotation | ModuleExpression | NewExpression | Noop | NullLiteral | NullLiteralTypeAnnotation | NullableTypeAnnotation | NumberLiteral | NumberLiteralTypeAnnotation | NumberTypeAnnotation | NumericLiteral | ObjectExpression | ObjectMethod | ObjectPattern | ObjectProperty | ObjectTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalCallExpression | OptionalIndexedAccessType | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelinePrimaryTopicReference | PipelineTopicExpression | Placeholder | PrivateName | Program | QualifiedTypeIdentifier | RecordExpression | RegExpLiteral | RegexLiteral | RestElement | RestProperty | ReturnStatement | SequenceExpression | SpreadElement | SpreadProperty | StaticBlock | StringLiteral | StringLiteralTypeAnnotation | StringTypeAnnotation | Super | SwitchCase | SwitchStatement | SymbolTypeAnnotation | TSAnyKeyword | TSArrayType | TSAsExpression | TSBigIntKeyword | TSBooleanKeyword | TSCallSignatureDeclaration | TSConditionalType | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSExternalModuleReference | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSIndexedAccessType | TSInferType | TSInstantiationExpression | TSInterfaceBody | TSInterfaceDeclaration | TSIntersectionType | TSIntrinsicKeyword | TSLiteralType | TSMappedType | TSMethodSignature | TSModuleBlock | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNeverKeyword | TSNonNullExpression | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSOptionalType | TSParameterProperty | TSParenthesizedType | TSPropertySignature | TSQualifiedName | TSRestType | TSSatisfiesExpression | TSStringKeyword | TSSymbolKeyword | TSThisType | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeLiteral | TSTypeOperator | TSTypeParameter | TSTypeParameterDeclaration | TSTypeParameterInstantiation | TSTypePredicate | TSTypeQuery | TSTypeReference | TSUndefinedKeyword | TSUnionType | TSUnknownKeyword | TSVoidKeyword | TaggedTemplateExpression | TemplateElement | TemplateLiteral | ThisExpression | ThisTypeAnnotation | ThrowStatement | TopicReference | TryStatement | TupleExpression | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | TypeofTypeAnnotation | UnaryExpression | UnionTypeAnnotation | UpdateExpression | V8IntrinsicIdentifier | VariableDeclaration | VariableDeclarator | Variance | VoidTypeAnnotation | WhileStatement | WithStatement | YieldExpression;
                    export interface Noop extends BaseNode {
                        type: "Noop";
                    }
                    export interface NullLiteral extends BaseNode {
                        type: "NullLiteral";
                    }
                    export interface NullLiteralTypeAnnotation extends BaseNode {
                        type: "NullLiteralTypeAnnotation";
                    }
                    export interface NullableTypeAnnotation extends BaseNode {
                        type: "NullableTypeAnnotation";
                        typeAnnotation: FlowType;
                    }
                    /**
                     * @deprecated Use `NumericLiteral`
                     */
                    export interface NumberLiteral extends BaseNode {
                        type: "NumberLiteral";
                        value: number;
                    }
                    export interface NumberLiteralTypeAnnotation extends BaseNode {
                        type: "NumberLiteralTypeAnnotation";
                        value: number;
                    }
                    export interface NumberTypeAnnotation extends BaseNode {
                        type: "NumberTypeAnnotation";
                    }
                    export interface NumericLiteral extends BaseNode {
                        type: "NumericLiteral";
                        value: number;
                    }
                    export const OBJECTMEMBER_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface ObjectExpression extends BaseNode {
                        type: "ObjectExpression";
                        properties: Array<ObjectMethod | ObjectProperty | SpreadElement>;
                    }
                    export type ObjectMember = ObjectMethod | ObjectProperty;
                    export interface ObjectMethod extends BaseNode {
                        type: "ObjectMethod";
                        kind: "method" | "get" | "set";
                        key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral;
                        params: Array<Identifier | Pattern | RestElement>;
                        body: BlockStatement;
                        computed: boolean;
                        generator: boolean;
                        async: boolean;
                        decorators?: Array<Decorator> | null;
                        returnType?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                        typeParameters?: TypeParameterDeclaration | TSTypeParameterDeclaration | Noop | null;
                    }
                    export interface ObjectPattern extends BaseNode {
                        type: "ObjectPattern";
                        properties: Array<RestElement | ObjectProperty>;
                        decorators?: Array<Decorator> | null;
                        optional?: boolean | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                    }
                    export interface ObjectProperty extends BaseNode {
                        type: "ObjectProperty";
                        key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral | DecimalLiteral | PrivateName;
                        value: Expression | PatternLike;
                        computed: boolean;
                        shorthand: boolean;
                        decorators?: Array<Decorator> | null;
                    }
                    export interface ObjectTypeAnnotation extends BaseNode {
                        type: "ObjectTypeAnnotation";
                        properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>;
                        indexers?: Array<ObjectTypeIndexer>;
                        callProperties?: Array<ObjectTypeCallProperty>;
                        internalSlots?: Array<ObjectTypeInternalSlot>;
                        exact: boolean;
                        inexact?: boolean | null;
                    }
                    export interface ObjectTypeCallProperty extends BaseNode {
                        type: "ObjectTypeCallProperty";
                        value: FlowType;
                        static: boolean;
                    }
                    export interface ObjectTypeIndexer extends BaseNode {
                        type: "ObjectTypeIndexer";
                        id?: Identifier | null;
                        key: FlowType;
                        value: FlowType;
                        variance?: Variance | null;
                        static: boolean;
                    }
                    export interface ObjectTypeInternalSlot extends BaseNode {
                        type: "ObjectTypeInternalSlot";
                        id: Identifier;
                        value: FlowType;
                        optional: boolean;
                        static: boolean;
                        method: boolean;
                    }
                    export interface ObjectTypeProperty extends BaseNode {
                        type: "ObjectTypeProperty";
                        key: Identifier | StringLiteral;
                        value: FlowType;
                        variance?: Variance | null;
                        kind: "init" | "get" | "set";
                        method: boolean;
                        optional: boolean;
                        proto: boolean;
                        static: boolean;
                    }
                    export interface ObjectTypeSpreadProperty extends BaseNode {
                        type: "ObjectTypeSpreadProperty";
                        argument: FlowType;
                    }
                    export interface OpaqueType extends BaseNode {
                        type: "OpaqueType";
                        id: Identifier;
                        typeParameters?: TypeParameterDeclaration | null;
                        supertype?: FlowType | null;
                        impltype: FlowType;
                    }
                    export interface OptionalCallExpression extends BaseNode {
                        type: "OptionalCallExpression";
                        callee: Expression;
                        arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>;
                        optional: boolean;
                        typeArguments?: TypeParameterInstantiation | null;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export interface OptionalIndexedAccessType extends BaseNode {
                        type: "OptionalIndexedAccessType";
                        objectType: FlowType;
                        indexType: FlowType;
                        optional: boolean;
                    }
                    export interface OptionalMemberExpression extends BaseNode {
                        type: "OptionalMemberExpression";
                        object: Expression;
                        property: Expression | Identifier;
                        computed: boolean;
                        optional: boolean;
                    }
                    export const PATTERNLIKE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const PATTERN_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const PLACEHOLDERS: readonly [
                        "Identifier",
                        "StringLiteral",
                        "Expression",
                        "Statement",
                        "Declaration",
                        "BlockStatement",
                        "ClassBody",
                        "Pattern"
                    ];
                    export const PLACEHOLDERS_ALIAS: Record<string, string[]>;
                    export const PLACEHOLDERS_FLIPPED_ALIAS: Record<string, string[]>;
                    export const PRIVATE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const PROPERTY_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const PUREISH_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface ParentMaps {
                        AnyTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        ArgumentPlaceholder: CallExpression | NewExpression | OptionalCallExpression;
                        ArrayExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ArrayPattern: ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | CatchClause | ClassMethod | ClassPrivateMethod | ForInStatement | ForOfStatement | FunctionDeclaration | FunctionExpression | ObjectMethod | ObjectProperty | RestElement | TSDeclareFunction | TSDeclareMethod | VariableDeclarator;
                        ArrayTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        ArrowFunctionExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        AssignmentExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        AssignmentPattern: ArrayPattern | ArrowFunctionExpression | AssignmentExpression | ClassMethod | ClassPrivateMethod | ForInStatement | ForOfStatement | FunctionDeclaration | FunctionExpression | ObjectMethod | ObjectProperty | RestElement | TSDeclareFunction | TSDeclareMethod | TSParameterProperty | VariableDeclarator;
                        AwaitExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        BigIntLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSLiteralType | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        BinaryExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        BindExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        BlockStatement: ArrowFunctionExpression | BlockStatement | CatchClause | ClassMethod | ClassPrivateMethod | DeclareModule | DoExpression | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | IfStatement | LabeledStatement | ObjectMethod | Program | StaticBlock | SwitchCase | TSModuleBlock | TryStatement | WhileStatement | WithStatement;
                        BooleanLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | EnumBooleanMember | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSLiteralType | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        BooleanLiteralTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        BooleanTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        BreakStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        CallExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        CatchClause: TryStatement;
                        ClassAccessorProperty: ClassBody;
                        ClassBody: ClassDeclaration | ClassExpression;
                        ClassDeclaration: BlockStatement | DoWhileStatement | ExportDefaultDeclaration | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        ClassExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ClassImplements: ClassDeclaration | ClassExpression | DeclareClass | DeclareExportDeclaration | DeclaredPredicate;
                        ClassMethod: ClassBody;
                        ClassPrivateMethod: ClassBody;
                        ClassPrivateProperty: ClassBody;
                        ClassProperty: ClassBody;
                        CommentBlock: File;
                        CommentLine: File;
                        ConditionalExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ContinueStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DebuggerStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DecimalLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        DeclareClass: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareExportAllDeclaration: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareExportDeclaration: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareFunction: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareInterface: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareModule: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareModuleExports: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareOpaqueType: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareTypeAlias: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclareVariable: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        DeclaredPredicate: ArrowFunctionExpression | DeclareExportDeclaration | DeclareFunction | DeclaredPredicate | FunctionDeclaration | FunctionExpression;
                        Decorator: ArrayPattern | AssignmentPattern | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | Identifier | ObjectMethod | ObjectPattern | ObjectProperty | RestElement | TSDeclareMethod | TSParameterProperty;
                        Directive: BlockStatement | Program;
                        DirectiveLiteral: Directive;
                        DoExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        DoWhileStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        EmptyStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        EmptyTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        EnumBooleanBody: DeclareExportDeclaration | DeclaredPredicate | EnumDeclaration;
                        EnumBooleanMember: DeclareExportDeclaration | DeclaredPredicate | EnumBooleanBody;
                        EnumDeclaration: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        EnumDefaultedMember: DeclareExportDeclaration | DeclaredPredicate | EnumStringBody | EnumSymbolBody;
                        EnumNumberBody: DeclareExportDeclaration | DeclaredPredicate | EnumDeclaration;
                        EnumNumberMember: DeclareExportDeclaration | DeclaredPredicate | EnumNumberBody;
                        EnumStringBody: DeclareExportDeclaration | DeclaredPredicate | EnumDeclaration;
                        EnumStringMember: DeclareExportDeclaration | DeclaredPredicate | EnumStringBody;
                        EnumSymbolBody: DeclareExportDeclaration | DeclaredPredicate | EnumDeclaration;
                        ExistsTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        ExportAllDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        ExportDefaultDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        ExportDefaultSpecifier: ExportNamedDeclaration;
                        ExportNamedDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        ExportNamespaceSpecifier: DeclareExportDeclaration | ExportNamedDeclaration;
                        ExportSpecifier: DeclareExportDeclaration | ExportNamedDeclaration;
                        ExpressionStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        File: null;
                        ForInStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        ForOfStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        ForStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        FunctionDeclaration: BlockStatement | DoWhileStatement | ExportDefaultDeclaration | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        FunctionExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        FunctionTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        FunctionTypeParam: DeclareExportDeclaration | DeclaredPredicate | FunctionTypeAnnotation;
                        GenericTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        Identifier: ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | BreakStatement | CallExpression | CatchClause | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassImplements | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | ContinueStatement | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareOpaqueType | DeclareTypeAlias | DeclareVariable | Decorator | DoWhileStatement | EnumBooleanMember | EnumDeclaration | EnumDefaultedMember | EnumNumberMember | EnumStringMember | ExportDefaultDeclaration | ExportDefaultSpecifier | ExportNamespaceSpecifier | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | FunctionDeclaration | FunctionExpression | FunctionTypeParam | GenericTypeAnnotation | IfStatement | ImportAttribute | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | InterfaceDeclaration | InterfaceExtends | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LabeledStatement | LogicalExpression | MemberExpression | MetaProperty | NewExpression | ObjectMethod | ObjectProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | OpaqueType | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | Placeholder | PrivateName | QualifiedTypeIdentifier | RestElement | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExpressionWithTypeArguments | TSFunctionType | TSImportEqualsDeclaration | TSImportType | TSIndexSignature | TSInstantiationExpression | TSInterfaceDeclaration | TSMethodSignature | TSModuleDeclaration | TSNamedTupleMember | TSNamespaceExportDeclaration | TSNonNullExpression | TSParameterProperty | TSPropertySignature | TSQualifiedName | TSSatisfiesExpression | TSTypeAliasDeclaration | TSTypeAssertion | TSTypePredicate | TSTypeQuery | TSTypeReference | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeAlias | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        IfStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        Import: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ImportAttribute: ExportAllDeclaration | ExportNamedDeclaration | ImportDeclaration;
                        ImportDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        ImportDefaultSpecifier: ImportDeclaration;
                        ImportNamespaceSpecifier: ImportDeclaration;
                        ImportSpecifier: ImportDeclaration;
                        IndexedAccessType: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        InferredPredicate: ArrowFunctionExpression | DeclareExportDeclaration | DeclaredPredicate | FunctionDeclaration | FunctionExpression;
                        InterfaceDeclaration: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        InterfaceExtends: ClassDeclaration | ClassExpression | DeclareClass | DeclareExportDeclaration | DeclareInterface | DeclaredPredicate | InterfaceDeclaration | InterfaceTypeAnnotation;
                        InterfaceTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        InterpreterDirective: Program;
                        IntersectionTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        JSXAttribute: JSXOpeningElement;
                        JSXClosingElement: JSXElement;
                        JSXClosingFragment: JSXFragment;
                        JSXElement: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXAttribute | JSXElement | JSXExpressionContainer | JSXFragment | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        JSXEmptyExpression: JSXExpressionContainer;
                        JSXExpressionContainer: JSXAttribute | JSXElement | JSXFragment;
                        JSXFragment: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXAttribute | JSXElement | JSXExpressionContainer | JSXFragment | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        JSXIdentifier: JSXAttribute | JSXClosingElement | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement;
                        JSXMemberExpression: JSXClosingElement | JSXMemberExpression | JSXOpeningElement;
                        JSXNamespacedName: CallExpression | JSXAttribute | JSXClosingElement | JSXOpeningElement | NewExpression | OptionalCallExpression;
                        JSXOpeningElement: JSXElement;
                        JSXOpeningFragment: JSXFragment;
                        JSXSpreadAttribute: JSXOpeningElement;
                        JSXSpreadChild: JSXElement | JSXFragment;
                        JSXText: JSXElement | JSXFragment;
                        LabeledStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        LogicalExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        MemberExpression: ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | RestElement | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        MetaProperty: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        MixedTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        ModuleExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        NewExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        Noop: ArrayPattern | ArrowFunctionExpression | AssignmentPattern | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | FunctionDeclaration | FunctionExpression | Identifier | ObjectMethod | ObjectPattern | RestElement | TSDeclareFunction | TSDeclareMethod;
                        NullLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        NullLiteralTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        NullableTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        NumberLiteral: null;
                        NumberLiteralTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        NumberTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        NumericLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | EnumNumberMember | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSLiteralType | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ObjectExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ObjectMethod: ObjectExpression;
                        ObjectPattern: ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | CatchClause | ClassMethod | ClassPrivateMethod | ForInStatement | ForOfStatement | FunctionDeclaration | FunctionExpression | ObjectMethod | ObjectProperty | RestElement | TSDeclareFunction | TSDeclareMethod | VariableDeclarator;
                        ObjectProperty: ObjectExpression | ObjectPattern | RecordExpression;
                        ObjectTypeAnnotation: ArrayTypeAnnotation | DeclareClass | DeclareExportDeclaration | DeclareInterface | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | InterfaceDeclaration | InterfaceTypeAnnotation | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        ObjectTypeCallProperty: DeclareExportDeclaration | DeclaredPredicate | ObjectTypeAnnotation;
                        ObjectTypeIndexer: DeclareExportDeclaration | DeclaredPredicate | ObjectTypeAnnotation;
                        ObjectTypeInternalSlot: DeclareExportDeclaration | DeclaredPredicate | ObjectTypeAnnotation;
                        ObjectTypeProperty: DeclareExportDeclaration | DeclaredPredicate | ObjectTypeAnnotation;
                        ObjectTypeSpreadProperty: DeclareExportDeclaration | DeclaredPredicate | ObjectTypeAnnotation;
                        OpaqueType: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        OptionalCallExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        OptionalIndexedAccessType: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        OptionalMemberExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ParenthesizedExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        PipelineBareFunction: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        PipelinePrimaryTopicReference: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        PipelineTopicExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        Placeholder: Node;
                        PrivateName: BinaryExpression | ClassAccessorProperty | ClassPrivateMethod | ClassPrivateProperty | MemberExpression | ObjectProperty;
                        Program: File | ModuleExpression;
                        QualifiedTypeIdentifier: DeclareExportDeclaration | DeclaredPredicate | GenericTypeAnnotation | InterfaceExtends | QualifiedTypeIdentifier;
                        RecordExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        RegExpLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        RegexLiteral: null;
                        RestElement: ArrayPattern | ArrowFunctionExpression | AssignmentExpression | ClassMethod | ClassPrivateMethod | ForInStatement | ForOfStatement | FunctionDeclaration | FunctionExpression | ObjectMethod | ObjectPattern | ObjectProperty | RestElement | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSFunctionType | TSMethodSignature | VariableDeclarator;
                        RestProperty: null;
                        ReturnStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        SequenceExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        SpreadElement: ArrayExpression | CallExpression | NewExpression | ObjectExpression | OptionalCallExpression | RecordExpression | TupleExpression;
                        SpreadProperty: null;
                        StaticBlock: ClassBody;
                        StringLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | DeclareExportAllDeclaration | DeclareExportDeclaration | DeclareModule | Decorator | DoWhileStatement | EnumStringMember | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | ImportAttribute | ImportDeclaration | ImportSpecifier | JSXAttribute | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | ObjectTypeProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSExternalModuleReference | TSImportType | TSInstantiationExpression | TSLiteralType | TSMethodSignature | TSModuleDeclaration | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        StringLiteralTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        StringTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        Super: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        SwitchCase: SwitchStatement;
                        SwitchStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        SymbolTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        TSAnyKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSArrayType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSAsExpression: ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | RestElement | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TSBigIntKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSBooleanKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSCallSignatureDeclaration: TSInterfaceBody | TSTypeLiteral;
                        TSConditionalType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSConstructSignatureDeclaration: TSInterfaceBody | TSTypeLiteral;
                        TSConstructorType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSDeclareFunction: BlockStatement | DoWhileStatement | ExportDefaultDeclaration | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TSDeclareMethod: ClassBody;
                        TSEnumDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TSEnumMember: TSEnumDeclaration;
                        TSExportAssignment: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TSExpressionWithTypeArguments: ClassDeclaration | ClassExpression | TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSInterfaceDeclaration | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSExternalModuleReference: TSImportEqualsDeclaration;
                        TSFunctionType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSImportEqualsDeclaration: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TSImportType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSTypeQuery | TSUnionType | TemplateLiteral;
                        TSIndexSignature: ClassBody | TSInterfaceBody | TSTypeLiteral;
                        TSIndexedAccessType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSInferType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSInstantiationExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TSInterfaceBody: TSInterfaceDeclaration;
                        TSInterfaceDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TSIntersectionType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSIntrinsicKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSLiteralType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSMappedType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSMethodSignature: TSInterfaceBody | TSTypeLiteral;
                        TSModuleBlock: TSModuleDeclaration;
                        TSModuleDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | TSModuleDeclaration | WhileStatement | WithStatement;
                        TSNamedTupleMember: TSTupleType;
                        TSNamespaceExportDeclaration: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TSNeverKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSNonNullExpression: ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | RestElement | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TSNullKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSNumberKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSObjectKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSOptionalType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSParameterProperty: ArrayPattern | AssignmentExpression | ClassMethod | ClassPrivateMethod | ForInStatement | ForOfStatement | RestElement | TSDeclareMethod | VariableDeclarator;
                        TSParenthesizedType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSPropertySignature: TSInterfaceBody | TSTypeLiteral;
                        TSQualifiedName: TSExpressionWithTypeArguments | TSImportEqualsDeclaration | TSImportType | TSQualifiedName | TSTypeQuery | TSTypeReference;
                        TSRestType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSSatisfiesExpression: ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | RestElement | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TSStringKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSSymbolKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSThisType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSTypePredicate | TSUnionType | TemplateLiteral;
                        TSTupleType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSTypeAliasDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TSTypeAnnotation: ArrayPattern | ArrowFunctionExpression | AssignmentPattern | ClassAccessorProperty | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | FunctionDeclaration | FunctionExpression | Identifier | ObjectMethod | ObjectPattern | RestElement | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSFunctionType | TSIndexSignature | TSMethodSignature | TSPropertySignature | TSTypePredicate;
                        TSTypeAssertion: ArrayExpression | ArrayPattern | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | RestElement | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TSTypeLiteral: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSTypeOperator: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSTypeParameter: TSInferType | TSMappedType | TSTypeParameterDeclaration;
                        TSTypeParameterDeclaration: ArrowFunctionExpression | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateMethod | FunctionDeclaration | FunctionExpression | ObjectMethod | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSConstructorType | TSDeclareFunction | TSDeclareMethod | TSFunctionType | TSInterfaceDeclaration | TSMethodSignature | TSTypeAliasDeclaration;
                        TSTypeParameterInstantiation: CallExpression | ClassDeclaration | ClassExpression | JSXOpeningElement | NewExpression | OptionalCallExpression | TSExpressionWithTypeArguments | TSImportType | TSInstantiationExpression | TSTypeQuery | TSTypeReference | TaggedTemplateExpression;
                        TSTypePredicate: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSTypeQuery: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSTypeReference: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSUndefinedKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSUnionType: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSUnknownKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TSVoidKeyword: TSArrayType | TSAsExpression | TSConditionalType | TSIndexedAccessType | TSIntersectionType | TSMappedType | TSNamedTupleMember | TSOptionalType | TSParenthesizedType | TSRestType | TSSatisfiesExpression | TSTupleType | TSTypeAliasDeclaration | TSTypeAnnotation | TSTypeAssertion | TSTypeOperator | TSTypeParameter | TSTypeParameterInstantiation | TSUnionType | TemplateLiteral;
                        TaggedTemplateExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TemplateElement: TemplateLiteral;
                        TemplateLiteral: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSLiteralType | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ThisExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        ThisTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        ThrowStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TopicReference: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TryStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TupleExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TupleTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        TypeAlias: BlockStatement | DeclareExportDeclaration | DeclaredPredicate | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        TypeAnnotation: ArrayPattern | ArrowFunctionExpression | AssignmentPattern | ClassAccessorProperty | ClassMethod | ClassPrivateMethod | ClassPrivateProperty | ClassProperty | DeclareExportDeclaration | DeclareModuleExports | DeclaredPredicate | FunctionDeclaration | FunctionExpression | Identifier | ObjectMethod | ObjectPattern | RestElement | TypeCastExpression | TypeParameter;
                        TypeCastExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | DeclareExportDeclaration | DeclaredPredicate | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        TypeParameter: DeclareExportDeclaration | DeclaredPredicate | TypeParameterDeclaration;
                        TypeParameterDeclaration: ArrowFunctionExpression | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateMethod | DeclareClass | DeclareExportDeclaration | DeclareInterface | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionDeclaration | FunctionExpression | FunctionTypeAnnotation | InterfaceDeclaration | ObjectMethod | OpaqueType | TypeAlias;
                        TypeParameterInstantiation: CallExpression | ClassDeclaration | ClassExpression | ClassImplements | DeclareExportDeclaration | DeclaredPredicate | GenericTypeAnnotation | InterfaceExtends | JSXOpeningElement | NewExpression | OptionalCallExpression | TaggedTemplateExpression;
                        TypeofTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        UnaryExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSLiteralType | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        UnionTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        UpdateExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                        V8IntrinsicIdentifier: CallExpression | NewExpression;
                        VariableDeclaration: BlockStatement | DoWhileStatement | ExportNamedDeclaration | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        VariableDeclarator: VariableDeclaration;
                        Variance: ClassAccessorProperty | ClassPrivateProperty | ClassProperty | DeclareExportDeclaration | DeclaredPredicate | ObjectTypeIndexer | ObjectTypeProperty | TypeParameter;
                        VoidTypeAnnotation: ArrayTypeAnnotation | DeclareExportDeclaration | DeclareOpaqueType | DeclareTypeAlias | DeclaredPredicate | FunctionTypeAnnotation | FunctionTypeParam | IndexedAccessType | IntersectionTypeAnnotation | NullableTypeAnnotation | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeInternalSlot | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | OptionalIndexedAccessType | TupleTypeAnnotation | TypeAlias | TypeAnnotation | TypeParameter | TypeParameterInstantiation | TypeofTypeAnnotation | UnionTypeAnnotation;
                        WhileStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        WithStatement: BlockStatement | DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | LabeledStatement | Program | StaticBlock | SwitchCase | TSModuleBlock | WhileStatement | WithStatement;
                        YieldExpression: ArrayExpression | ArrowFunctionExpression | AssignmentExpression | AssignmentPattern | AwaitExpression | BinaryExpression | BindExpression | CallExpression | ClassAccessorProperty | ClassDeclaration | ClassExpression | ClassMethod | ClassPrivateProperty | ClassProperty | ConditionalExpression | Decorator | DoWhileStatement | ExportDefaultDeclaration | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | JSXExpressionContainer | JSXSpreadAttribute | JSXSpreadChild | LogicalExpression | MemberExpression | NewExpression | ObjectMethod | ObjectProperty | OptionalCallExpression | OptionalMemberExpression | ParenthesizedExpression | PipelineBareFunction | PipelineTopicExpression | ReturnStatement | SequenceExpression | SpreadElement | SwitchCase | SwitchStatement | TSAsExpression | TSDeclareMethod | TSEnumDeclaration | TSEnumMember | TSExportAssignment | TSInstantiationExpression | TSMethodSignature | TSNonNullExpression | TSPropertySignature | TSSatisfiesExpression | TSTypeAssertion | TaggedTemplateExpression | TemplateLiteral | ThrowStatement | TupleExpression | TypeCastExpression | UnaryExpression | UpdateExpression | VariableDeclarator | WhileStatement | WithStatement | YieldExpression;
                    }
                    export interface ParenthesizedExpression extends BaseNode {
                        type: "ParenthesizedExpression";
                        expression: Expression;
                    }
                    export type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern;
                    export type PatternLike = Identifier | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
                    export interface PipelineBareFunction extends BaseNode {
                        type: "PipelineBareFunction";
                        callee: Expression;
                    }
                    export interface PipelinePrimaryTopicReference extends BaseNode {
                        type: "PipelinePrimaryTopicReference";
                    }
                    export interface PipelineTopicExpression extends BaseNode {
                        type: "PipelineTopicExpression";
                        expression: Expression;
                    }
                    export interface Placeholder extends BaseNode {
                        type: "Placeholder";
                        expectedNode: "Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern";
                        name: Identifier;
                    }
                    export type Private = ClassPrivateProperty | ClassPrivateMethod | PrivateName;
                    export interface PrivateName extends BaseNode {
                        type: "PrivateName";
                        id: Identifier;
                    }
                    export interface Program extends BaseNode {
                        type: "Program";
                        body: Array<Statement>;
                        directives: Array<Directive>;
                        sourceType: "script" | "module";
                        interpreter?: InterpreterDirective | null;
                        sourceFile: string;
                    }
                    export type Property = ObjectProperty | ClassProperty | ClassAccessorProperty | ClassPrivateProperty;
                    export type Pureish = FunctionDeclaration | FunctionExpression | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | ArrowFunctionExpression | BigIntLiteral | DecimalLiteral;
                    export interface QualifiedTypeIdentifier extends BaseNode {
                        type: "QualifiedTypeIdentifier";
                        id: Identifier;
                        qualification: Identifier | QualifiedTypeIdentifier;
                    }
                    export interface RecordExpression extends BaseNode {
                        type: "RecordExpression";
                        properties: Array<ObjectProperty | SpreadElement>;
                    }
                    export interface RegExpLiteral extends BaseNode {
                        type: "RegExpLiteral";
                        pattern: string;
                        flags: string;
                    }
                    /**
                     * @deprecated Use `RegExpLiteral`
                     */
                    export interface RegexLiteral extends BaseNode {
                        type: "RegexLiteral";
                        pattern: string;
                        flags: string;
                    }
                    export type RemovePropertiesOptions = {
                        preserveComments?: boolean;
                    };
                    export interface RestElement extends BaseNode {
                        type: "RestElement";
                        argument: LVal;
                        decorators?: Array<Decorator> | null;
                        optional?: boolean | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                    }
                    /**
                     * @deprecated Use `RestElement`
                     */
                    export interface RestProperty extends BaseNode {
                        type: "RestProperty";
                        argument: LVal;
                        decorators?: Array<Decorator> | null;
                        optional?: boolean | null;
                        typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null;
                    }
                    export interface ReturnStatement extends BaseNode {
                        type: "ReturnStatement";
                        argument?: Expression | null;
                    }
                    export const SCOPABLE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const STANDARDIZED_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const STATEMENT_OR_BLOCK_KEYS: string[];
                    export const STATEMENT_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const STRING_UNARY_OPERATORS: string[];
                    export type Scopable = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ClassExpression | ClassDeclaration | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
                    export interface SequenceExpression extends BaseNode {
                        type: "SequenceExpression";
                        expressions: Array<Expression>;
                    }
                    export interface SourceLocation {
                        start: Position;
                        end: Position;
                        filename: string;
                        identifierName: string | undefined | null;
                    }
                    export interface SpreadElement extends BaseNode {
                        type: "SpreadElement";
                        argument: Expression;
                    }
                    /**
                     * @deprecated Use `SpreadElement`
                     */
                    export interface SpreadProperty extends BaseNode {
                        type: "SpreadProperty";
                        argument: Expression;
                    }
                    export type Standardized = ArrayExpression | AssignmentExpression | BinaryExpression | InterpreterDirective | Directive | DirectiveLiteral | BlockStatement | BreakStatement | CallExpression | CatchClause | ConditionalExpression | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | File | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Identifier | IfStatement | LabeledStatement | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | Program | ObjectExpression | ObjectMethod | ObjectProperty | RestElement | ReturnStatement | SequenceExpression | ParenthesizedExpression | SwitchCase | SwitchStatement | ThisExpression | ThrowStatement | TryStatement | UnaryExpression | UpdateExpression | VariableDeclaration | VariableDeclarator | WhileStatement | WithStatement | AssignmentPattern | ArrayPattern | ArrowFunctionExpression | ClassBody | ClassExpression | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ForOfStatement | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | MetaProperty | ClassMethod | ObjectPattern | SpreadElement | Super | TaggedTemplateExpression | TemplateElement | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | ExportNamespaceSpecifier | OptionalMemberExpression | OptionalCallExpression | ClassProperty | ClassAccessorProperty | ClassPrivateProperty | ClassPrivateMethod | PrivateName | StaticBlock;
                    export type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | ForInStatement | ForStatement | FunctionDeclaration | IfStatement | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration | WhileStatement | WithStatement | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ForOfStatement | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration | TSExportAssignment | TSNamespaceExportDeclaration;
                    export interface StaticBlock extends BaseNode {
                        type: "StaticBlock";
                        body: Array<Statement>;
                    }
                    export interface StringLiteral extends BaseNode {
                        type: "StringLiteral";
                        value: string;
                    }
                    export interface StringLiteralTypeAnnotation extends BaseNode {
                        type: "StringLiteralTypeAnnotation";
                        value: string;
                    }
                    export interface StringTypeAnnotation extends BaseNode {
                        type: "StringTypeAnnotation";
                    }
                    export interface Super extends BaseNode {
                        type: "Super";
                    }
                    export interface SwitchCase extends BaseNode {
                        type: "SwitchCase";
                        test?: Expression | null;
                        consequent: Array<Statement>;
                    }
                    export interface SwitchStatement extends BaseNode {
                        type: "SwitchStatement";
                        discriminant: Expression;
                        cases: Array<SwitchCase>;
                    }
                    export interface SymbolTypeAnnotation extends BaseNode {
                        type: "SymbolTypeAnnotation";
                    }
                    export const TERMINATORLESS_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface TSAnyKeyword extends BaseNode {
                        type: "TSAnyKeyword";
                    }
                    export interface TSArrayType extends BaseNode {
                        type: "TSArrayType";
                        elementType: TSType;
                    }
                    export interface TSAsExpression extends BaseNode {
                        type: "TSAsExpression";
                        expression: Expression;
                        typeAnnotation: TSType;
                    }
                    export const TSBASETYPE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export type TSBaseType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSLiteralType;
                    export interface TSBigIntKeyword extends BaseNode {
                        type: "TSBigIntKeyword";
                    }
                    export interface TSBooleanKeyword extends BaseNode {
                        type: "TSBooleanKeyword";
                    }
                    export interface TSCallSignatureDeclaration extends BaseNode {
                        type: "TSCallSignatureDeclaration";
                        typeParameters?: TSTypeParameterDeclaration | null;
                        parameters: Array<Identifier | RestElement>;
                        typeAnnotation?: TSTypeAnnotation | null;
                    }
                    export interface TSConditionalType extends BaseNode {
                        type: "TSConditionalType";
                        checkType: TSType;
                        extendsType: TSType;
                        trueType: TSType;
                        falseType: TSType;
                    }
                    export interface TSConstructSignatureDeclaration extends BaseNode {
                        type: "TSConstructSignatureDeclaration";
                        typeParameters?: TSTypeParameterDeclaration | null;
                        parameters: Array<Identifier | RestElement>;
                        typeAnnotation?: TSTypeAnnotation | null;
                    }
                    export interface TSConstructorType extends BaseNode {
                        type: "TSConstructorType";
                        typeParameters?: TSTypeParameterDeclaration | null;
                        parameters: Array<Identifier | RestElement>;
                        typeAnnotation?: TSTypeAnnotation | null;
                        abstract?: boolean | null;
                    }
                    export interface TSDeclareFunction extends BaseNode {
                        type: "TSDeclareFunction";
                        id?: Identifier | null;
                        typeParameters?: TSTypeParameterDeclaration | Noop | null;
                        params: Array<Identifier | Pattern | RestElement>;
                        returnType?: TSTypeAnnotation | Noop | null;
                        async?: boolean;
                        declare?: boolean | null;
                        generator?: boolean;
                    }
                    export interface TSDeclareMethod extends BaseNode {
                        type: "TSDeclareMethod";
                        decorators?: Array<Decorator> | null;
                        key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression;
                        typeParameters?: TSTypeParameterDeclaration | Noop | null;
                        params: Array<Identifier | Pattern | RestElement | TSParameterProperty>;
                        returnType?: TSTypeAnnotation | Noop | null;
                        abstract?: boolean | null;
                        access?: "public" | "private" | "protected" | null;
                        accessibility?: "public" | "private" | "protected" | null;
                        async?: boolean;
                        computed?: boolean;
                        generator?: boolean;
                        kind?: "get" | "set" | "method" | "constructor";
                        optional?: boolean | null;
                        override?: boolean;
                        static?: boolean;
                    }
                    export const TSENTITYNAME_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export type TSEntityName = Identifier | TSQualifiedName;
                    export interface TSEnumDeclaration extends BaseNode {
                        type: "TSEnumDeclaration";
                        id: Identifier;
                        members: Array<TSEnumMember>;
                        const?: boolean | null;
                        declare?: boolean | null;
                        initializer?: Expression | null;
                    }
                    export interface TSEnumMember extends BaseNode {
                        type: "TSEnumMember";
                        id: Identifier | StringLiteral;
                        initializer?: Expression | null;
                    }
                    export interface TSExportAssignment extends BaseNode {
                        type: "TSExportAssignment";
                        expression: Expression;
                    }
                    export interface TSExpressionWithTypeArguments extends BaseNode {
                        type: "TSExpressionWithTypeArguments";
                        expression: TSEntityName;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export interface TSExternalModuleReference extends BaseNode {
                        type: "TSExternalModuleReference";
                        expression: StringLiteral;
                    }
                    export interface TSFunctionType extends BaseNode {
                        type: "TSFunctionType";
                        typeParameters?: TSTypeParameterDeclaration | null;
                        parameters: Array<Identifier | RestElement>;
                        typeAnnotation?: TSTypeAnnotation | null;
                    }
                    export interface TSImportEqualsDeclaration extends BaseNode {
                        type: "TSImportEqualsDeclaration";
                        id: Identifier;
                        moduleReference: TSEntityName | TSExternalModuleReference;
                        importKind?: "type" | "value" | null;
                        isExport: boolean;
                    }
                    export interface TSImportType extends BaseNode {
                        type: "TSImportType";
                        argument: StringLiteral;
                        qualifier?: TSEntityName | null;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export interface TSIndexSignature extends BaseNode {
                        type: "TSIndexSignature";
                        parameters: Array<Identifier>;
                        typeAnnotation?: TSTypeAnnotation | null;
                        readonly?: boolean | null;
                        static?: boolean | null;
                    }
                    export interface TSIndexedAccessType extends BaseNode {
                        type: "TSIndexedAccessType";
                        objectType: TSType;
                        indexType: TSType;
                    }
                    export interface TSInferType extends BaseNode {
                        type: "TSInferType";
                        typeParameter: TSTypeParameter;
                    }
                    export interface TSInstantiationExpression extends BaseNode {
                        type: "TSInstantiationExpression";
                        expression: Expression;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export interface TSInterfaceBody extends BaseNode {
                        type: "TSInterfaceBody";
                        body: Array<TSTypeElement>;
                    }
                    export interface TSInterfaceDeclaration extends BaseNode {
                        type: "TSInterfaceDeclaration";
                        id: Identifier;
                        typeParameters?: TSTypeParameterDeclaration | null;
                        extends?: Array<TSExpressionWithTypeArguments> | null;
                        body: TSInterfaceBody;
                        declare?: boolean | null;
                    }
                    export interface TSIntersectionType extends BaseNode {
                        type: "TSIntersectionType";
                        types: Array<TSType>;
                    }
                    export interface TSIntrinsicKeyword extends BaseNode {
                        type: "TSIntrinsicKeyword";
                    }
                    export interface TSLiteralType extends BaseNode {
                        type: "TSLiteralType";
                        literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | TemplateLiteral | UnaryExpression;
                    }
                    export interface TSMappedType extends BaseNode {
                        type: "TSMappedType";
                        typeParameter: TSTypeParameter;
                        typeAnnotation?: TSType | null;
                        nameType?: TSType | null;
                        optional?: true | false | "+" | "-" | null;
                        readonly?: true | false | "+" | "-" | null;
                    }
                    export interface TSMethodSignature extends BaseNode {
                        type: "TSMethodSignature";
                        key: Expression;
                        typeParameters?: TSTypeParameterDeclaration | null;
                        parameters: Array<Identifier | RestElement>;
                        typeAnnotation?: TSTypeAnnotation | null;
                        computed?: boolean;
                        kind: "method" | "get" | "set";
                        optional?: boolean | null;
                    }
                    export interface TSModuleBlock extends BaseNode {
                        type: "TSModuleBlock";
                        body: Array<Statement>;
                    }
                    export interface TSModuleDeclaration extends BaseNode {
                        type: "TSModuleDeclaration";
                        id: Identifier | StringLiteral;
                        body: TSModuleBlock | TSModuleDeclaration;
                        declare?: boolean | null;
                        global?: boolean | null;
                    }
                    export interface TSNamedTupleMember extends BaseNode {
                        type: "TSNamedTupleMember";
                        label: Identifier;
                        elementType: TSType;
                        optional: boolean;
                    }
                    export interface TSNamespaceExportDeclaration extends BaseNode {
                        type: "TSNamespaceExportDeclaration";
                        id: Identifier;
                    }
                    export interface TSNeverKeyword extends BaseNode {
                        type: "TSNeverKeyword";
                    }
                    export interface TSNonNullExpression extends BaseNode {
                        type: "TSNonNullExpression";
                        expression: Expression;
                    }
                    export interface TSNullKeyword extends BaseNode {
                        type: "TSNullKeyword";
                    }
                    export interface TSNumberKeyword extends BaseNode {
                        type: "TSNumberKeyword";
                    }
                    export interface TSObjectKeyword extends BaseNode {
                        type: "TSObjectKeyword";
                    }
                    export interface TSOptionalType extends BaseNode {
                        type: "TSOptionalType";
                        typeAnnotation: TSType;
                    }
                    export interface TSParameterProperty extends BaseNode {
                        type: "TSParameterProperty";
                        parameter: Identifier | AssignmentPattern;
                        accessibility?: "public" | "private" | "protected" | null;
                        decorators?: Array<Decorator> | null;
                        override?: boolean | null;
                        readonly?: boolean | null;
                    }
                    export interface TSParenthesizedType extends BaseNode {
                        type: "TSParenthesizedType";
                        typeAnnotation: TSType;
                    }
                    export interface TSPropertySignature extends BaseNode {
                        type: "TSPropertySignature";
                        key: Expression;
                        typeAnnotation?: TSTypeAnnotation | null;
                        initializer?: Expression | null;
                        computed?: boolean;
                        kind: "get" | "set";
                        optional?: boolean | null;
                        readonly?: boolean | null;
                    }
                    export interface TSQualifiedName extends BaseNode {
                        type: "TSQualifiedName";
                        left: TSEntityName;
                        right: Identifier;
                    }
                    export interface TSRestType extends BaseNode {
                        type: "TSRestType";
                        typeAnnotation: TSType;
                    }
                    export interface TSSatisfiesExpression extends BaseNode {
                        type: "TSSatisfiesExpression";
                        expression: Expression;
                        typeAnnotation: TSType;
                    }
                    export interface TSStringKeyword extends BaseNode {
                        type: "TSStringKeyword";
                    }
                    export interface TSSymbolKeyword extends BaseNode {
                        type: "TSSymbolKeyword";
                    }
                    export const TSTYPEELEMENT_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const TSTYPE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface TSThisType extends BaseNode {
                        type: "TSThisType";
                    }
                    export interface TSTupleType extends BaseNode {
                        type: "TSTupleType";
                        elementTypes: Array<TSType | TSNamedTupleMember>;
                    }
                    export type TSType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSLiteralType | TSExpressionWithTypeArguments | TSImportType;
                    export interface TSTypeAliasDeclaration extends BaseNode {
                        type: "TSTypeAliasDeclaration";
                        id: Identifier;
                        typeParameters?: TSTypeParameterDeclaration | null;
                        typeAnnotation: TSType;
                        declare?: boolean | null;
                    }
                    export interface TSTypeAnnotation extends BaseNode {
                        type: "TSTypeAnnotation";
                        typeAnnotation: TSType;
                    }
                    export interface TSTypeAssertion extends BaseNode {
                        type: "TSTypeAssertion";
                        typeAnnotation: TSType;
                        expression: Expression;
                    }
                    export type TSTypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature;
                    export interface TSTypeLiteral extends BaseNode {
                        type: "TSTypeLiteral";
                        members: Array<TSTypeElement>;
                    }
                    export interface TSTypeOperator extends BaseNode {
                        type: "TSTypeOperator";
                        typeAnnotation: TSType;
                        operator: string;
                    }
                    export interface TSTypeParameter extends BaseNode {
                        type: "TSTypeParameter";
                        constraint?: TSType | null;
                        default?: TSType | null;
                        name: string;
                        const?: boolean | null;
                        in?: boolean | null;
                        out?: boolean | null;
                    }
                    export interface TSTypeParameterDeclaration extends BaseNode {
                        type: "TSTypeParameterDeclaration";
                        params: Array<TSTypeParameter>;
                    }
                    export interface TSTypeParameterInstantiation extends BaseNode {
                        type: "TSTypeParameterInstantiation";
                        params: Array<TSType>;
                    }
                    export interface TSTypePredicate extends BaseNode {
                        type: "TSTypePredicate";
                        parameterName: Identifier | TSThisType;
                        typeAnnotation?: TSTypeAnnotation | null;
                        asserts?: boolean | null;
                    }
                    export interface TSTypeQuery extends BaseNode {
                        type: "TSTypeQuery";
                        exprName: TSEntityName | TSImportType;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export interface TSTypeReference extends BaseNode {
                        type: "TSTypeReference";
                        typeName: TSEntityName;
                        typeParameters?: TSTypeParameterInstantiation | null;
                    }
                    export interface TSUndefinedKeyword extends BaseNode {
                        type: "TSUndefinedKeyword";
                    }
                    export interface TSUnionType extends BaseNode {
                        type: "TSUnionType";
                        types: Array<TSType>;
                    }
                    export interface TSUnknownKeyword extends BaseNode {
                        type: "TSUnknownKeyword";
                    }
                    export interface TSVoidKeyword extends BaseNode {
                        type: "TSVoidKeyword";
                    }
                    export const TYPES: Array<string>;
                    export const TYPESCRIPT_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface TaggedTemplateExpression extends BaseNode {
                        type: "TaggedTemplateExpression";
                        tag: Expression;
                        quasi: TemplateLiteral;
                        typeParameters?: TypeParameterInstantiation | TSTypeParameterInstantiation | null;
                    }
                    export interface TemplateElement extends BaseNode {
                        type: "TemplateElement";
                        value: {
                            raw: string;
                            cooked?: string;
                        };
                        tail: boolean;
                    }
                    export interface TemplateLiteral extends BaseNode {
                        type: "TemplateLiteral";
                        quasis: Array<TemplateElement>;
                        expressions: Array<Expression | TSType>;
                    }
                    export type Terminatorless = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression;
                    export interface ThisExpression extends BaseNode {
                        type: "ThisExpression";
                    }
                    export interface ThisTypeAnnotation extends BaseNode {
                        type: "ThisTypeAnnotation";
                    }
                    export interface ThrowStatement extends BaseNode {
                        type: "ThrowStatement";
                        argument: Expression;
                    }
                    export interface TopicReference extends BaseNode {
                        type: "TopicReference";
                    }
                    //# sourceMappingURL=getOuterBindingIdentifiers.d.ts.map
                    export type TraversalAncestors = Array<{
                        node: Node;
                        key: string;
                        index?: number;
                    }>;
                    export type TraversalHandler<T> = (this: undefined, node: Node, parent: TraversalAncestors, state: T) => void;
                    export type TraversalHandlers<T> = {
                        enter?: TraversalHandler<T>;
                        exit?: TraversalHandler<T>;
                    };
                    export interface TryStatement extends BaseNode {
                        type: "TryStatement";
                        block: BlockStatement;
                        handler?: CatchClause | null;
                        finalizer?: BlockStatement | null;
                    }
                    export interface TupleExpression extends BaseNode {
                        type: "TupleExpression";
                        elements: Array<Expression | SpreadElement>;
                    }
                    export interface TupleTypeAnnotation extends BaseNode {
                        type: "TupleTypeAnnotation";
                        types: Array<FlowType>;
                    }
                    export interface TypeAlias extends BaseNode {
                        type: "TypeAlias";
                        id: Identifier;
                        typeParameters?: TypeParameterDeclaration | null;
                        right: FlowType;
                    }
                    export interface TypeAnnotation extends BaseNode {
                        type: "TypeAnnotation";
                        typeAnnotation: FlowType;
                    }
                    export interface TypeCastExpression extends BaseNode {
                        type: "TypeCastExpression";
                        expression: Expression;
                        typeAnnotation: TypeAnnotation;
                    }
                    export interface TypeParameter extends BaseNode {
                        type: "TypeParameter";
                        bound?: TypeAnnotation | null;
                        default?: FlowType | null;
                        variance?: Variance | null;
                        name: string;
                    }
                    export interface TypeParameterDeclaration extends BaseNode {
                        type: "TypeParameterDeclaration";
                        params: Array<TypeParameter>;
                    }
                    export interface TypeParameterInstantiation extends BaseNode {
                        type: "TypeParameterInstantiation";
                        params: Array<FlowType>;
                    }
                    export type TypeScript = TSParameterProperty | TSDeclareFunction | TSDeclareMethod | TSQualifiedName | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature | TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSNamedTupleMember | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSLiteralType | TSExpressionWithTypeArguments | TSInterfaceDeclaration | TSInterfaceBody | TSTypeAliasDeclaration | TSInstantiationExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSEnumDeclaration | TSEnumMember | TSModuleDeclaration | TSModuleBlock | TSImportType | TSImportEqualsDeclaration | TSExternalModuleReference | TSNonNullExpression | TSExportAssignment | TSNamespaceExportDeclaration | TSTypeAnnotation | TSTypeParameterInstantiation | TSTypeParameterDeclaration | TSTypeParameter;
                    export interface TypeofTypeAnnotation extends BaseNode {
                        type: "TypeofTypeAnnotation";
                        argument: FlowType;
                    }
                    export const UNARYLIKE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export const UNARY_OPERATORS: string[];
                    export const UPDATE_OPERATORS: string[];
                    export const USERWHITESPACABLE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export interface UnaryExpression extends BaseNode {
                        type: "UnaryExpression";
                        operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof";
                        argument: Expression;
                        prefix: boolean;
                    }
                    export type UnaryLike = UnaryExpression | SpreadElement;
                    export interface UnionTypeAnnotation extends BaseNode {
                        type: "UnionTypeAnnotation";
                        types: Array<FlowType>;
                    }
                    export interface UpdateExpression extends BaseNode {
                        type: "UpdateExpression";
                        operator: "++" | "--";
                        argument: Expression;
                        prefix: boolean;
                    }
                    export type UserWhitespacable = ObjectMethod | ObjectProperty | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty;
                    export interface V8IntrinsicIdentifier extends BaseNode {
                        type: "V8IntrinsicIdentifier";
                        name: string;
                    }
                    //# sourceMappingURL=valueToNode.d.ts.map
                    export const VISITOR_KEYS: Record<string, string[]>;
                    export interface VariableDeclaration extends BaseNode {
                        type: "VariableDeclaration";
                        kind: "var" | "let" | "const" | "using" | "await using";
                        declarations: Array<VariableDeclarator>;
                        declare?: boolean | null;
                    }
                    export interface VariableDeclarator extends BaseNode {
                        type: "VariableDeclarator";
                        id: LVal;
                        init?: Expression | null;
                        definite?: boolean | null;
                    }
                    export interface Variance extends BaseNode {
                        type: "Variance";
                        kind: "minus" | "plus";
                    }
                    export interface VoidTypeAnnotation extends BaseNode {
                        type: "VoidTypeAnnotation";
                    }
                    export const WHILE_TYPES: ("AnyTypeAnnotation" | "ArgumentPlaceholder" | "ArrayExpression" | "ArrayPattern" | "ArrayTypeAnnotation" | "ArrowFunctionExpression" | "AssignmentExpression" | "AssignmentPattern" | "AwaitExpression" | "BigIntLiteral" | "BinaryExpression" | "BindExpression" | "BlockStatement" | "BooleanLiteral" | "BooleanLiteralTypeAnnotation" | "BooleanTypeAnnotation" | "BreakStatement" | "CallExpression" | "CatchClause" | "ClassAccessorProperty" | "ClassBody" | "ClassDeclaration" | "ClassExpression" | "ClassImplements" | "ClassMethod" | "ClassPrivateMethod" | "ClassPrivateProperty" | "ClassProperty" | "ConditionalExpression" | "ContinueStatement" | "DebuggerStatement" | "DecimalLiteral" | "DeclareClass" | "DeclareExportAllDeclaration" | "DeclareExportDeclaration" | "DeclareFunction" | "DeclareInterface" | "DeclareModule" | "DeclareModuleExports" | "DeclareOpaqueType" | "DeclareTypeAlias" | "DeclareVariable" | "DeclaredPredicate" | "Decorator" | "Directive" | "DirectiveLiteral" | "DoExpression" | "DoWhileStatement" | "EmptyStatement" | "EmptyTypeAnnotation" | "EnumBooleanBody" | "EnumBooleanMember" | "EnumDeclaration" | "EnumDefaultedMember" | "EnumNumberBody" | "EnumNumberMember" | "EnumStringBody" | "EnumStringMember" | "EnumSymbolBody" | "ExistsTypeAnnotation" | "ExportAllDeclaration" | "ExportDefaultDeclaration" | "ExportDefaultSpecifier" | "ExportNamedDeclaration" | "ExportNamespaceSpecifier" | "ExportSpecifier" | "ExpressionStatement" | "File" | "ForInStatement" | "ForOfStatement" | "ForStatement" | "FunctionDeclaration" | "FunctionExpression" | "FunctionTypeAnnotation" | "FunctionTypeParam" | "GenericTypeAnnotation" | "Identifier" | "IfStatement" | "Import" | "ImportAttribute" | "ImportDeclaration" | "ImportDefaultSpecifier" | "ImportNamespaceSpecifier" | "ImportSpecifier" | "IndexedAccessType" | "InferredPredicate" | "InterfaceDeclaration" | "InterfaceExtends" | "InterfaceTypeAnnotation" | "InterpreterDirective" | "IntersectionTypeAnnotation" | "JSXAttribute" | "JSXClosingElement" | "JSXClosingFragment" | "JSXElement" | "JSXEmptyExpression" | "JSXExpressionContainer" | "JSXFragment" | "JSXIdentifier" | "JSXMemberExpression" | "JSXNamespacedName" | "JSXOpeningElement" | "JSXOpeningFragment" | "JSXSpreadAttribute" | "JSXSpreadChild" | "JSXText" | "LabeledStatement" | "LogicalExpression" | "MemberExpression" | "MetaProperty" | "MixedTypeAnnotation" | "ModuleExpression" | "NewExpression" | "Noop" | "NullLiteral" | "NullLiteralTypeAnnotation" | "NullableTypeAnnotation" | "NumberLiteral" | "NumberLiteralTypeAnnotation" | "NumberTypeAnnotation" | "NumericLiteral" | "ObjectExpression" | "ObjectMethod" | "ObjectPattern" | "ObjectProperty" | "ObjectTypeAnnotation" | "ObjectTypeCallProperty" | "ObjectTypeIndexer" | "ObjectTypeInternalSlot" | "ObjectTypeProperty" | "ObjectTypeSpreadProperty" | "OpaqueType" | "OptionalCallExpression" | "OptionalIndexedAccessType" | "OptionalMemberExpression" | "ParenthesizedExpression" | "PipelineBareFunction" | "PipelinePrimaryTopicReference" | "PipelineTopicExpression" | "Placeholder" | "PrivateName" | "Program" | "QualifiedTypeIdentifier" | "RecordExpression" | "RegExpLiteral" | "RegexLiteral" | "RestElement" | "RestProperty" | "ReturnStatement" | "SequenceExpression" | "SpreadElement" | "SpreadProperty" | "StaticBlock" | "StringLiteral" | "StringLiteralTypeAnnotation" | "StringTypeAnnotation" | "Super" | "SwitchCase" | "SwitchStatement" | "SymbolTypeAnnotation" | "TSAnyKeyword" | "TSArrayType" | "TSAsExpression" | "TSBigIntKeyword" | "TSBooleanKeyword" | "TSCallSignatureDeclaration" | "TSConditionalType" | "TSConstructSignatureDeclaration" | "TSConstructorType" | "TSDeclareFunction" | "TSDeclareMethod" | "TSEnumDeclaration" | "TSEnumMember" | "TSExportAssignment" | "TSExpressionWithTypeArguments" | "TSExternalModuleReference" | "TSFunctionType" | "TSImportEqualsDeclaration" | "TSImportType" | "TSIndexSignature" | "TSIndexedAccessType" | "TSInferType" | "TSInstantiationExpression" | "TSInterfaceBody" | "TSInterfaceDeclaration" | "TSIntersectionType" | "TSIntrinsicKeyword" | "TSLiteralType" | "TSMappedType" | "TSMethodSignature" | "TSModuleBlock" | "TSModuleDeclaration" | "TSNamedTupleMember" | "TSNamespaceExportDeclaration" | "TSNeverKeyword" | "TSNonNullExpression" | "TSNullKeyword" | "TSNumberKeyword" | "TSObjectKeyword" | "TSOptionalType" | "TSParameterProperty" | "TSParenthesizedType" | "TSPropertySignature" | "TSQualifiedName" | "TSRestType" | "TSSatisfiesExpression" | "TSStringKeyword" | "TSSymbolKeyword" | "TSThisType" | "TSTupleType" | "TSTypeAliasDeclaration" | "TSTypeAnnotation" | "TSTypeAssertion" | "TSTypeLiteral" | "TSTypeOperator" | "TSTypeParameter" | "TSTypeParameterDeclaration" | "TSTypeParameterInstantiation" | "TSTypePredicate" | "TSTypeQuery" | "TSTypeReference" | "TSUndefinedKeyword" | "TSUnionType" | "TSUnknownKeyword" | "TSVoidKeyword" | "TaggedTemplateExpression" | "TemplateElement" | "TemplateLiteral" | "ThisExpression" | "ThisTypeAnnotation" | "ThrowStatement" | "TopicReference" | "TryStatement" | "TupleExpression" | "TupleTypeAnnotation" | "TypeAlias" | "TypeAnnotation" | "TypeCastExpression" | "TypeParameter" | "TypeParameterDeclaration" | "TypeParameterInstantiation" | "TypeofTypeAnnotation" | "UnaryExpression" | "UnionTypeAnnotation" | "UpdateExpression" | "V8IntrinsicIdentifier" | "VariableDeclaration" | "VariableDeclarator" | "Variance" | "VoidTypeAnnotation" | "WhileStatement" | "WithStatement" | "YieldExpression" | keyof Aliases)[];
                    export type While = DoWhileStatement | WhileStatement;
                    export interface WhileStatement extends BaseNode {
                        type: "WhileStatement";
                        test: Expression;
                        body: Statement;
                    }
                    export interface WithStatement extends BaseNode {
                        type: "WithStatement";
                        object: Expression;
                        body: Statement;
                    }
                    export interface YieldExpression extends BaseNode {
                        type: "YieldExpression";
                        argument?: Expression | null;
                        delegate: boolean;
                    }
                    function __internal__deprecationWarning(oldName: string, newName: string, prefix?: string): void;
                    /**
                     * Add comment of certain type to a node.
                     */
                    function addComment<T extends Node>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T;
                    /**
                     * Add comments of certain type to a node.
                     */
                    function addComments<T extends Node>(node: T, type: CommentTypeShorthand, comments: Array<Comment>): T;
                    function anyTypeAnnotation(): AnyTypeAnnotation;
                    //# sourceMappingURL=index.d.ts.map
                    /**
                     * Append a node to a member expression.
                     */
                    function appendToMemberExpression(member: MemberExpression, append: MemberExpression["property"], computed?: boolean): MemberExpression;
                    function argumentPlaceholder(): ArgumentPlaceholder;
                    function arrayExpression(elements?: Array<null | Expression | SpreadElement>): ArrayExpression;
                    function arrayPattern(elements: Array<null | PatternLike | LVal>): ArrayPattern;
                    function arrayTypeAnnotation(elementType: FlowType): ArrayTypeAnnotation;
                    function arrowFunctionExpression(params: Array<Identifier | Pattern | RestElement>, body: BlockStatement | Expression, async?: boolean): ArrowFunctionExpression;
                    function assertAccessor(node: object | null | undefined, opts?: object | null): asserts node is Accessor;
                    function assertAnyTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is AnyTypeAnnotation;
                    function assertArgumentPlaceholder(node: object | null | undefined, opts?: object | null): asserts node is ArgumentPlaceholder;
                    function assertArrayExpression(node: object | null | undefined, opts?: object | null): asserts node is ArrayExpression;
                    function assertArrayPattern(node: object | null | undefined, opts?: object | null): asserts node is ArrayPattern;
                    function assertArrayTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ArrayTypeAnnotation;
                    function assertArrowFunctionExpression(node: object | null | undefined, opts?: object | null): asserts node is ArrowFunctionExpression;
                    function assertAssignmentExpression(node: object | null | undefined, opts?: object | null): asserts node is AssignmentExpression;
                    function assertAssignmentPattern(node: object | null | undefined, opts?: object | null): asserts node is AssignmentPattern;
                    function assertAwaitExpression(node: object | null | undefined, opts?: object | null): asserts node is AwaitExpression;
                    function assertBigIntLiteral(node: object | null | undefined, opts?: object | null): asserts node is BigIntLiteral;
                    function assertBinary(node: object | null | undefined, opts?: object | null): asserts node is Binary;
                    function assertBinaryExpression(node: object | null | undefined, opts?: object | null): asserts node is BinaryExpression;
                    function assertBindExpression(node: object | null | undefined, opts?: object | null): asserts node is BindExpression;
                    function assertBlock(node: object | null | undefined, opts?: object | null): asserts node is Block;
                    function assertBlockParent(node: object | null | undefined, opts?: object | null): asserts node is BlockParent;
                    function assertBlockStatement(node: object | null | undefined, opts?: object | null): asserts node is BlockStatement;
                    function assertBooleanLiteral(node: object | null | undefined, opts?: object | null): asserts node is BooleanLiteral;
                    function assertBooleanLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is BooleanLiteralTypeAnnotation;
                    function assertBooleanTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is BooleanTypeAnnotation;
                    function assertBreakStatement(node: object | null | undefined, opts?: object | null): asserts node is BreakStatement;
                    function assertCallExpression(node: object | null | undefined, opts?: object | null): asserts node is CallExpression;
                    function assertCatchClause(node: object | null | undefined, opts?: object | null): asserts node is CatchClause;
                    function assertClass(node: object | null | undefined, opts?: object | null): asserts node is Class;
                    function assertClassAccessorProperty(node: object | null | undefined, opts?: object | null): asserts node is ClassAccessorProperty;
                    function assertClassBody(node: object | null | undefined, opts?: object | null): asserts node is ClassBody;
                    function assertClassDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ClassDeclaration;
                    function assertClassExpression(node: object | null | undefined, opts?: object | null): asserts node is ClassExpression;
                    function assertClassImplements(node: object | null | undefined, opts?: object | null): asserts node is ClassImplements;
                    function assertClassMethod(node: object | null | undefined, opts?: object | null): asserts node is ClassMethod;
                    function assertClassPrivateMethod(node: object | null | undefined, opts?: object | null): asserts node is ClassPrivateMethod;
                    function assertClassPrivateProperty(node: object | null | undefined, opts?: object | null): asserts node is ClassPrivateProperty;
                    function assertClassProperty(node: object | null | undefined, opts?: object | null): asserts node is ClassProperty;
                    function assertCompletionStatement(node: object | null | undefined, opts?: object | null): asserts node is CompletionStatement;
                    function assertConditional(node: object | null | undefined, opts?: object | null): asserts node is Conditional;
                    function assertConditionalExpression(node: object | null | undefined, opts?: object | null): asserts node is ConditionalExpression;
                    function assertContinueStatement(node: object | null | undefined, opts?: object | null): asserts node is ContinueStatement;
                    function assertDebuggerStatement(node: object | null | undefined, opts?: object | null): asserts node is DebuggerStatement;
                    function assertDecimalLiteral(node: object | null | undefined, opts?: object | null): asserts node is DecimalLiteral;
                    function assertDeclaration(node: object | null | undefined, opts?: object | null): asserts node is Declaration;
                    function assertDeclareClass(node: object | null | undefined, opts?: object | null): asserts node is DeclareClass;
                    function assertDeclareExportAllDeclaration(node: object | null | undefined, opts?: object | null): asserts node is DeclareExportAllDeclaration;
                    function assertDeclareExportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is DeclareExportDeclaration;
                    function assertDeclareFunction(node: object | null | undefined, opts?: object | null): asserts node is DeclareFunction;
                    function assertDeclareInterface(node: object | null | undefined, opts?: object | null): asserts node is DeclareInterface;
                    function assertDeclareModule(node: object | null | undefined, opts?: object | null): asserts node is DeclareModule;
                    function assertDeclareModuleExports(node: object | null | undefined, opts?: object | null): asserts node is DeclareModuleExports;
                    function assertDeclareOpaqueType(node: object | null | undefined, opts?: object | null): asserts node is DeclareOpaqueType;
                    function assertDeclareTypeAlias(node: object | null | undefined, opts?: object | null): asserts node is DeclareTypeAlias;
                    function assertDeclareVariable(node: object | null | undefined, opts?: object | null): asserts node is DeclareVariable;
                    function assertDeclaredPredicate(node: object | null | undefined, opts?: object | null): asserts node is DeclaredPredicate;
                    function assertDecorator(node: object | null | undefined, opts?: object | null): asserts node is Decorator;
                    function assertDirective(node: object | null | undefined, opts?: object | null): asserts node is Directive;
                    function assertDirectiveLiteral(node: object | null | undefined, opts?: object | null): asserts node is DirectiveLiteral;
                    function assertDoExpression(node: object | null | undefined, opts?: object | null): asserts node is DoExpression;
                    function assertDoWhileStatement(node: object | null | undefined, opts?: object | null): asserts node is DoWhileStatement;
                    function assertEmptyStatement(node: object | null | undefined, opts?: object | null): asserts node is EmptyStatement;
                    function assertEmptyTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is EmptyTypeAnnotation;
                    function assertEnumBody(node: object | null | undefined, opts?: object | null): asserts node is EnumBody;
                    function assertEnumBooleanBody(node: object | null | undefined, opts?: object | null): asserts node is EnumBooleanBody;
                    function assertEnumBooleanMember(node: object | null | undefined, opts?: object | null): asserts node is EnumBooleanMember;
                    function assertEnumDeclaration(node: object | null | undefined, opts?: object | null): asserts node is EnumDeclaration;
                    function assertEnumDefaultedMember(node: object | null | undefined, opts?: object | null): asserts node is EnumDefaultedMember;
                    function assertEnumMember(node: object | null | undefined, opts?: object | null): asserts node is EnumMember;
                    function assertEnumNumberBody(node: object | null | undefined, opts?: object | null): asserts node is EnumNumberBody;
                    function assertEnumNumberMember(node: object | null | undefined, opts?: object | null): asserts node is EnumNumberMember;
                    function assertEnumStringBody(node: object | null | undefined, opts?: object | null): asserts node is EnumStringBody;
                    function assertEnumStringMember(node: object | null | undefined, opts?: object | null): asserts node is EnumStringMember;
                    function assertEnumSymbolBody(node: object | null | undefined, opts?: object | null): asserts node is EnumSymbolBody;
                    function assertExistsTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ExistsTypeAnnotation;
                    function assertExportAllDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportAllDeclaration;
                    function assertExportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportDeclaration;
                    function assertExportDefaultDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportDefaultDeclaration;
                    function assertExportDefaultSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ExportDefaultSpecifier;
                    function assertExportNamedDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ExportNamedDeclaration;
                    function assertExportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ExportNamespaceSpecifier;
                    function assertExportSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ExportSpecifier;
                    function assertExpression(node: object | null | undefined, opts?: object | null): asserts node is Expression;
                    function assertExpressionStatement(node: object | null | undefined, opts?: object | null): asserts node is ExpressionStatement;
                    function assertExpressionWrapper(node: object | null | undefined, opts?: object | null): asserts node is ExpressionWrapper;
                    function assertFile(node: object | null | undefined, opts?: object | null): asserts node is File;
                    function assertFlow(node: object | null | undefined, opts?: object | null): asserts node is Flow;
                    function assertFlowBaseAnnotation(node: object | null | undefined, opts?: object | null): asserts node is FlowBaseAnnotation;
                    function assertFlowDeclaration(node: object | null | undefined, opts?: object | null): asserts node is FlowDeclaration;
                    function assertFlowPredicate(node: object | null | undefined, opts?: object | null): asserts node is FlowPredicate;
                    function assertFlowType(node: object | null | undefined, opts?: object | null): asserts node is FlowType;
                    function assertFor(node: object | null | undefined, opts?: object | null): asserts node is For;
                    function assertForInStatement(node: object | null | undefined, opts?: object | null): asserts node is ForInStatement;
                    function assertForOfStatement(node: object | null | undefined, opts?: object | null): asserts node is ForOfStatement;
                    function assertForStatement(node: object | null | undefined, opts?: object | null): asserts node is ForStatement;
                    function assertForXStatement(node: object | null | undefined, opts?: object | null): asserts node is ForXStatement;
                    function assertFunction(node: object | null | undefined, opts?: object | null): asserts node is Function;
                    function assertFunctionDeclaration(node: object | null | undefined, opts?: object | null): asserts node is FunctionDeclaration;
                    function assertFunctionExpression(node: object | null | undefined, opts?: object | null): asserts node is FunctionExpression;
                    function assertFunctionParent(node: object | null | undefined, opts?: object | null): asserts node is FunctionParent;
                    function assertFunctionTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is FunctionTypeAnnotation;
                    function assertFunctionTypeParam(node: object | null | undefined, opts?: object | null): asserts node is FunctionTypeParam;
                    function assertGenericTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is GenericTypeAnnotation;
                    function assertIdentifier(node: object | null | undefined, opts?: object | null): asserts node is Identifier;
                    function assertIfStatement(node: object | null | undefined, opts?: object | null): asserts node is IfStatement;
                    function assertImmutable(node: object | null | undefined, opts?: object | null): asserts node is Immutable;
                    function assertImport(node: object | null | undefined, opts?: object | null): asserts node is Import;
                    function assertImportAttribute(node: object | null | undefined, opts?: object | null): asserts node is ImportAttribute;
                    function assertImportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ImportDeclaration;
                    function assertImportDefaultSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ImportDefaultSpecifier;
                    function assertImportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ImportNamespaceSpecifier;
                    function assertImportOrExportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is ImportOrExportDeclaration;
                    function assertImportSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ImportSpecifier;
                    function assertIndexedAccessType(node: object | null | undefined, opts?: object | null): asserts node is IndexedAccessType;
                    function assertInferredPredicate(node: object | null | undefined, opts?: object | null): asserts node is InferredPredicate;
                    function assertInterfaceDeclaration(node: object | null | undefined, opts?: object | null): asserts node is InterfaceDeclaration;
                    function assertInterfaceExtends(node: object | null | undefined, opts?: object | null): asserts node is InterfaceExtends;
                    function assertInterfaceTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is InterfaceTypeAnnotation;
                    function assertInterpreterDirective(node: object | null | undefined, opts?: object | null): asserts node is InterpreterDirective;
                    function assertIntersectionTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is IntersectionTypeAnnotation;
                    function assertJSX(node: object | null | undefined, opts?: object | null): asserts node is JSX;
                    function assertJSXAttribute(node: object | null | undefined, opts?: object | null): asserts node is JSXAttribute;
                    function assertJSXClosingElement(node: object | null | undefined, opts?: object | null): asserts node is JSXClosingElement;
                    function assertJSXClosingFragment(node: object | null | undefined, opts?: object | null): asserts node is JSXClosingFragment;
                    function assertJSXElement(node: object | null | undefined, opts?: object | null): asserts node is JSXElement;
                    function assertJSXEmptyExpression(node: object | null | undefined, opts?: object | null): asserts node is JSXEmptyExpression;
                    function assertJSXExpressionContainer(node: object | null | undefined, opts?: object | null): asserts node is JSXExpressionContainer;
                    function assertJSXFragment(node: object | null | undefined, opts?: object | null): asserts node is JSXFragment;
                    function assertJSXIdentifier(node: object | null | undefined, opts?: object | null): asserts node is JSXIdentifier;
                    function assertJSXMemberExpression(node: object | null | undefined, opts?: object | null): asserts node is JSXMemberExpression;
                    function assertJSXNamespacedName(node: object | null | undefined, opts?: object | null): asserts node is JSXNamespacedName;
                    function assertJSXOpeningElement(node: object | null | undefined, opts?: object | null): asserts node is JSXOpeningElement;
                    function assertJSXOpeningFragment(node: object | null | undefined, opts?: object | null): asserts node is JSXOpeningFragment;
                    function assertJSXSpreadAttribute(node: object | null | undefined, opts?: object | null): asserts node is JSXSpreadAttribute;
                    function assertJSXSpreadChild(node: object | null | undefined, opts?: object | null): asserts node is JSXSpreadChild;
                    function assertJSXText(node: object | null | undefined, opts?: object | null): asserts node is JSXText;
                    function assertLVal(node: object | null | undefined, opts?: object | null): asserts node is LVal;
                    function assertLabeledStatement(node: object | null | undefined, opts?: object | null): asserts node is LabeledStatement;
                    function assertLiteral(node: object | null | undefined, opts?: object | null): asserts node is Literal;
                    function assertLogicalExpression(node: object | null | undefined, opts?: object | null): asserts node is LogicalExpression;
                    function assertLoop(node: object | null | undefined, opts?: object | null): asserts node is Loop;
                    function assertMemberExpression(node: object | null | undefined, opts?: object | null): asserts node is MemberExpression;
                    function assertMetaProperty(node: object | null | undefined, opts?: object | null): asserts node is MetaProperty;
                    function assertMethod(node: object | null | undefined, opts?: object | null): asserts node is Method;
                    function assertMiscellaneous(node: object | null | undefined, opts?: object | null): asserts node is Miscellaneous;
                    function assertMixedTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is MixedTypeAnnotation;
                    function assertModuleDeclaration(node: any, opts: any): void;
                    function assertModuleExpression(node: object | null | undefined, opts?: object | null): asserts node is ModuleExpression;
                    function assertModuleSpecifier(node: object | null | undefined, opts?: object | null): asserts node is ModuleSpecifier;
                    function assertNewExpression(node: object | null | undefined, opts?: object | null): asserts node is NewExpression;
                    function assertNode(node?: any): asserts node is Node;
                    function assertNoop(node: object | null | undefined, opts?: object | null): asserts node is Noop;
                    function assertNullLiteral(node: object | null | undefined, opts?: object | null): asserts node is NullLiteral;
                    function assertNullLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NullLiteralTypeAnnotation;
                    function assertNullableTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NullableTypeAnnotation;
                    function assertNumberLiteral(node: any, opts: any): void;
                    function assertNumberLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NumberLiteralTypeAnnotation;
                    function assertNumberTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is NumberTypeAnnotation;
                    function assertNumericLiteral(node: object | null | undefined, opts?: object | null): asserts node is NumericLiteral;
                    function assertObjectExpression(node: object | null | undefined, opts?: object | null): asserts node is ObjectExpression;
                    function assertObjectMember(node: object | null | undefined, opts?: object | null): asserts node is ObjectMember;
                    function assertObjectMethod(node: object | null | undefined, opts?: object | null): asserts node is ObjectMethod;
                    function assertObjectPattern(node: object | null | undefined, opts?: object | null): asserts node is ObjectPattern;
                    function assertObjectProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectProperty;
                    function assertObjectTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeAnnotation;
                    function assertObjectTypeCallProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeCallProperty;
                    function assertObjectTypeIndexer(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeIndexer;
                    function assertObjectTypeInternalSlot(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeInternalSlot;
                    function assertObjectTypeProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeProperty;
                    function assertObjectTypeSpreadProperty(node: object | null | undefined, opts?: object | null): asserts node is ObjectTypeSpreadProperty;
                    function assertOpaqueType(node: object | null | undefined, opts?: object | null): asserts node is OpaqueType;
                    function assertOptionalCallExpression(node: object | null | undefined, opts?: object | null): asserts node is OptionalCallExpression;
                    function assertOptionalIndexedAccessType(node: object | null | undefined, opts?: object | null): asserts node is OptionalIndexedAccessType;
                    function assertOptionalMemberExpression(node: object | null | undefined, opts?: object | null): asserts node is OptionalMemberExpression;
                    function assertParenthesizedExpression(node: object | null | undefined, opts?: object | null): asserts node is ParenthesizedExpression;
                    function assertPattern(node: object | null | undefined, opts?: object | null): asserts node is Pattern;
                    function assertPatternLike(node: object | null | undefined, opts?: object | null): asserts node is PatternLike;
                    function assertPipelineBareFunction(node: object | null | undefined, opts?: object | null): asserts node is PipelineBareFunction;
                    function assertPipelinePrimaryTopicReference(node: object | null | undefined, opts?: object | null): asserts node is PipelinePrimaryTopicReference;
                    function assertPipelineTopicExpression(node: object | null | undefined, opts?: object | null): asserts node is PipelineTopicExpression;
                    function assertPlaceholder(node: object | null | undefined, opts?: object | null): asserts node is Placeholder;
                    function assertPrivate(node: object | null | undefined, opts?: object | null): asserts node is Private;
                    function assertPrivateName(node: object | null | undefined, opts?: object | null): asserts node is PrivateName;
                    function assertProgram(node: object | null | undefined, opts?: object | null): asserts node is Program;
                    function assertProperty(node: object | null | undefined, opts?: object | null): asserts node is Property;
                    function assertPureish(node: object | null | undefined, opts?: object | null): asserts node is Pureish;
                    function assertQualifiedTypeIdentifier(node: object | null | undefined, opts?: object | null): asserts node is QualifiedTypeIdentifier;
                    function assertRecordExpression(node: object | null | undefined, opts?: object | null): asserts node is RecordExpression;
                    function assertRegExpLiteral(node: object | null | undefined, opts?: object | null): asserts node is RegExpLiteral;
                    function assertRegexLiteral(node: any, opts: any): void;
                    function assertRestElement(node: object | null | undefined, opts?: object | null): asserts node is RestElement;
                    function assertRestProperty(node: any, opts: any): void;
                    function assertReturnStatement(node: object | null | undefined, opts?: object | null): asserts node is ReturnStatement;
                    function assertScopable(node: object | null | undefined, opts?: object | null): asserts node is Scopable;
                    function assertSequenceExpression(node: object | null | undefined, opts?: object | null): asserts node is SequenceExpression;
                    function assertSpreadElement(node: object | null | undefined, opts?: object | null): asserts node is SpreadElement;
                    function assertSpreadProperty(node: any, opts: any): void;
                    function assertStandardized(node: object | null | undefined, opts?: object | null): asserts node is Standardized;
                    function assertStatement(node: object | null | undefined, opts?: object | null): asserts node is Statement;
                    function assertStaticBlock(node: object | null | undefined, opts?: object | null): asserts node is StaticBlock;
                    function assertStringLiteral(node: object | null | undefined, opts?: object | null): asserts node is StringLiteral;
                    function assertStringLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is StringLiteralTypeAnnotation;
                    function assertStringTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is StringTypeAnnotation;
                    function assertSuper(node: object | null | undefined, opts?: object | null): asserts node is Super;
                    function assertSwitchCase(node: object | null | undefined, opts?: object | null): asserts node is SwitchCase;
                    function assertSwitchStatement(node: object | null | undefined, opts?: object | null): asserts node is SwitchStatement;
                    function assertSymbolTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is SymbolTypeAnnotation;
                    function assertTSAnyKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSAnyKeyword;
                    function assertTSArrayType(node: object | null | undefined, opts?: object | null): asserts node is TSArrayType;
                    function assertTSAsExpression(node: object | null | undefined, opts?: object | null): asserts node is TSAsExpression;
                    function assertTSBaseType(node: object | null | undefined, opts?: object | null): asserts node is TSBaseType;
                    function assertTSBigIntKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSBigIntKeyword;
                    function assertTSBooleanKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSBooleanKeyword;
                    function assertTSCallSignatureDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSCallSignatureDeclaration;
                    function assertTSConditionalType(node: object | null | undefined, opts?: object | null): asserts node is TSConditionalType;
                    function assertTSConstructSignatureDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSConstructSignatureDeclaration;
                    function assertTSConstructorType(node: object | null | undefined, opts?: object | null): asserts node is TSConstructorType;
                    function assertTSDeclareFunction(node: object | null | undefined, opts?: object | null): asserts node is TSDeclareFunction;
                    function assertTSDeclareMethod(node: object | null | undefined, opts?: object | null): asserts node is TSDeclareMethod;
                    function assertTSEntityName(node: object | null | undefined, opts?: object | null): asserts node is TSEntityName;
                    function assertTSEnumDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSEnumDeclaration;
                    function assertTSEnumMember(node: object | null | undefined, opts?: object | null): asserts node is TSEnumMember;
                    function assertTSExportAssignment(node: object | null | undefined, opts?: object | null): asserts node is TSExportAssignment;
                    function assertTSExpressionWithTypeArguments(node: object | null | undefined, opts?: object | null): asserts node is TSExpressionWithTypeArguments;
                    function assertTSExternalModuleReference(node: object | null | undefined, opts?: object | null): asserts node is TSExternalModuleReference;
                    function assertTSFunctionType(node: object | null | undefined, opts?: object | null): asserts node is TSFunctionType;
                    function assertTSImportEqualsDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSImportEqualsDeclaration;
                    function assertTSImportType(node: object | null | undefined, opts?: object | null): asserts node is TSImportType;
                    function assertTSIndexSignature(node: object | null | undefined, opts?: object | null): asserts node is TSIndexSignature;
                    function assertTSIndexedAccessType(node: object | null | undefined, opts?: object | null): asserts node is TSIndexedAccessType;
                    function assertTSInferType(node: object | null | undefined, opts?: object | null): asserts node is TSInferType;
                    function assertTSInstantiationExpression(node: object | null | undefined, opts?: object | null): asserts node is TSInstantiationExpression;
                    function assertTSInterfaceBody(node: object | null | undefined, opts?: object | null): asserts node is TSInterfaceBody;
                    function assertTSInterfaceDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSInterfaceDeclaration;
                    function assertTSIntersectionType(node: object | null | undefined, opts?: object | null): asserts node is TSIntersectionType;
                    function assertTSIntrinsicKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSIntrinsicKeyword;
                    function assertTSLiteralType(node: object | null | undefined, opts?: object | null): asserts node is TSLiteralType;
                    function assertTSMappedType(node: object | null | undefined, opts?: object | null): asserts node is TSMappedType;
                    function assertTSMethodSignature(node: object | null | undefined, opts?: object | null): asserts node is TSMethodSignature;
                    function assertTSModuleBlock(node: object | null | undefined, opts?: object | null): asserts node is TSModuleBlock;
                    function assertTSModuleDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSModuleDeclaration;
                    function assertTSNamedTupleMember(node: object | null | undefined, opts?: object | null): asserts node is TSNamedTupleMember;
                    function assertTSNamespaceExportDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSNamespaceExportDeclaration;
                    function assertTSNeverKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSNeverKeyword;
                    function assertTSNonNullExpression(node: object | null | undefined, opts?: object | null): asserts node is TSNonNullExpression;
                    function assertTSNullKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSNullKeyword;
                    function assertTSNumberKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSNumberKeyword;
                    function assertTSObjectKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSObjectKeyword;
                    function assertTSOptionalType(node: object | null | undefined, opts?: object | null): asserts node is TSOptionalType;
                    function assertTSParameterProperty(node: object | null | undefined, opts?: object | null): asserts node is TSParameterProperty;
                    function assertTSParenthesizedType(node: object | null | undefined, opts?: object | null): asserts node is TSParenthesizedType;
                    function assertTSPropertySignature(node: object | null | undefined, opts?: object | null): asserts node is TSPropertySignature;
                    function assertTSQualifiedName(node: object | null | undefined, opts?: object | null): asserts node is TSQualifiedName;
                    function assertTSRestType(node: object | null | undefined, opts?: object | null): asserts node is TSRestType;
                    function assertTSSatisfiesExpression(node: object | null | undefined, opts?: object | null): asserts node is TSSatisfiesExpression;
                    function assertTSStringKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSStringKeyword;
                    function assertTSSymbolKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSSymbolKeyword;
                    function assertTSThisType(node: object | null | undefined, opts?: object | null): asserts node is TSThisType;
                    function assertTSTupleType(node: object | null | undefined, opts?: object | null): asserts node is TSTupleType;
                    function assertTSType(node: object | null | undefined, opts?: object | null): asserts node is TSType;
                    function assertTSTypeAliasDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSTypeAliasDeclaration;
                    function assertTSTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TSTypeAnnotation;
                    function assertTSTypeAssertion(node: object | null | undefined, opts?: object | null): asserts node is TSTypeAssertion;
                    function assertTSTypeElement(node: object | null | undefined, opts?: object | null): asserts node is TSTypeElement;
                    function assertTSTypeLiteral(node: object | null | undefined, opts?: object | null): asserts node is TSTypeLiteral;
                    function assertTSTypeOperator(node: object | null | undefined, opts?: object | null): asserts node is TSTypeOperator;
                    function assertTSTypeParameter(node: object | null | undefined, opts?: object | null): asserts node is TSTypeParameter;
                    function assertTSTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TSTypeParameterDeclaration;
                    function assertTSTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): asserts node is TSTypeParameterInstantiation;
                    function assertTSTypePredicate(node: object | null | undefined, opts?: object | null): asserts node is TSTypePredicate;
                    function assertTSTypeQuery(node: object | null | undefined, opts?: object | null): asserts node is TSTypeQuery;
                    function assertTSTypeReference(node: object | null | undefined, opts?: object | null): asserts node is TSTypeReference;
                    function assertTSUndefinedKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSUndefinedKeyword;
                    function assertTSUnionType(node: object | null | undefined, opts?: object | null): asserts node is TSUnionType;
                    function assertTSUnknownKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSUnknownKeyword;
                    function assertTSVoidKeyword(node: object | null | undefined, opts?: object | null): asserts node is TSVoidKeyword;
                    function assertTaggedTemplateExpression(node: object | null | undefined, opts?: object | null): asserts node is TaggedTemplateExpression;
                    function assertTemplateElement(node: object | null | undefined, opts?: object | null): asserts node is TemplateElement;
                    function assertTemplateLiteral(node: object | null | undefined, opts?: object | null): asserts node is TemplateLiteral;
                    function assertTerminatorless(node: object | null | undefined, opts?: object | null): asserts node is Terminatorless;
                    function assertThisExpression(node: object | null | undefined, opts?: object | null): asserts node is ThisExpression;
                    function assertThisTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is ThisTypeAnnotation;
                    function assertThrowStatement(node: object | null | undefined, opts?: object | null): asserts node is ThrowStatement;
                    function assertTopicReference(node: object | null | undefined, opts?: object | null): asserts node is TopicReference;
                    function assertTryStatement(node: object | null | undefined, opts?: object | null): asserts node is TryStatement;
                    function assertTupleExpression(node: object | null | undefined, opts?: object | null): asserts node is TupleExpression;
                    function assertTupleTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TupleTypeAnnotation;
                    function assertTypeAlias(node: object | null | undefined, opts?: object | null): asserts node is TypeAlias;
                    function assertTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TypeAnnotation;
                    function assertTypeCastExpression(node: object | null | undefined, opts?: object | null): asserts node is TypeCastExpression;
                    function assertTypeParameter(node: object | null | undefined, opts?: object | null): asserts node is TypeParameter;
                    function assertTypeParameterDeclaration(node: object | null | undefined, opts?: object | null): asserts node is TypeParameterDeclaration;
                    function assertTypeParameterInstantiation(node: object | null | undefined, opts?: object | null): asserts node is TypeParameterInstantiation;
                    function assertTypeScript(node: object | null | undefined, opts?: object | null): asserts node is TypeScript;
                    function assertTypeofTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is TypeofTypeAnnotation;
                    function assertUnaryExpression(node: object | null | undefined, opts?: object | null): asserts node is UnaryExpression;
                    function assertUnaryLike(node: object | null | undefined, opts?: object | null): asserts node is UnaryLike;
                    function assertUnionTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is UnionTypeAnnotation;
                    function assertUpdateExpression(node: object | null | undefined, opts?: object | null): asserts node is UpdateExpression;
                    function assertUserWhitespacable(node: object | null | undefined, opts?: object | null): asserts node is UserWhitespacable;
                    function assertV8IntrinsicIdentifier(node: object | null | undefined, opts?: object | null): asserts node is V8IntrinsicIdentifier;
                    function assertVariableDeclaration(node: object | null | undefined, opts?: object | null): asserts node is VariableDeclaration;
                    function assertVariableDeclarator(node: object | null | undefined, opts?: object | null): asserts node is VariableDeclarator;
                    function assertVariance(node: object | null | undefined, opts?: object | null): asserts node is Variance;
                    function assertVoidTypeAnnotation(node: object | null | undefined, opts?: object | null): asserts node is VoidTypeAnnotation;
                    function assertWhile(node: object | null | undefined, opts?: object | null): asserts node is While;
                    function assertWhileStatement(node: object | null | undefined, opts?: object | null): asserts node is WhileStatement;
                    function assertWithStatement(node: object | null | undefined, opts?: object | null): asserts node is WithStatement;
                    function assertYieldExpression(node: object | null | undefined, opts?: object | null): asserts node is YieldExpression;
                    function assignmentExpression(operator: string, left: LVal, right: Expression): AssignmentExpression;
                    function assignmentPattern(left: Identifier | ObjectPattern | ArrayPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression, right: Expression): AssignmentPattern;
                    function awaitExpression(argument: Expression): AwaitExpression;
                    function bigIntLiteral(value: string): BigIntLiteral;
                    function binaryExpression(operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=" | "|>", left: Expression | PrivateName, right: Expression): BinaryExpression;
                    function bindExpression(object: Expression, callee: Expression): BindExpression;
                    function blockStatement(body: Array<Statement>, directives?: Array<Directive>): BlockStatement;
                    function booleanLiteral(value: boolean): BooleanLiteral;
                    function booleanLiteralTypeAnnotation(value: boolean): BooleanLiteralTypeAnnotation;
                    function booleanTypeAnnotation(): BooleanTypeAnnotation;
                    function breakStatement(label?: Identifier | null): BreakStatement;
                    /**
                     * Build a function that when called will return whether or not the
                     * input `node` `MemberExpression` matches the input `match`.
                     *
                     * For example, given the match `React.createClass` it would match the
                     * parsed nodes of `React.createClass` and `React["createClass"]`.
                     */
                    function buildMatchMemberExpression(match: string, allowPartial?: boolean): (member: Node) => boolean;
                    function callExpression(callee: Expression | Super | V8IntrinsicIdentifier, _arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>): CallExpression;
                    function catchClause(param: Identifier | ArrayPattern | ObjectPattern | null | undefined, body: BlockStatement): CatchClause;
                    function classAccessorProperty(key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression | PrivateName, value?: Expression | null, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null, decorators?: Array<Decorator> | null, computed?: boolean, _static?: boolean): ClassAccessorProperty;
                    function classBody(body: Array<ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | ClassAccessorProperty | TSDeclareMethod | TSIndexSignature | StaticBlock>): ClassBody;
                    function classDeclaration(id: Identifier, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array<Decorator> | null): ClassDeclaration;
                    function classExpression(id: Identifier | null | undefined, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array<Decorator> | null): ClassExpression;
                    function classImplements(id: Identifier, typeParameters?: TypeParameterInstantiation | null): ClassImplements;
                    function classMethod(kind: "get" | "set" | "method" | "constructor" | undefined, key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement, computed?: boolean, _static?: boolean, generator?: boolean, async?: boolean): ClassMethod;
                    function classPrivateMethod(kind: "get" | "set" | "method" | undefined, key: PrivateName, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, body: BlockStatement, _static?: boolean): ClassPrivateMethod;
                    function classPrivateProperty(key: PrivateName, value?: Expression | null, decorators?: Array<Decorator> | null, _static?: boolean): ClassPrivateProperty;
                    function classProperty(key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, value?: Expression | null, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null, decorators?: Array<Decorator> | null, computed?: boolean, _static?: boolean): ClassProperty;
                    /**
                     * Create a shallow clone of a `node`, including only
                     * properties belonging to the node.
                     * @deprecated Use t.cloneNode instead.
                     */
                    function clone<T extends Node>(node: T): T;
                    /**
                     * Create a deep clone of a `node` and all of it's child nodes
                     * including only properties belonging to the node.
                     * @deprecated Use t.cloneNode instead.
                     */
                    function cloneDeep<T extends Node>(node: T): T;
                    /**
                     * Create a deep clone of a `node` and all of it's child nodes
                     * including only properties belonging to the node.
                     * excluding `_private` and location properties.
                     */
                    function cloneDeepWithoutLoc<T extends Node>(node: T): T;
                    /**
                     * Create a clone of a `node` including only properties belonging to the node.
                     * If the second parameter is `false`, cloneNode performs a shallow clone.
                     * If the third parameter is true, the cloned nodes exclude location properties.
                     */
                    function cloneNode<T extends Node>(node: T, deep?: boolean, withoutLoc?: boolean): T;
                    /**
                     * Create a shallow clone of a `node` excluding `_private` and location properties.
                     */
                    function cloneWithoutLoc<T extends Node>(node: T): T;
                    function conditionalExpression(test: Expression, consequent: Expression, alternate: Expression): ConditionalExpression;
                    function continueStatement(label?: Identifier | null): ContinueStatement;
                    //# sourceMappingURL=createTypeAnnotationBasedOnTypeof.d.ts.map
                    /**
                     * Takes an array of `types` and flattens them, removing duplicates and
                     * returns a `UnionTypeAnnotation` node containing them.
                     */
                    function createFlowUnionType<T extends FlowType>(types: [
                        T
                    ] | Array<T>): T | UnionTypeAnnotation;
                    /**
                     * Takes an array of `types` and flattens them, removing duplicates and
                     * returns a `UnionTypeAnnotation` node containing them.
                     */
                    function createTSUnionType(typeAnnotations: Array<TSTypeAnnotation | TSType>): TSType;
                    export const createTypeAnnotationBasedOnTypeof: {
                        (type: "string"): StringTypeAnnotation;
                        (type: "number"): NumberTypeAnnotation;
                        (type: "undefined"): VoidTypeAnnotation;
                        (type: "boolean"): BooleanTypeAnnotation;
                        (type: "function"): GenericTypeAnnotation;
                        (type: "object"): GenericTypeAnnotation;
                        (type: "symbol"): GenericTypeAnnotation;
                        (type: "bigint"): AnyTypeAnnotation;
                    };
                    function debuggerStatement(): DebuggerStatement;
                    function decimalLiteral(value: string): DecimalLiteral;
                    function declareClass(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): DeclareClass;
                    function declareExportAllDeclaration(source: StringLiteral): DeclareExportAllDeclaration;
                    function declareExportDeclaration(declaration?: Flow | null, specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null, source?: StringLiteral | null): DeclareExportDeclaration;
                    function declareFunction(id: Identifier): DeclareFunction;
                    function declareInterface(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): DeclareInterface;
                    function declareModule(id: Identifier | StringLiteral, body: BlockStatement, kind?: "CommonJS" | "ES" | null): DeclareModule;
                    function declareModuleExports(typeAnnotation: TypeAnnotation): DeclareModuleExports;
                    function declareOpaqueType(id: Identifier, typeParameters?: TypeParameterDeclaration | null, supertype?: FlowType | null): DeclareOpaqueType;
                    function declareTypeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): DeclareTypeAlias;
                    function declareVariable(id: Identifier): DeclareVariable;
                    function declaredPredicate(value: Flow): DeclaredPredicate;
                    function decorator(expression: Expression): Decorator;
                    function directive(value: DirectiveLiteral): Directive;
                    function directiveLiteral(value: string): DirectiveLiteral;
                    function doExpression(body: BlockStatement, async?: boolean): DoExpression;
                    function doWhileStatement(test: Expression, body: Statement): DoWhileStatement;
                    function emptyStatement(): EmptyStatement;
                    function emptyTypeAnnotation(): EmptyTypeAnnotation;
                    /**
                     * Ensure the `key` (defaults to "body") of a `node` is a block.
                     * Casting it to a block if it is not.
                     *
                     * Returns the BlockStatement
                     */
                    function ensureBlock(node: Node, key?: string): BlockStatement;
                    function enumBooleanBody(members: Array<EnumBooleanMember>): EnumBooleanBody;
                    function enumBooleanMember(id: Identifier): EnumBooleanMember;
                    function enumDeclaration(id: Identifier, body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody): EnumDeclaration;
                    function enumDefaultedMember(id: Identifier): EnumDefaultedMember;
                    function enumNumberBody(members: Array<EnumNumberMember>): EnumNumberBody;
                    function enumNumberMember(id: Identifier, init: NumericLiteral): EnumNumberMember;
                    function enumStringBody(members: Array<EnumStringMember | EnumDefaultedMember>): EnumStringBody;
                    function enumStringMember(id: Identifier, init: StringLiteral): EnumStringMember;
                    function enumSymbolBody(members: Array<EnumDefaultedMember>): EnumSymbolBody;
                    function existsTypeAnnotation(): ExistsTypeAnnotation;
                    function exportAllDeclaration(source: StringLiteral): ExportAllDeclaration;
                    function exportDefaultDeclaration(declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Expression): ExportDefaultDeclaration;
                    function exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier;
                    function exportNamedDeclaration(declaration?: Declaration | null, specifiers?: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>, source?: StringLiteral | null): ExportNamedDeclaration;
                    function exportNamespaceSpecifier(exported: Identifier): ExportNamespaceSpecifier;
                    function exportSpecifier(local: Identifier, exported: Identifier | StringLiteral): ExportSpecifier;
                    function expressionStatement(expression: Expression): ExpressionStatement;
                    function file(program: Program, comments?: Array<CommentBlock | CommentLine> | null, tokens?: Array<any> | null): File;
                    function forInStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForInStatement;
                    function forOfStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement, _await?: boolean): ForOfStatement;
                    function forStatement(init: VariableDeclaration | Expression | null | undefined, test: Expression | null | undefined, update: Expression | null | undefined, body: Statement): ForStatement;
                    function functionDeclaration(id: Identifier | null | undefined, params: Array<Identifier | Pattern | RestElement>, body: BlockStatement, generator?: boolean, async?: boolean): FunctionDeclaration;
                    function functionExpression(id: Identifier | null | undefined, params: Array<Identifier | Pattern | RestElement>, body: BlockStatement, generator?: boolean, async?: boolean): FunctionExpression;
                    function functionTypeAnnotation(typeParameters: TypeParameterDeclaration | null | undefined, params: Array<FunctionTypeParam>, rest: FunctionTypeParam | null | undefined, returnType: FlowType): FunctionTypeAnnotation;
                    function functionTypeParam(name: Identifier | null | undefined, typeAnnotation: FlowType): FunctionTypeParam;
                    function genericTypeAnnotation(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): GenericTypeAnnotation;
                    function getBindingIdentifiers(node: Node, duplicates: true, outerOnly?: boolean): Record<string, Array<Identifier>>;
                    function getBindingIdentifiers(node: Node, duplicates?: false, outerOnly?: boolean): Record<string, Identifier>;
                    function getBindingIdentifiers(node: Node, duplicates?: boolean, outerOnly?: boolean): Record<string, Identifier> | Record<string, Array<Identifier>>;
                    export namespace getBindingIdentifiers {
                        export var keys: {
                            DeclareClass: string[];
                            DeclareFunction: string[];
                            DeclareModule: string[];
                            DeclareVariable: string[];
                            DeclareInterface: string[];
                            DeclareTypeAlias: string[];
                            DeclareOpaqueType: string[];
                            InterfaceDeclaration: string[];
                            TypeAlias: string[];
                            OpaqueType: string[];
                            CatchClause: string[];
                            LabeledStatement: string[];
                            UnaryExpression: string[];
                            AssignmentExpression: string[];
                            ImportSpecifier: string[];
                            ImportNamespaceSpecifier: string[];
                            ImportDefaultSpecifier: string[];
                            ImportDeclaration: string[];
                            ExportSpecifier: string[];
                            ExportNamespaceSpecifier: string[];
                            ExportDefaultSpecifier: string[];
                            FunctionDeclaration: string[];
                            FunctionExpression: string[];
                            ArrowFunctionExpression: string[];
                            ObjectMethod: string[];
                            ClassMethod: string[];
                            ClassPrivateMethod: string[];
                            ForInStatement: string[];
                            ForOfStatement: string[];
                            ClassDeclaration: string[];
                            ClassExpression: string[];
                            RestElement: string[];
                            UpdateExpression: string[];
                            ObjectProperty: string[];
                            AssignmentPattern: string[];
                            ArrayPattern: string[];
                            ObjectPattern: string[];
                            VariableDeclaration: string[];
                            VariableDeclarator: string[];
                        };
                    }
                    //# sourceMappingURL=getBindingIdentifiers.d.ts.map
                    export const getOuterBindingIdentifiers: {
                        (node: Node, duplicates: true): Record<string, Array<Identifier>>;
                        (node: Node, duplicates?: false): Record<string, Identifier>;
                        (node: Node, duplicates?: boolean): Record<string, Identifier> | Record<string, Array<Identifier>>;
                    };
                    function identifier(name: string): Identifier;
                    function ifStatement(test: Expression, consequent: Statement, alternate?: Statement | null): IfStatement;
                    function import(): Import;
                    function importAttribute(key: Identifier | StringLiteral, value: StringLiteral): ImportAttribute;
                    function importDeclaration(specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>, source: StringLiteral): ImportDeclaration;
                    function importDefaultSpecifier(local: Identifier): ImportDefaultSpecifier;
                    function importNamespaceSpecifier(local: Identifier): ImportNamespaceSpecifier;
                    function importSpecifier(local: Identifier, imported: Identifier | StringLiteral): ImportSpecifier;
                    function indexedAccessType(objectType: FlowType, indexType: FlowType): IndexedAccessType;
                    function inferredPredicate(): InferredPredicate;
                    function inheritInnerComments(child: Node, parent: Node): void;
                    function inheritLeadingComments(child: Node, parent: Node): void;
                    function inheritTrailingComments(child: Node, parent: Node): void;
                    /**
                     * Inherit all contextual properties from `parent` node to `child` node.
                     */
                    function inherits<T extends Node | null | undefined>(child: T, parent: Node | null | undefined): T;
                    /**
                     * Inherit all unique comments from `parent` node to `child` node.
                     */
                    function inheritsComments<T extends Node>(child: T, parent: Node): T;
                    function interfaceDeclaration(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): InterfaceDeclaration;
                    function interfaceExtends(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): InterfaceExtends;
                    function interfaceTypeAnnotation(_extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): InterfaceTypeAnnotation;
                    function interpreterDirective(value: string): InterpreterDirective;
                    function intersectionTypeAnnotation(types: Array<FlowType>): IntersectionTypeAnnotation;
                    function is<T extends Node["type"]>(type: T, node: Node | null | undefined, opts?: undefined): node is Extract<Node, {
                        type: T;
                    }>;
                    function is<T extends Node["type"], P extends Extract<Node, {
                        type: T;
                    }>>(type: T, n: Node | null | undefined, required: Partial<P>): n is P;
                    function is<P extends Node>(type: string, node: Node | null | undefined, opts: Partial<P>): node is P;
                    function is(type: string, node: Node | null | undefined, opts?: Partial<Node>): node is Node;
                    function isAccessor(node: Node | null | undefined, opts?: Opts<Accessor> | null): node is Accessor;
                    function isAnyTypeAnnotation(node: Node | null | undefined, opts?: Opts<AnyTypeAnnotation> | null): node is AnyTypeAnnotation;
                    function isArgumentPlaceholder(node: Node | null | undefined, opts?: Opts<ArgumentPlaceholder> | null): node is ArgumentPlaceholder;
                    function isArrayExpression(node: Node | null | undefined, opts?: Opts<ArrayExpression> | null): node is ArrayExpression;
                    function isArrayPattern(node: Node | null | undefined, opts?: Opts<ArrayPattern> | null): node is ArrayPattern;
                    function isArrayTypeAnnotation(node: Node | null | undefined, opts?: Opts<ArrayTypeAnnotation> | null): node is ArrayTypeAnnotation;
                    function isArrowFunctionExpression(node: Node | null | undefined, opts?: Opts<ArrowFunctionExpression> | null): node is ArrowFunctionExpression;
                    function isAssignmentExpression(node: Node | null | undefined, opts?: Opts<AssignmentExpression> | null): node is AssignmentExpression;
                    function isAssignmentPattern(node: Node | null | undefined, opts?: Opts<AssignmentPattern> | null): node is AssignmentPattern;
                    function isAwaitExpression(node: Node | null | undefined, opts?: Opts<AwaitExpression> | null): node is AwaitExpression;
                    function isBigIntLiteral(node: Node | null | undefined, opts?: Opts<BigIntLiteral> | null): node is BigIntLiteral;
                    function isBinary(node: Node | null | undefined, opts?: Opts<Binary> | null): node is Binary;
                    function isBinaryExpression(node: Node | null | undefined, opts?: Opts<BinaryExpression> | null): node is BinaryExpression;
                    function isBindExpression(node: Node | null | undefined, opts?: Opts<BindExpression> | null): node is BindExpression;
                    /**
                     * Check if the input `node` is a binding identifier.
                     */
                    function isBinding(node: Node, parent: Node, grandparent?: Node): boolean;
                    function isBlock(node: Node | null | undefined, opts?: Opts<Block> | null): node is Block;
                    function isBlockParent(node: Node | null | undefined, opts?: Opts<BlockParent> | null): node is BlockParent;
                    /**
                     * Check if the input `node` is block scoped.
                     */
                    function isBlockScoped(node: Node): boolean;
                    function isBlockStatement(node: Node | null | undefined, opts?: Opts<BlockStatement> | null): node is BlockStatement;
                    function isBooleanLiteral(node: Node | null | undefined, opts?: Opts<BooleanLiteral> | null): node is BooleanLiteral;
                    function isBooleanLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<BooleanLiteralTypeAnnotation> | null): node is BooleanLiteralTypeAnnotation;
                    function isBooleanTypeAnnotation(node: Node | null | undefined, opts?: Opts<BooleanTypeAnnotation> | null): node is BooleanTypeAnnotation;
                    function isBreakStatement(node: Node | null | undefined, opts?: Opts<BreakStatement> | null): node is BreakStatement;
                    function isCallExpression(node: Node | null | undefined, opts?: Opts<CallExpression> | null): node is CallExpression;
                    function isCatchClause(node: Node | null | undefined, opts?: Opts<CatchClause> | null): node is CatchClause;
                    function isClass(node: Node | null | undefined, opts?: Opts<Class> | null): node is Class;
                    function isClassAccessorProperty(node: Node | null | undefined, opts?: Opts<ClassAccessorProperty> | null): node is ClassAccessorProperty;
                    function isClassBody(node: Node | null | undefined, opts?: Opts<ClassBody> | null): node is ClassBody;
                    function isClassDeclaration(node: Node | null | undefined, opts?: Opts<ClassDeclaration> | null): node is ClassDeclaration;
                    function isClassExpression(node: Node | null | undefined, opts?: Opts<ClassExpression> | null): node is ClassExpression;
                    function isClassImplements(node: Node | null | undefined, opts?: Opts<ClassImplements> | null): node is ClassImplements;
                    function isClassMethod(node: Node | null | undefined, opts?: Opts<ClassMethod> | null): node is ClassMethod;
                    function isClassPrivateMethod(node: Node | null | undefined, opts?: Opts<ClassPrivateMethod> | null): node is ClassPrivateMethod;
                    function isClassPrivateProperty(node: Node | null | undefined, opts?: Opts<ClassPrivateProperty> | null): node is ClassPrivateProperty;
                    function isClassProperty(node: Node | null | undefined, opts?: Opts<ClassProperty> | null): node is ClassProperty;
                    function isCompletionStatement(node: Node | null | undefined, opts?: Opts<CompletionStatement> | null): node is CompletionStatement;
                    function isConditional(node: Node | null | undefined, opts?: Opts<Conditional> | null): node is Conditional;
                    function isConditionalExpression(node: Node | null | undefined, opts?: Opts<ConditionalExpression> | null): node is ConditionalExpression;
                    function isContinueStatement(node: Node | null | undefined, opts?: Opts<ContinueStatement> | null): node is ContinueStatement;
                    function isDebuggerStatement(node: Node | null | undefined, opts?: Opts<DebuggerStatement> | null): node is DebuggerStatement;
                    function isDecimalLiteral(node: Node | null | undefined, opts?: Opts<DecimalLiteral> | null): node is DecimalLiteral;
                    function isDeclaration(node: Node | null | undefined, opts?: Opts<Declaration> | null): node is Declaration;
                    function isDeclareClass(node: Node | null | undefined, opts?: Opts<DeclareClass> | null): node is DeclareClass;
                    function isDeclareExportAllDeclaration(node: Node | null | undefined, opts?: Opts<DeclareExportAllDeclaration> | null): node is DeclareExportAllDeclaration;
                    function isDeclareExportDeclaration(node: Node | null | undefined, opts?: Opts<DeclareExportDeclaration> | null): node is DeclareExportDeclaration;
                    function isDeclareFunction(node: Node | null | undefined, opts?: Opts<DeclareFunction> | null): node is DeclareFunction;
                    function isDeclareInterface(node: Node | null | undefined, opts?: Opts<DeclareInterface> | null): node is DeclareInterface;
                    function isDeclareModule(node: Node | null | undefined, opts?: Opts<DeclareModule> | null): node is DeclareModule;
                    function isDeclareModuleExports(node: Node | null | undefined, opts?: Opts<DeclareModuleExports> | null): node is DeclareModuleExports;
                    function isDeclareOpaqueType(node: Node | null | undefined, opts?: Opts<DeclareOpaqueType> | null): node is DeclareOpaqueType;
                    function isDeclareTypeAlias(node: Node | null | undefined, opts?: Opts<DeclareTypeAlias> | null): node is DeclareTypeAlias;
                    function isDeclareVariable(node: Node | null | undefined, opts?: Opts<DeclareVariable> | null): node is DeclareVariable;
                    function isDeclaredPredicate(node: Node | null | undefined, opts?: Opts<DeclaredPredicate> | null): node is DeclaredPredicate;
                    function isDecorator(node: Node | null | undefined, opts?: Opts<Decorator> | null): node is Decorator;
                    function isDirective(node: Node | null | undefined, opts?: Opts<Directive> | null): node is Directive;
                    function isDirectiveLiteral(node: Node | null | undefined, opts?: Opts<DirectiveLiteral> | null): node is DirectiveLiteral;
                    function isDoExpression(node: Node | null | undefined, opts?: Opts<DoExpression> | null): node is DoExpression;
                    function isDoWhileStatement(node: Node | null | undefined, opts?: Opts<DoWhileStatement> | null): node is DoWhileStatement;
                    function isEmptyStatement(node: Node | null | undefined, opts?: Opts<EmptyStatement> | null): node is EmptyStatement;
                    function isEmptyTypeAnnotation(node: Node | null | undefined, opts?: Opts<EmptyTypeAnnotation> | null): node is EmptyTypeAnnotation;
                    function isEnumBody(node: Node | null | undefined, opts?: Opts<EnumBody> | null): node is EnumBody;
                    function isEnumBooleanBody(node: Node | null | undefined, opts?: Opts<EnumBooleanBody> | null): node is EnumBooleanBody;
                    function isEnumBooleanMember(node: Node | null | undefined, opts?: Opts<EnumBooleanMember> | null): node is EnumBooleanMember;
                    function isEnumDeclaration(node: Node | null | undefined, opts?: Opts<EnumDeclaration> | null): node is EnumDeclaration;
                    function isEnumDefaultedMember(node: Node | null | undefined, opts?: Opts<EnumDefaultedMember> | null): node is EnumDefaultedMember;
                    function isEnumMember(node: Node | null | undefined, opts?: Opts<EnumMember> | null): node is EnumMember;
                    function isEnumNumberBody(node: Node | null | undefined, opts?: Opts<EnumNumberBody> | null): node is EnumNumberBody;
                    function isEnumNumberMember(node: Node | null | undefined, opts?: Opts<EnumNumberMember> | null): node is EnumNumberMember;
                    function isEnumStringBody(node: Node | null | undefined, opts?: Opts<EnumStringBody> | null): node is EnumStringBody;
                    function isEnumStringMember(node: Node | null | undefined, opts?: Opts<EnumStringMember> | null): node is EnumStringMember;
                    function isEnumSymbolBody(node: Node | null | undefined, opts?: Opts<EnumSymbolBody> | null): node is EnumSymbolBody;
                    function isExistsTypeAnnotation(node: Node | null | undefined, opts?: Opts<ExistsTypeAnnotation> | null): node is ExistsTypeAnnotation;
                    function isExportAllDeclaration(node: Node | null | undefined, opts?: Opts<ExportAllDeclaration> | null): node is ExportAllDeclaration;
                    function isExportDeclaration(node: Node | null | undefined, opts?: Opts<ExportDeclaration> | null): node is ExportDeclaration;
                    function isExportDefaultDeclaration(node: Node | null | undefined, opts?: Opts<ExportDefaultDeclaration> | null): node is ExportDefaultDeclaration;
                    function isExportDefaultSpecifier(node: Node | null | undefined, opts?: Opts<ExportDefaultSpecifier> | null): node is ExportDefaultSpecifier;
                    function isExportNamedDeclaration(node: Node | null | undefined, opts?: Opts<ExportNamedDeclaration> | null): node is ExportNamedDeclaration;
                    function isExportNamespaceSpecifier(node: Node | null | undefined, opts?: Opts<ExportNamespaceSpecifier> | null): node is ExportNamespaceSpecifier;
                    function isExportSpecifier(node: Node | null | undefined, opts?: Opts<ExportSpecifier> | null): node is ExportSpecifier;
                    function isExpression(node: Node | null | undefined, opts?: Opts<Expression> | null): node is Expression;
                    function isExpressionStatement(node: Node | null | undefined, opts?: Opts<ExpressionStatement> | null): node is ExpressionStatement;
                    function isExpressionWrapper(node: Node | null | undefined, opts?: Opts<ExpressionWrapper> | null): node is ExpressionWrapper;
                    function isFile(node: Node | null | undefined, opts?: Opts<File> | null): node is File;
                    function isFlow(node: Node | null | undefined, opts?: Opts<Flow> | null): node is Flow;
                    function isFlowBaseAnnotation(node: Node | null | undefined, opts?: Opts<FlowBaseAnnotation> | null): node is FlowBaseAnnotation;
                    function isFlowDeclaration(node: Node | null | undefined, opts?: Opts<FlowDeclaration> | null): node is FlowDeclaration;
                    function isFlowPredicate(node: Node | null | undefined, opts?: Opts<FlowPredicate> | null): node is FlowPredicate;
                    function isFlowType(node: Node | null | undefined, opts?: Opts<FlowType> | null): node is FlowType;
                    function isFor(node: Node | null | undefined, opts?: Opts<For> | null): node is For;
                    function isForInStatement(node: Node | null | undefined, opts?: Opts<ForInStatement> | null): node is ForInStatement;
                    function isForOfStatement(node: Node | null | undefined, opts?: Opts<ForOfStatement> | null): node is ForOfStatement;
                    function isForStatement(node: Node | null | undefined, opts?: Opts<ForStatement> | null): node is ForStatement;
                    function isForXStatement(node: Node | null | undefined, opts?: Opts<ForXStatement> | null): node is ForXStatement;
                    function isFunction(node: Node | null | undefined, opts?: Opts<Function> | null): node is Function;
                    function isFunctionDeclaration(node: Node | null | undefined, opts?: Opts<FunctionDeclaration> | null): node is FunctionDeclaration;
                    function isFunctionExpression(node: Node | null | undefined, opts?: Opts<FunctionExpression> | null): node is FunctionExpression;
                    function isFunctionParent(node: Node | null | undefined, opts?: Opts<FunctionParent> | null): node is FunctionParent;
                    function isFunctionTypeAnnotation(node: Node | null | undefined, opts?: Opts<FunctionTypeAnnotation> | null): node is FunctionTypeAnnotation;
                    function isFunctionTypeParam(node: Node | null | undefined, opts?: Opts<FunctionTypeParam> | null): node is FunctionTypeParam;
                    function isGenericTypeAnnotation(node: Node | null | undefined, opts?: Opts<GenericTypeAnnotation> | null): node is GenericTypeAnnotation;
                    function isIdentifier(node: Node | null | undefined, opts?: Opts<Identifier> | null): node is Identifier;
                    function isIfStatement(node: Node | null | undefined, opts?: Opts<IfStatement> | null): node is IfStatement;
                    /**
                     * Check if the input `node` is definitely immutable.
                     */
                    function isImmutable(node: Node): boolean;
                    function isImport(node: Node | null | undefined, opts?: Opts<Import> | null): node is Import;
                    function isImportAttribute(node: Node | null | undefined, opts?: Opts<ImportAttribute> | null): node is ImportAttribute;
                    function isImportDeclaration(node: Node | null | undefined, opts?: Opts<ImportDeclaration> | null): node is ImportDeclaration;
                    function isImportDefaultSpecifier(node: Node | null | undefined, opts?: Opts<ImportDefaultSpecifier> | null): node is ImportDefaultSpecifier;
                    function isImportNamespaceSpecifier(node: Node | null | undefined, opts?: Opts<ImportNamespaceSpecifier> | null): node is ImportNamespaceSpecifier;
                    function isImportOrExportDeclaration(node: Node | null | undefined, opts?: Opts<ImportOrExportDeclaration> | null): node is ImportOrExportDeclaration;
                    function isImportSpecifier(node: Node | null | undefined, opts?: Opts<ImportSpecifier> | null): node is ImportSpecifier;
                    function isIndexedAccessType(node: Node | null | undefined, opts?: Opts<IndexedAccessType> | null): node is IndexedAccessType;
                    function isInferredPredicate(node: Node | null | undefined, opts?: Opts<InferredPredicate> | null): node is InferredPredicate;
                    function isInterfaceDeclaration(node: Node | null | undefined, opts?: Opts<InterfaceDeclaration> | null): node is InterfaceDeclaration;
                    function isInterfaceExtends(node: Node | null | undefined, opts?: Opts<InterfaceExtends> | null): node is InterfaceExtends;
                    function isInterfaceTypeAnnotation(node: Node | null | undefined, opts?: Opts<InterfaceTypeAnnotation> | null): node is InterfaceTypeAnnotation;
                    function isInterpreterDirective(node: Node | null | undefined, opts?: Opts<InterpreterDirective> | null): node is InterpreterDirective;
                    function isIntersectionTypeAnnotation(node: Node | null | undefined, opts?: Opts<IntersectionTypeAnnotation> | null): node is IntersectionTypeAnnotation;
                    function isJSX(node: Node | null | undefined, opts?: Opts<JSX> | null): node is JSX;
                    function isJSXAttribute(node: Node | null | undefined, opts?: Opts<JSXAttribute> | null): node is JSXAttribute;
                    function isJSXClosingElement(node: Node | null | undefined, opts?: Opts<JSXClosingElement> | null): node is JSXClosingElement;
                    function isJSXClosingFragment(node: Node | null | undefined, opts?: Opts<JSXClosingFragment> | null): node is JSXClosingFragment;
                    function isJSXElement(node: Node | null | undefined, opts?: Opts<JSXElement> | null): node is JSXElement;
                    function isJSXEmptyExpression(node: Node | null | undefined, opts?: Opts<JSXEmptyExpression> | null): node is JSXEmptyExpression;
                    function isJSXExpressionContainer(node: Node | null | undefined, opts?: Opts<JSXExpressionContainer> | null): node is JSXExpressionContainer;
                    function isJSXFragment(node: Node | null | undefined, opts?: Opts<JSXFragment> | null): node is JSXFragment;
                    function isJSXIdentifier(node: Node | null | undefined, opts?: Opts<JSXIdentifier> | null): node is JSXIdentifier;
                    function isJSXMemberExpression(node: Node | null | undefined, opts?: Opts<JSXMemberExpression> | null): node is JSXMemberExpression;
                    function isJSXNamespacedName(node: Node | null | undefined, opts?: Opts<JSXNamespacedName> | null): node is JSXNamespacedName;
                    function isJSXOpeningElement(node: Node | null | undefined, opts?: Opts<JSXOpeningElement> | null): node is JSXOpeningElement;
                    function isJSXOpeningFragment(node: Node | null | undefined, opts?: Opts<JSXOpeningFragment> | null): node is JSXOpeningFragment;
                    function isJSXSpreadAttribute(node: Node | null | undefined, opts?: Opts<JSXSpreadAttribute> | null): node is JSXSpreadAttribute;
                    function isJSXSpreadChild(node: Node | null | undefined, opts?: Opts<JSXSpreadChild> | null): node is JSXSpreadChild;
                    function isJSXText(node: Node | null | undefined, opts?: Opts<JSXText> | null): node is JSXText;
                    function isLVal(node: Node | null | undefined, opts?: Opts<LVal> | null): node is LVal;
                    function isLabeledStatement(node: Node | null | undefined, opts?: Opts<LabeledStatement> | null): node is LabeledStatement;
                    /**
                     * Check if the input `node` is a `let` variable declaration.
                     */
                    function isLet(node: Node): boolean;
                    function isLiteral(node: Node | null | undefined, opts?: Opts<Literal> | null): node is Literal;
                    function isLogicalExpression(node: Node | null | undefined, opts?: Opts<LogicalExpression> | null): node is LogicalExpression;
                    function isLoop(node: Node | null | undefined, opts?: Opts<Loop> | null): node is Loop;
                    function isMemberExpression(node: Node | null | undefined, opts?: Opts<MemberExpression> | null): node is MemberExpression;
                    function isMetaProperty(node: Node | null | undefined, opts?: Opts<MetaProperty> | null): node is MetaProperty;
                    function isMethod(node: Node | null | undefined, opts?: Opts<Method> | null): node is Method;
                    function isMiscellaneous(node: Node | null | undefined, opts?: Opts<Miscellaneous> | null): node is Miscellaneous;
                    function isMixedTypeAnnotation(node: Node | null | undefined, opts?: Opts<MixedTypeAnnotation> | null): node is MixedTypeAnnotation;
                    /**
                     * @deprecated Use `isImportOrExportDeclaration`
                     */
                    function isModuleDeclaration(node: Node | null | undefined, opts?: Opts<ModuleDeclaration> | null): node is ImportOrExportDeclaration;
                    function isModuleExpression(node: Node | null | undefined, opts?: Opts<ModuleExpression> | null): node is ModuleExpression;
                    function isModuleSpecifier(node: Node | null | undefined, opts?: Opts<ModuleSpecifier> | null): node is ModuleSpecifier;
                    function isNewExpression(node: Node | null | undefined, opts?: Opts<NewExpression> | null): node is NewExpression;
                    function isNode(node: any): node is Node;
                    /**
                     * Check if two nodes are equivalent
                     */
                    function isNodesEquivalent<T extends Partial<Node>>(a: T, b: any): b is T;
                    function isNoop(node: Node | null | undefined, opts?: Opts<Noop> | null): node is Noop;
                    function isNullLiteral(node: Node | null | undefined, opts?: Opts<NullLiteral> | null): node is NullLiteral;
                    function isNullLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<NullLiteralTypeAnnotation> | null): node is NullLiteralTypeAnnotation;
                    function isNullableTypeAnnotation(node: Node | null | undefined, opts?: Opts<NullableTypeAnnotation> | null): node is NullableTypeAnnotation;
                    /**
                     * @deprecated Use `isNumericLiteral`
                     */
                    function isNumberLiteral(node: Node | null | undefined, opts?: Opts<NumberLiteral> | null): boolean;
                    function isNumberLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<NumberLiteralTypeAnnotation> | null): node is NumberLiteralTypeAnnotation;
                    function isNumberTypeAnnotation(node: Node | null | undefined, opts?: Opts<NumberTypeAnnotation> | null): node is NumberTypeAnnotation;
                    function isNumericLiteral(node: Node | null | undefined, opts?: Opts<NumericLiteral> | null): node is NumericLiteral;
                    function isObjectExpression(node: Node | null | undefined, opts?: Opts<ObjectExpression> | null): node is ObjectExpression;
                    function isObjectMember(node: Node | null | undefined, opts?: Opts<ObjectMember> | null): node is ObjectMember;
                    function isObjectMethod(node: Node | null | undefined, opts?: Opts<ObjectMethod> | null): node is ObjectMethod;
                    function isObjectPattern(node: Node | null | undefined, opts?: Opts<ObjectPattern> | null): node is ObjectPattern;
                    function isObjectProperty(node: Node | null | undefined, opts?: Opts<ObjectProperty> | null): node is ObjectProperty;
                    function isObjectTypeAnnotation(node: Node | null | undefined, opts?: Opts<ObjectTypeAnnotation> | null): node is ObjectTypeAnnotation;
                    function isObjectTypeCallProperty(node: Node | null | undefined, opts?: Opts<ObjectTypeCallProperty> | null): node is ObjectTypeCallProperty;
                    function isObjectTypeIndexer(node: Node | null | undefined, opts?: Opts<ObjectTypeIndexer> | null): node is ObjectTypeIndexer;
                    function isObjectTypeInternalSlot(node: Node | null | undefined, opts?: Opts<ObjectTypeInternalSlot> | null): node is ObjectTypeInternalSlot;
                    function isObjectTypeProperty(node: Node | null | undefined, opts?: Opts<ObjectTypeProperty> | null): node is ObjectTypeProperty;
                    function isObjectTypeSpreadProperty(node: Node | null | undefined, opts?: Opts<ObjectTypeSpreadProperty> | null): node is ObjectTypeSpreadProperty;
                    function isOpaqueType(node: Node | null | undefined, opts?: Opts<OpaqueType> | null): node is OpaqueType;
                    function isOptionalCallExpression(node: Node | null | undefined, opts?: Opts<OptionalCallExpression> | null): node is OptionalCallExpression;
                    function isOptionalIndexedAccessType(node: Node | null | undefined, opts?: Opts<OptionalIndexedAccessType> | null): node is OptionalIndexedAccessType;
                    function isOptionalMemberExpression(node: Node | null | undefined, opts?: Opts<OptionalMemberExpression> | null): node is OptionalMemberExpression;
                    function isParenthesizedExpression(node: Node | null | undefined, opts?: Opts<ParenthesizedExpression> | null): node is ParenthesizedExpression;
                    function isPattern(node: Node | null | undefined, opts?: Opts<Pattern> | null): node is Pattern;
                    function isPatternLike(node: Node | null | undefined, opts?: Opts<PatternLike> | null): node is PatternLike;
                    function isPipelineBareFunction(node: Node | null | undefined, opts?: Opts<PipelineBareFunction> | null): node is PipelineBareFunction;
                    function isPipelinePrimaryTopicReference(node: Node | null | undefined, opts?: Opts<PipelinePrimaryTopicReference> | null): node is PipelinePrimaryTopicReference;
                    function isPipelineTopicExpression(node: Node | null | undefined, opts?: Opts<PipelineTopicExpression> | null): node is PipelineTopicExpression;
                    function isPlaceholder(node: Node | null | undefined, opts?: Opts<Placeholder> | null): node is Placeholder;
                    /**
                     * Test if a `placeholderType` is a `targetType` or if `targetType` is an alias of `placeholderType`.
                     */
                    function isPlaceholderType(placeholderType: string, targetType: string): boolean;
                    function isPrivate(node: Node | null | undefined, opts?: Opts<Private> | null): node is Private;
                    function isPrivateName(node: Node | null | undefined, opts?: Opts<PrivateName> | null): node is PrivateName;
                    function isProgram(node: Node | null | undefined, opts?: Opts<Program> | null): node is Program;
                    function isProperty(node: Node | null | undefined, opts?: Opts<Property> | null): node is Property;
                    function isPureish(node: Node | null | undefined, opts?: Opts<Pureish> | null): node is Pureish;
                    function isQualifiedTypeIdentifier(node: Node | null | undefined, opts?: Opts<QualifiedTypeIdentifier> | null): node is QualifiedTypeIdentifier;
                    function isRecordExpression(node: Node | null | undefined, opts?: Opts<RecordExpression> | null): node is RecordExpression;
                    /**
                     * Check if the input `node` is a reference to a bound variable.
                     */
                    function isReferenced(node: Node, parent: Node, grandparent?: Node): boolean;
                    function isRegExpLiteral(node: Node | null | undefined, opts?: Opts<RegExpLiteral> | null): node is RegExpLiteral;
                    /**
                     * @deprecated Use `isRegExpLiteral`
                     */
                    function isRegexLiteral(node: Node | null | undefined, opts?: Opts<RegexLiteral> | null): boolean;
                    function isRestElement(node: Node | null | undefined, opts?: Opts<RestElement> | null): node is RestElement;
                    /**
                     * @deprecated Use `isRestElement`
                     */
                    function isRestProperty(node: Node | null | undefined, opts?: Opts<RestProperty> | null): boolean;
                    function isReturnStatement(node: Node | null | undefined, opts?: Opts<ReturnStatement> | null): node is ReturnStatement;
                    function isScopable(node: Node | null | undefined, opts?: Opts<Scopable> | null): node is Scopable;
                    /**
                     * Check if the input `node` is a scope.
                     */
                    function isScope(node: Node, parent: Node): boolean;
                    function isSequenceExpression(node: Node | null | undefined, opts?: Opts<SequenceExpression> | null): node is SequenceExpression;
                    /**
                     * Check if the input `specifier` is a `default` import or export.
                     */
                    function isSpecifierDefault(specifier: ModuleSpecifier): boolean;
                    function isSpreadElement(node: Node | null | undefined, opts?: Opts<SpreadElement> | null): node is SpreadElement;
                    /**
                     * @deprecated Use `isSpreadElement`
                     */
                    function isSpreadProperty(node: Node | null | undefined, opts?: Opts<SpreadProperty> | null): boolean;
                    function isStandardized(node: Node | null | undefined, opts?: Opts<Standardized> | null): node is Standardized;
                    function isStatement(node: Node | null | undefined, opts?: Opts<Statement> | null): node is Statement;
                    function isStaticBlock(node: Node | null | undefined, opts?: Opts<StaticBlock> | null): node is StaticBlock;
                    function isStringLiteral(node: Node | null | undefined, opts?: Opts<StringLiteral> | null): node is StringLiteral;
                    function isStringLiteralTypeAnnotation(node: Node | null | undefined, opts?: Opts<StringLiteralTypeAnnotation> | null): node is StringLiteralTypeAnnotation;
                    function isStringTypeAnnotation(node: Node | null | undefined, opts?: Opts<StringTypeAnnotation> | null): node is StringTypeAnnotation;
                    function isSuper(node: Node | null | undefined, opts?: Opts<Super> | null): node is Super;
                    function isSwitchCase(node: Node | null | undefined, opts?: Opts<SwitchCase> | null): node is SwitchCase;
                    function isSwitchStatement(node: Node | null | undefined, opts?: Opts<SwitchStatement> | null): node is SwitchStatement;
                    function isSymbolTypeAnnotation(node: Node | null | undefined, opts?: Opts<SymbolTypeAnnotation> | null): node is SymbolTypeAnnotation;
                    function isTSAnyKeyword(node: Node | null | undefined, opts?: Opts<TSAnyKeyword> | null): node is TSAnyKeyword;
                    function isTSArrayType(node: Node | null | undefined, opts?: Opts<TSArrayType> | null): node is TSArrayType;
                    function isTSAsExpression(node: Node | null | undefined, opts?: Opts<TSAsExpression> | null): node is TSAsExpression;
                    function isTSBaseType(node: Node | null | undefined, opts?: Opts<TSBaseType> | null): node is TSBaseType;
                    function isTSBigIntKeyword(node: Node | null | undefined, opts?: Opts<TSBigIntKeyword> | null): node is TSBigIntKeyword;
                    function isTSBooleanKeyword(node: Node | null | undefined, opts?: Opts<TSBooleanKeyword> | null): node is TSBooleanKeyword;
                    function isTSCallSignatureDeclaration(node: Node | null | undefined, opts?: Opts<TSCallSignatureDeclaration> | null): node is TSCallSignatureDeclaration;
                    function isTSConditionalType(node: Node | null | undefined, opts?: Opts<TSConditionalType> | null): node is TSConditionalType;
                    function isTSConstructSignatureDeclaration(node: Node | null | undefined, opts?: Opts<TSConstructSignatureDeclaration> | null): node is TSConstructSignatureDeclaration;
                    function isTSConstructorType(node: Node | null | undefined, opts?: Opts<TSConstructorType> | null): node is TSConstructorType;
                    function isTSDeclareFunction(node: Node | null | undefined, opts?: Opts<TSDeclareFunction> | null): node is TSDeclareFunction;
                    function isTSDeclareMethod(node: Node | null | undefined, opts?: Opts<TSDeclareMethod> | null): node is TSDeclareMethod;
                    function isTSEntityName(node: Node | null | undefined, opts?: Opts<TSEntityName> | null): node is TSEntityName;
                    function isTSEnumDeclaration(node: Node | null | undefined, opts?: Opts<TSEnumDeclaration> | null): node is TSEnumDeclaration;
                    function isTSEnumMember(node: Node | null | undefined, opts?: Opts<TSEnumMember> | null): node is TSEnumMember;
                    function isTSExportAssignment(node: Node | null | undefined, opts?: Opts<TSExportAssignment> | null): node is TSExportAssignment;
                    function isTSExpressionWithTypeArguments(node: Node | null | undefined, opts?: Opts<TSExpressionWithTypeArguments> | null): node is TSExpressionWithTypeArguments;
                    function isTSExternalModuleReference(node: Node | null | undefined, opts?: Opts<TSExternalModuleReference> | null): node is TSExternalModuleReference;
                    function isTSFunctionType(node: Node | null | undefined, opts?: Opts<TSFunctionType> | null): node is TSFunctionType;
                    function isTSImportEqualsDeclaration(node: Node | null | undefined, opts?: Opts<TSImportEqualsDeclaration> | null): node is TSImportEqualsDeclaration;
                    function isTSImportType(node: Node | null | undefined, opts?: Opts<TSImportType> | null): node is TSImportType;
                    function isTSIndexSignature(node: Node | null | undefined, opts?: Opts<TSIndexSignature> | null): node is TSIndexSignature;
                    function isTSIndexedAccessType(node: Node | null | undefined, opts?: Opts<TSIndexedAccessType> | null): node is TSIndexedAccessType;
                    function isTSInferType(node: Node | null | undefined, opts?: Opts<TSInferType> | null): node is TSInferType;
                    function isTSInstantiationExpression(node: Node | null | undefined, opts?: Opts<TSInstantiationExpression> | null): node is TSInstantiationExpression;
                    function isTSInterfaceBody(node: Node | null | undefined, opts?: Opts<TSInterfaceBody> | null): node is TSInterfaceBody;
                    function isTSInterfaceDeclaration(node: Node | null | undefined, opts?: Opts<TSInterfaceDeclaration> | null): node is TSInterfaceDeclaration;
                    function isTSIntersectionType(node: Node | null | undefined, opts?: Opts<TSIntersectionType> | null): node is TSIntersectionType;
                    function isTSIntrinsicKeyword(node: Node | null | undefined, opts?: Opts<TSIntrinsicKeyword> | null): node is TSIntrinsicKeyword;
                    function isTSLiteralType(node: Node | null | undefined, opts?: Opts<TSLiteralType> | null): node is TSLiteralType;
                    function isTSMappedType(node: Node | null | undefined, opts?: Opts<TSMappedType> | null): node is TSMappedType;
                    function isTSMethodSignature(node: Node | null | undefined, opts?: Opts<TSMethodSignature> | null): node is TSMethodSignature;
                    function isTSModuleBlock(node: Node | null | undefined, opts?: Opts<TSModuleBlock> | null): node is TSModuleBlock;
                    function isTSModuleDeclaration(node: Node | null | undefined, opts?: Opts<TSModuleDeclaration> | null): node is TSModuleDeclaration;
                    function isTSNamedTupleMember(node: Node | null | undefined, opts?: Opts<TSNamedTupleMember> | null): node is TSNamedTupleMember;
                    function isTSNamespaceExportDeclaration(node: Node | null | undefined, opts?: Opts<TSNamespaceExportDeclaration> | null): node is TSNamespaceExportDeclaration;
                    function isTSNeverKeyword(node: Node | null | undefined, opts?: Opts<TSNeverKeyword> | null): node is TSNeverKeyword;
                    function isTSNonNullExpression(node: Node | null | undefined, opts?: Opts<TSNonNullExpression> | null): node is TSNonNullExpression;
                    function isTSNullKeyword(node: Node | null | undefined, opts?: Opts<TSNullKeyword> | null): node is TSNullKeyword;
                    function isTSNumberKeyword(node: Node | null | undefined, opts?: Opts<TSNumberKeyword> | null): node is TSNumberKeyword;
                    function isTSObjectKeyword(node: Node | null | undefined, opts?: Opts<TSObjectKeyword> | null): node is TSObjectKeyword;
                    function isTSOptionalType(node: Node | null | undefined, opts?: Opts<TSOptionalType> | null): node is TSOptionalType;
                    function isTSParameterProperty(node: Node | null | undefined, opts?: Opts<TSParameterProperty> | null): node is TSParameterProperty;
                    function isTSParenthesizedType(node: Node | null | undefined, opts?: Opts<TSParenthesizedType> | null): node is TSParenthesizedType;
                    function isTSPropertySignature(node: Node | null | undefined, opts?: Opts<TSPropertySignature> | null): node is TSPropertySignature;
                    function isTSQualifiedName(node: Node | null | undefined, opts?: Opts<TSQualifiedName> | null): node is TSQualifiedName;
                    function isTSRestType(node: Node | null | undefined, opts?: Opts<TSRestType> | null): node is TSRestType;
                    function isTSSatisfiesExpression(node: Node | null | undefined, opts?: Opts<TSSatisfiesExpression> | null): node is TSSatisfiesExpression;
                    function isTSStringKeyword(node: Node | null | undefined, opts?: Opts<TSStringKeyword> | null): node is TSStringKeyword;
                    function isTSSymbolKeyword(node: Node | null | undefined, opts?: Opts<TSSymbolKeyword> | null): node is TSSymbolKeyword;
                    function isTSThisType(node: Node | null | undefined, opts?: Opts<TSThisType> | null): node is TSThisType;
                    function isTSTupleType(node: Node | null | undefined, opts?: Opts<TSTupleType> | null): node is TSTupleType;
                    function isTSType(node: Node | null | undefined, opts?: Opts<TSType> | null): node is TSType;
                    function isTSTypeAliasDeclaration(node: Node | null | undefined, opts?: Opts<TSTypeAliasDeclaration> | null): node is TSTypeAliasDeclaration;
                    function isTSTypeAnnotation(node: Node | null | undefined, opts?: Opts<TSTypeAnnotation> | null): node is TSTypeAnnotation;
                    function isTSTypeAssertion(node: Node | null | undefined, opts?: Opts<TSTypeAssertion> | null): node is TSTypeAssertion;
                    function isTSTypeElement(node: Node | null | undefined, opts?: Opts<TSTypeElement> | null): node is TSTypeElement;
                    function isTSTypeLiteral(node: Node | null | undefined, opts?: Opts<TSTypeLiteral> | null): node is TSTypeLiteral;
                    function isTSTypeOperator(node: Node | null | undefined, opts?: Opts<TSTypeOperator> | null): node is TSTypeOperator;
                    function isTSTypeParameter(node: Node | null | undefined, opts?: Opts<TSTypeParameter> | null): node is TSTypeParameter;
                    function isTSTypeParameterDeclaration(node: Node | null | undefined, opts?: Opts<TSTypeParameterDeclaration> | null): node is TSTypeParameterDeclaration;
                    function isTSTypeParameterInstantiation(node: Node | null | undefined, opts?: Opts<TSTypeParameterInstantiation> | null): node is TSTypeParameterInstantiation;
                    function isTSTypePredicate(node: Node | null | undefined, opts?: Opts<TSTypePredicate> | null): node is TSTypePredicate;
                    function isTSTypeQuery(node: Node | null | undefined, opts?: Opts<TSTypeQuery> | null): node is TSTypeQuery;
                    function isTSTypeReference(node: Node | null | undefined, opts?: Opts<TSTypeReference> | null): node is TSTypeReference;
                    function isTSUndefinedKeyword(node: Node | null | undefined, opts?: Opts<TSUndefinedKeyword> | null): node is TSUndefinedKeyword;
                    function isTSUnionType(node: Node | null | undefined, opts?: Opts<TSUnionType> | null): node is TSUnionType;
                    function isTSUnknownKeyword(node: Node | null | undefined, opts?: Opts<TSUnknownKeyword> | null): node is TSUnknownKeyword;
                    function isTSVoidKeyword(node: Node | null | undefined, opts?: Opts<TSVoidKeyword> | null): node is TSVoidKeyword;
                    function isTaggedTemplateExpression(node: Node | null | undefined, opts?: Opts<TaggedTemplateExpression> | null): node is TaggedTemplateExpression;
                    function isTemplateElement(node: Node | null | undefined, opts?: Opts<TemplateElement> | null): node is TemplateElement;
                    function isTemplateLiteral(node: Node | null | undefined, opts?: Opts<TemplateLiteral> | null): node is TemplateLiteral;
                    function isTerminatorless(node: Node | null | undefined, opts?: Opts<Terminatorless> | null): node is Terminatorless;
                    function isThisExpression(node: Node | null | undefined, opts?: Opts<ThisExpression> | null): node is ThisExpression;
                    function isThisTypeAnnotation(node: Node | null | undefined, opts?: Opts<ThisTypeAnnotation> | null): node is ThisTypeAnnotation;
                    function isThrowStatement(node: Node | null | undefined, opts?: Opts<ThrowStatement> | null): node is ThrowStatement;
                    function isTopicReference(node: Node | null | undefined, opts?: Opts<TopicReference> | null): node is TopicReference;
                    function isTryStatement(node: Node | null | undefined, opts?: Opts<TryStatement> | null): node is TryStatement;
                    function isTupleExpression(node: Node | null | undefined, opts?: Opts<TupleExpression> | null): node is TupleExpression;
                    function isTupleTypeAnnotation(node: Node | null | undefined, opts?: Opts<TupleTypeAnnotation> | null): node is TupleTypeAnnotation;
                    function isType<T extends Node["type"]>(nodeType: string, targetType: T): nodeType is T;
                    function isType(nodeType: string | null | undefined, targetType: string): boolean;
                    function isTypeAlias(node: Node | null | undefined, opts?: Opts<TypeAlias> | null): node is TypeAlias;
                    function isTypeAnnotation(node: Node | null | undefined, opts?: Opts<TypeAnnotation> | null): node is TypeAnnotation;
                    function isTypeCastExpression(node: Node | null | undefined, opts?: Opts<TypeCastExpression> | null): node is TypeCastExpression;
                    function isTypeParameter(node: Node | null | undefined, opts?: Opts<TypeParameter> | null): node is TypeParameter;
                    function isTypeParameterDeclaration(node: Node | null | undefined, opts?: Opts<TypeParameterDeclaration> | null): node is TypeParameterDeclaration;
                    function isTypeParameterInstantiation(node: Node | null | undefined, opts?: Opts<TypeParameterInstantiation> | null): node is TypeParameterInstantiation;
                    function isTypeScript(node: Node | null | undefined, opts?: Opts<TypeScript> | null): node is TypeScript;
                    function isTypeofTypeAnnotation(node: Node | null | undefined, opts?: Opts<TypeofTypeAnnotation> | null): node is TypeofTypeAnnotation;
                    function isUnaryExpression(node: Node | null | undefined, opts?: Opts<UnaryExpression> | null): node is UnaryExpression;
                    function isUnaryLike(node: Node | null | undefined, opts?: Opts<UnaryLike> | null): node is UnaryLike;
                    function isUnionTypeAnnotation(node: Node | null | undefined, opts?: Opts<UnionTypeAnnotation> | null): node is UnionTypeAnnotation;
                    function isUpdateExpression(node: Node | null | undefined, opts?: Opts<UpdateExpression> | null): node is UpdateExpression;
                    function isUserWhitespacable(node: Node | null | undefined, opts?: Opts<UserWhitespacable> | null): node is UserWhitespacable;
                    function isV8IntrinsicIdentifier(node: Node | null | undefined, opts?: Opts<V8IntrinsicIdentifier> | null): node is V8IntrinsicIdentifier;
                    /**
                     * Check if the input `name` is a valid identifier name according to the ES3 specification.
                     *
                     * Additional ES3 reserved words are
                     */
                    function isValidES3Identifier(name: string): boolean;
                    /**
                     * Check if the input `name` is a valid identifier name
                     * and isn't a reserved word.
                     */
                    function isValidIdentifier(name: string, reserved?: boolean): boolean;
                    /**
                     * Check if the input `node` is a variable declaration.
                     */
                    function isVar(node: Node): boolean;
                    function isVariableDeclaration(node: Node | null | undefined, opts?: Opts<VariableDeclaration> | null): node is VariableDeclaration;
                    function isVariableDeclarator(node: Node | null | undefined, opts?: Opts<VariableDeclarator> | null): node is VariableDeclarator;
                    function isVariance(node: Node | null | undefined, opts?: Opts<Variance> | null): node is Variance;
                    function isVoidTypeAnnotation(node: Node | null | undefined, opts?: Opts<VoidTypeAnnotation> | null): node is VoidTypeAnnotation;
                    function isWhile(node: Node | null | undefined, opts?: Opts<While> | null): node is While;
                    function isWhileStatement(node: Node | null | undefined, opts?: Opts<WhileStatement> | null): node is WhileStatement;
                    function isWithStatement(node: Node | null | undefined, opts?: Opts<WithStatement> | null): node is WithStatement;
                    function isYieldExpression(node: Node | null | undefined, opts?: Opts<YieldExpression> | null): node is YieldExpression;
                    function jSXAttribute(name: JSXIdentifier | JSXNamespacedName, value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null): JSXAttribute;
                    function jSXClosingElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName): JSXClosingElement;
                    function jSXClosingFragment(): JSXClosingFragment;
                    function jSXElement(openingElement: JSXOpeningElement, closingElement: JSXClosingElement | null | undefined, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>, selfClosing?: boolean | null): JSXElement;
                    function jSXEmptyExpression(): JSXEmptyExpression;
                    function jSXExpressionContainer(expression: Expression | JSXEmptyExpression): JSXExpressionContainer;
                    function jSXFragment(openingFragment: JSXOpeningFragment, closingFragment: JSXClosingFragment, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>): JSXFragment;
                    function jSXIdentifier(name: string): JSXIdentifier;
                    function jSXMemberExpression(object: JSXMemberExpression | JSXIdentifier, property: JSXIdentifier): JSXMemberExpression;
                    function jSXNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName;
                    function jSXOpeningElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName, attributes: Array<JSXAttribute | JSXSpreadAttribute>, selfClosing?: boolean): JSXOpeningElement;
                    function jSXOpeningFragment(): JSXOpeningFragment;
                    function jSXSpreadAttribute(argument: Expression): JSXSpreadAttribute;
                    function jSXSpreadChild(expression: Expression): JSXSpreadChild;
                    function jSXText(value: string): JSXText;
                    function labeledStatement(label: Identifier, body: Statement): LabeledStatement;
                    function logicalExpression(operator: "||" | "&&" | "??", left: Expression, right: Expression): LogicalExpression;
                    /**
                     * Determines whether or not the input node `member` matches the
                     * input `match`.
                     *
                     * For example, given the match `React.createClass` it would match the
                     * parsed nodes of `React.createClass` and `React["createClass"]`.
                     */
                    function matchesPattern(member: Node | null | undefined, match: string | string[], allowPartial?: boolean): boolean;
                    function memberExpression(object: Expression | Super, property: Expression | Identifier | PrivateName, computed?: boolean, optional?: true | false | null): MemberExpression;
                    function metaProperty(meta: Identifier, property: Identifier): MetaProperty;
                    function mixedTypeAnnotation(): MixedTypeAnnotation;
                    function moduleExpression(body: Program): ModuleExpression;
                    function newExpression(callee: Expression | Super | V8IntrinsicIdentifier, _arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>): NewExpression;
                    function noop(): Noop;
                    function nullLiteral(): NullLiteral;
                    function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;
                    function nullableTypeAnnotation(typeAnnotation: FlowType): NullableTypeAnnotation;
                    /** @deprecated */
                    function numberLiteral(value: number): NumericLiteral;
                    function numberLiteralTypeAnnotation(value: number): NumberLiteralTypeAnnotation;
                    function numberTypeAnnotation(): NumberTypeAnnotation;
                    function numericLiteral(value: number): NumericLiteral;
                    function objectExpression(properties: Array<ObjectMethod | ObjectProperty | SpreadElement>): ObjectExpression;
                    function objectMethod(kind: "method" | "get" | "set" | undefined, key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral, params: Array<Identifier | Pattern | RestElement>, body: BlockStatement, computed?: boolean, generator?: boolean, async?: boolean): ObjectMethod;
                    function objectPattern(properties: Array<RestElement | ObjectProperty>): ObjectPattern;
                    function objectProperty(key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral | DecimalLiteral | PrivateName, value: Expression | PatternLike, computed?: boolean, shorthand?: boolean, decorators?: Array<Decorator> | null): ObjectProperty;
                    function objectTypeAnnotation(properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>, indexers?: Array<ObjectTypeIndexer>, callProperties?: Array<ObjectTypeCallProperty>, internalSlots?: Array<ObjectTypeInternalSlot>, exact?: boolean): ObjectTypeAnnotation;
                    function objectTypeCallProperty(value: FlowType): ObjectTypeCallProperty;
                    function objectTypeIndexer(id: Identifier | null | undefined, key: FlowType, value: FlowType, variance?: Variance | null): ObjectTypeIndexer;
                    function objectTypeInternalSlot(id: Identifier, value: FlowType, optional: boolean, _static: boolean, method: boolean): ObjectTypeInternalSlot;
                    function objectTypeProperty(key: Identifier | StringLiteral, value: FlowType, variance?: Variance | null): ObjectTypeProperty;
                    function objectTypeSpreadProperty(argument: FlowType): ObjectTypeSpreadProperty;
                    function opaqueType(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, supertype: FlowType | null | undefined, impltype: FlowType): OpaqueType;
                    function optionalCallExpression(callee: Expression, _arguments: Array<Expression | SpreadElement | JSXNamespacedName | ArgumentPlaceholder>, optional: boolean): OptionalCallExpression;
                    function optionalIndexedAccessType(objectType: FlowType, indexType: FlowType): OptionalIndexedAccessType;
                    function optionalMemberExpression(object: Expression, property: Expression | Identifier, computed: boolean | undefined, optional: boolean): OptionalMemberExpression;
                    function parenthesizedExpression(expression: Expression): ParenthesizedExpression;
                    function pipelineBareFunction(callee: Expression): PipelineBareFunction;
                    function pipelinePrimaryTopicReference(): PipelinePrimaryTopicReference;
                    function pipelineTopicExpression(expression: Expression): PipelineTopicExpression;
                    function placeholder(expectedNode: "Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern", name: Identifier): Placeholder;
                    /**
                     * Prepend a node to a member expression.
                     */
                    function prependToMemberExpression<T extends Pick<MemberExpression, "object" | "property">>(member: T, prepend: MemberExpression["object"]): T;
                    function privateName(id: Identifier): PrivateName;
                    function program(body: Array<Statement>, directives?: Array<Directive>, sourceType?: "script" | "module", interpreter?: InterpreterDirective | null): Program;
                    function qualifiedTypeIdentifier(id: Identifier, qualification: Identifier | QualifiedTypeIdentifier): QualifiedTypeIdentifier;
                    export const react: {
                        isReactComponent: (member: Node) => boolean;
                        isCompatTag: typeof isCompatTag;
                        buildChildren: typeof buildChildren;
                    };
                    function recordExpression(properties: Array<ObjectProperty | SpreadElement>): RecordExpression;
                    function regExpLiteral(pattern: string, flags?: string): RegExpLiteral;
                    /** @deprecated */
                    function regexLiteral(pattern: string, flags?: string): RegExpLiteral;
                    /**
                     * Remove comment properties from a node.
                     */
                    function removeComments<T extends Node>(node: T): T;
                    /**
                     * Remove all of the _* properties from a node along with the additional metadata
                     * properties like location data and raw token data.
                     */
                    function removeProperties(node: Node, opts?: RemovePropertiesOptions): void;
                    function removePropertiesDeep<T extends Node>(tree: T, opts?: {
                        preserveComments: boolean;
                    } | null): T;
                    /**
                     * Dedupe type annotations.
                     */
                    function removeTypeDuplicates(nodesIn: ReadonlyArray<FlowType | false | null | undefined>): FlowType[];
                    function restElement(argument: LVal): RestElement;
                    /** @deprecated */
                    function restProperty(argument: LVal): RestElement;
                    function returnStatement(argument?: Expression | null): ReturnStatement;
                    function sequenceExpression(expressions: Array<Expression>): SequenceExpression;
                    function shallowEqual<T extends object>(actual: object, expected: T): actual is T;
                    function spreadElement(argument: Expression): SpreadElement;
                    /** @deprecated */
                    function spreadProperty(argument: Expression): SpreadElement;
                    function staticBlock(body: Array<Statement>): StaticBlock;
                    function stringLiteral(value: string): StringLiteral;
                    function stringLiteralTypeAnnotation(value: string): StringLiteralTypeAnnotation;
                    function stringTypeAnnotation(): StringTypeAnnotation;
                    function super(): Super;
                    function switchCase(test: Expression | null | undefined, consequent: Array<Statement>): SwitchCase;
                    function switchStatement(discriminant: Expression, cases: Array<SwitchCase>): SwitchStatement;
                    function symbolTypeAnnotation(): SymbolTypeAnnotation;
                    function tSAnyKeyword(): TSAnyKeyword;
                    function tSArrayType(elementType: TSType): TSArrayType;
                    function tSAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression;
                    function tSBigIntKeyword(): TSBigIntKeyword;
                    function tSBooleanKeyword(): TSBooleanKeyword;
                    function tSCallSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSCallSignatureDeclaration;
                    function tSConditionalType(checkType: TSType, extendsType: TSType, trueType: TSType, falseType: TSType): TSConditionalType;
                    function tSConstructSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructSignatureDeclaration;
                    function tSConstructorType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructorType;
                    function tSDeclareFunction(id: Identifier | null | undefined, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<Identifier | Pattern | RestElement>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareFunction;
                    function tSDeclareMethod(decorators: Array<Decorator> | null | undefined, key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<Identifier | Pattern | RestElement | TSParameterProperty>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareMethod;
                    function tSEnumDeclaration(id: Identifier, members: Array<TSEnumMember>): TSEnumDeclaration;
                    function tSEnumMember(id: Identifier | StringLiteral, initializer?: Expression | null): TSEnumMember;
                    function tSExportAssignment(expression: Expression): TSExportAssignment;
                    function tSExpressionWithTypeArguments(expression: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSExpressionWithTypeArguments;
                    function tSExternalModuleReference(expression: StringLiteral): TSExternalModuleReference;
                    function tSFunctionType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSFunctionType;
                    function tSImportEqualsDeclaration(id: Identifier, moduleReference: TSEntityName | TSExternalModuleReference): TSImportEqualsDeclaration;
                    function tSImportType(argument: StringLiteral, qualifier?: TSEntityName | null, typeParameters?: TSTypeParameterInstantiation | null): TSImportType;
                    function tSIndexSignature(parameters: Array<Identifier>, typeAnnotation?: TSTypeAnnotation | null): TSIndexSignature;
                    function tSIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType;
                    function tSInferType(typeParameter: TSTypeParameter): TSInferType;
                    function tSInstantiationExpression(expression: Expression, typeParameters?: TSTypeParameterInstantiation | null): TSInstantiationExpression;
                    function tSInterfaceBody(body: Array<TSTypeElement>): TSInterfaceBody;
                    function tSInterfaceDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, _extends: Array<TSExpressionWithTypeArguments> | null | undefined, body: TSInterfaceBody): TSInterfaceDeclaration;
                    function tSIntersectionType(types: Array<TSType>): TSIntersectionType;
                    function tSIntrinsicKeyword(): TSIntrinsicKeyword;
                    function tSLiteralType(literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | TemplateLiteral | UnaryExpression): TSLiteralType;
                    function tSMappedType(typeParameter: TSTypeParameter, typeAnnotation?: TSType | null, nameType?: TSType | null): TSMappedType;
                    function tSMethodSignature(key: Expression, typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<Identifier | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSMethodSignature;
                    function tSModuleBlock(body: Array<Statement>): TSModuleBlock;
                    function tSModuleDeclaration(id: Identifier | StringLiteral, body: TSModuleBlock | TSModuleDeclaration): TSModuleDeclaration;
                    function tSNamedTupleMember(label: Identifier, elementType: TSType, optional?: boolean): TSNamedTupleMember;
                    function tSNamespaceExportDeclaration(id: Identifier): TSNamespaceExportDeclaration;
                    function tSNeverKeyword(): TSNeverKeyword;
                    function tSNonNullExpression(expression: Expression): TSNonNullExpression;
                    function tSNullKeyword(): TSNullKeyword;
                    function tSNumberKeyword(): TSNumberKeyword;
                    function tSObjectKeyword(): TSObjectKeyword;
                    function tSOptionalType(typeAnnotation: TSType): TSOptionalType;
                    function tSParameterProperty(parameter: Identifier | AssignmentPattern): TSParameterProperty;
                    function tSParenthesizedType(typeAnnotation: TSType): TSParenthesizedType;
                    function tSPropertySignature(key: Expression, typeAnnotation?: TSTypeAnnotation | null, initializer?: Expression | null): TSPropertySignature;
                    function tSQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName;
                    function tSRestType(typeAnnotation: TSType): TSRestType;
                    function tSSatisfiesExpression(expression: Expression, typeAnnotation: TSType): TSSatisfiesExpression;
                    function tSStringKeyword(): TSStringKeyword;
                    function tSSymbolKeyword(): TSSymbolKeyword;
                    function tSThisType(): TSThisType;
                    function tSTupleType(elementTypes: Array<TSType | TSNamedTupleMember>): TSTupleType;
                    function tSTypeAliasDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, typeAnnotation: TSType): TSTypeAliasDeclaration;
                    function tSTypeAnnotation(typeAnnotation: TSType): TSTypeAnnotation;
                    function tSTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion;
                    function tSTypeLiteral(members: Array<TSTypeElement>): TSTypeLiteral;
                    function tSTypeOperator(typeAnnotation: TSType): TSTypeOperator;
                    function tSTypeParameter(constraint: TSType | null | undefined, _default: TSType | null | undefined, name: string): TSTypeParameter;
                    function tSTypeParameterDeclaration(params: Array<TSTypeParameter>): TSTypeParameterDeclaration;
                    function tSTypeParameterInstantiation(params: Array<TSType>): TSTypeParameterInstantiation;
                    function tSTypePredicate(parameterName: Identifier | TSThisType, typeAnnotation?: TSTypeAnnotation | null, asserts?: boolean | null): TSTypePredicate;
                    function tSTypeQuery(exprName: TSEntityName | TSImportType, typeParameters?: TSTypeParameterInstantiation | null): TSTypeQuery;
                    function tSTypeReference(typeName: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSTypeReference;
                    function tSUndefinedKeyword(): TSUndefinedKeyword;
                    function tSUnionType(types: Array<TSType>): TSUnionType;
                    function tSUnknownKeyword(): TSUnknownKeyword;
                    function tSVoidKeyword(): TSVoidKeyword;
                    function taggedTemplateExpression(tag: Expression, quasi: TemplateLiteral): TaggedTemplateExpression;
                    function templateElement(value: {
                        raw: string;
                        cooked?: string;
                    }, tail?: boolean): TemplateElement;
                    function templateLiteral(quasis: Array<TemplateElement>, expressions: Array<Expression | TSType>): TemplateLiteral;
                    function thisExpression(): ThisExpression;
                    function thisTypeAnnotation(): ThisTypeAnnotation;
                    function throwStatement(argument: Expression): ThrowStatement;
                    function toBindingIdentifierName(name: string): string;
                    function toBlock(node: Statement | Expression, parent?: Node): BlockStatement;
                    function toComputedKey(node: ObjectMember | ObjectProperty | ClassMethod | ClassProperty | ClassAccessorProperty | MemberExpression | OptionalMemberExpression, key?: Expression | PrivateName): PrivateName | Expression;
                    export const toExpression: {
                        (node: Function): FunctionExpression;
                        (node: Class): ClassExpression;
                        (node: ExpressionStatement | Expression | Class | Function): Expression;
                    };
                    //# sourceMappingURL=toExpression.d.ts.map
                    function toIdentifier(input: string): string;
                    function toKeyAlias(node: Method | Property, key?: Node): string;
                    export namespace toKeyAlias {
                        export var uid: number;
                        export var increment: () => number;
                    }
                    //# sourceMappingURL=toKeyAlias.d.ts.map
                    /**
                     * Turn an array of statement `nodes` into a `SequenceExpression`.
                     *
                     * Variable declarations are turned into simple assignments and their
                     * declarations hoisted to the top of the current scope.
                     *
                     * Expression statements are just resolved to their expression.
                     */
                    function toSequenceExpression(nodes: ReadonlyArray<Node>, scope: any): SequenceExpression | undefined;
                    export const toStatement: {
                        (node: AssignmentExpression, ignore?: boolean): ExpressionStatement;
                        <T extends Statement>(node: T, ignore: false): T;
                        <T_1 extends Statement>(node: T_1, ignore?: boolean): false | T_1;
                        (node: Class, ignore: false): ClassDeclaration;
                        (node: Class, ignore?: boolean): ClassDeclaration | false;
                        (node: Function, ignore: false): FunctionDeclaration;
                        (node: Function, ignore?: boolean): FunctionDeclaration | false;
                        (node: Node, ignore: false): Statement;
                        (node: Node, ignore?: boolean): Statement | false;
                    };
                    function topicReference(): TopicReference;
                    /**
                     * A general AST traversal with both prefix and postfix handlers, and a
                     * state object. Exposes ancestry data to each handler so that more complex
                     * AST data can be taken into account.
                     */
                    function traverse<T>(node: Node, handlers: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;
                    /**
                     * A prefix AST traversal implementation meant for simple searching
                     * and processing.
                     */
                    function traverseFast<Options = {}>(node: Node | null | undefined, enter: (node: Node, opts?: Options) => void, opts?: Options): void;
                    function tryStatement(block: BlockStatement, handler?: CatchClause | null, finalizer?: BlockStatement | null): TryStatement;
                    function tupleExpression(elements?: Array<Expression | SpreadElement>): TupleExpression;
                    function tupleTypeAnnotation(types: Array<FlowType>): TupleTypeAnnotation;
                    function typeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): TypeAlias;
                    function typeAnnotation(typeAnnotation: FlowType): TypeAnnotation;
                    function typeCastExpression(expression: Expression, typeAnnotation: TypeAnnotation): TypeCastExpression;
                    function typeParameter(bound?: TypeAnnotation | null, _default?: FlowType | null, variance?: Variance | null): TypeParameter;
                    function typeParameterDeclaration(params: Array<TypeParameter>): TypeParameterDeclaration;
                    function typeParameterInstantiation(params: Array<FlowType>): TypeParameterInstantiation;
                    function typeofTypeAnnotation(argument: FlowType): TypeofTypeAnnotation;
                    function unaryExpression(operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof", argument: Expression, prefix?: boolean): UnaryExpression;
                    function unionTypeAnnotation(types: Array<FlowType>): UnionTypeAnnotation;
                    function updateExpression(operator: "++" | "--", argument: Expression, prefix?: boolean): UpdateExpression;
                    function v8IntrinsicIdentifier(name: string): V8IntrinsicIdentifier;
                    function validate(node: Node | undefined | null, key: string, val: any): void;
                    //# sourceMappingURL=toStatement.d.ts.map
                    export const valueToNode: {
                        (value: undefined): Identifier;
                        (value: boolean): BooleanLiteral;
                        (value: null): NullLiteral;
                        (value: string): StringLiteral;
                        (value: number): NumericLiteral | BinaryExpression | UnaryExpression;
                        (value: RegExp): RegExpLiteral;
                        (value: ReadonlyArray<unknown>): ArrayExpression;
                        (value: object): ObjectExpression;
                        (value: unknown): Expression;
                    };
                    function variableDeclaration(kind: "var" | "let" | "const" | "using" | "await using", declarations: Array<VariableDeclarator>): VariableDeclaration;
                    function variableDeclarator(id: LVal, init?: Expression | null): VariableDeclarator;
                    function variance(kind: "minus" | "plus"): Variance;
                    function voidTypeAnnotation(): VoidTypeAnnotation;
                    function whileStatement(test: Expression, body: Statement): WhileStatement;
                    function withStatement(object: Expression, body: Statement): WithStatement;
                    function yieldExpression(argument?: Expression | null, delegate?: boolean): YieldExpression;
                    export import createUnionTypeAnnotation = types.createFlowUnionType;
                    export import jsxAttribute = types.jSXAttribute;
                    export import jsxClosingElement = types.jSXClosingElement;
                    export import jsxClosingFragment = types.jSXClosingFragment;
                    export import jsxElement = types.jSXElement;
                    export import jsxEmptyExpression = types.jSXEmptyExpression;
                    export import jsxExpressionContainer = types.jSXExpressionContainer;
                    export import jsxFragment = types.jSXFragment;
                    export import jsxIdentifier = types.jSXIdentifier;
                    export import jsxMemberExpression = types.jSXMemberExpression;
                    export import jsxNamespacedName = types.jSXNamespacedName;
                    export import jsxOpeningElement = types.jSXOpeningElement;
                    export import jsxOpeningFragment = types.jSXOpeningFragment;
                    export import jsxSpreadAttribute = types.jSXSpreadAttribute;
                    export import jsxSpreadChild = types.jSXSpreadChild;
                    export import jsxText = types.jSXText;
                    export import tsAnyKeyword = types.tSAnyKeyword;
                    export import tsArrayType = types.tSArrayType;
                    export import tsAsExpression = types.tSAsExpression;
                    export import tsBigIntKeyword = types.tSBigIntKeyword;
                    export import tsBooleanKeyword = types.tSBooleanKeyword;
                    export import tsCallSignatureDeclaration = types.tSCallSignatureDeclaration;
                    export import tsConditionalType = types.tSConditionalType;
                    export import tsConstructSignatureDeclaration = types.tSConstructSignatureDeclaration;
                    export import tsConstructorType = types.tSConstructorType;
                    export import tsDeclareFunction = types.tSDeclareFunction;
                    export import tsDeclareMethod = types.tSDeclareMethod;
                    export import tsEnumDeclaration = types.tSEnumDeclaration;
                    export import tsEnumMember = types.tSEnumMember;
                    export import tsExportAssignment = types.tSExportAssignment;
                    export import tsExpressionWithTypeArguments = types.tSExpressionWithTypeArguments;
                    export import tsExternalModuleReference = types.tSExternalModuleReference;
                    export import tsFunctionType = types.tSFunctionType;
                    export import tsImportEqualsDeclaration = types.tSImportEqualsDeclaration;
                    export import tsImportType = types.tSImportType;
                    export import tsIndexSignature = types.tSIndexSignature;
                    export import tsIndexedAccessType = types.tSIndexedAccessType;
                    export import tsInferType = types.tSInferType;
                    export import tsInstantiationExpression = types.tSInstantiationExpression;
                    export import tsInterfaceBody = types.tSInterfaceBody;
                    export import tsInterfaceDeclaration = types.tSInterfaceDeclaration;
                    export import tsIntersectionType = types.tSIntersectionType;
                    export import tsIntrinsicKeyword = types.tSIntrinsicKeyword;
                    export import tsLiteralType = types.tSLiteralType;
                    export import tsMappedType = types.tSMappedType;
                    export import tsMethodSignature = types.tSMethodSignature;
                    export import tsModuleBlock = types.tSModuleBlock;
                    export import tsModuleDeclaration = types.tSModuleDeclaration;
                    export import tsNamedTupleMember = types.tSNamedTupleMember;
                    export import tsNamespaceExportDeclaration = types.tSNamespaceExportDeclaration;
                    export import tsNeverKeyword = types.tSNeverKeyword;
                    export import tsNonNullExpression = types.tSNonNullExpression;
                    export import tsNullKeyword = types.tSNullKeyword;
                    export import tsNumberKeyword = types.tSNumberKeyword;
                    export import tsObjectKeyword = types.tSObjectKeyword;
                    export import tsOptionalType = types.tSOptionalType;
                    export import tsParameterProperty = types.tSParameterProperty;
                    export import tsParenthesizedType = types.tSParenthesizedType;
                    export import tsPropertySignature = types.tSPropertySignature;
                    export import tsQualifiedName = types.tSQualifiedName;
                    export import tsRestType = types.tSRestType;
                    export import tsSatisfiesExpression = types.tSSatisfiesExpression;
                    export import tsStringKeyword = types.tSStringKeyword;
                    export import tsSymbolKeyword = types.tSSymbolKeyword;
                    export import tsThisType = types.tSThisType;
                    export import tsTupleType = types.tSTupleType;
                    export import tsTypeAliasDeclaration = types.tSTypeAliasDeclaration;
                    export import tsTypeAnnotation = types.tSTypeAnnotation;
                    export import tsTypeAssertion = types.tSTypeAssertion;
                    export import tsTypeLiteral = types.tSTypeLiteral;
                    export import tsTypeOperator = types.tSTypeOperator;
                    export import tsTypeParameter = types.tSTypeParameter;
                    export import tsTypeParameterDeclaration = types.tSTypeParameterDeclaration;
                    export import tsTypeParameterInstantiation = types.tSTypeParameterInstantiation;
                    export import tsTypePredicate = types.tSTypePredicate;
                    export import tsTypeQuery = types.tSTypeQuery;
                    export import tsTypeReference = types.tSTypeReference;
                    export import tsUndefinedKeyword = types.tSUndefinedKeyword;
                    export import tsUnionType = types.tSUnionType;
                    export import tsUnknownKeyword = types.tSUnknownKeyword;
                    export import tsVoidKeyword = types.tSVoidKeyword;
                }
                export const template: DefaultTemplateBuilder;
                export const traverse: {
                    <S>(parent: types.Node | types.Node[] | null | undefined, opts: babel.traverse.TraverseOptions<S>, scope: babel.traverse.Scope | undefined, state: S, parentPath?: babel.traverse.NodePath): void;
                    (parent: types.Node | types.Node[] | null | undefined, opts?: babel.traverse.TraverseOptions, scope?: babel.traverse.Scope, state?: any, parentPath?: babel.traverse.NodePath): void;
                    visitors: typeof babel.traverse.visitors;
                    verify: typeof babel.traverse.visitors.verify;
                    explode: typeof babel.traverse.visitors.explode;
                };
                export type Node = types.Node;
                export type ParseResult = ReturnType<typeof parser.parse>;
                export const version: string;
                export const DEFAULT_EXTENSIONS: [
                    ".js",
                    ".jsx",
                    ".es6",
                    ".es",
                    ".mjs"
                ];
                export interface TransformOptions {
                    /**
                     * Specify which assumptions it can make about your code, to better optimize the compilation result. **NOTE**: This replaces the various `loose` options in plugins in favor of
                     * top-level options that can apply to multiple plugins
                     *
                     * @see https://babeljs.io/docs/en/assumptions
                     */
                    assumptions?: {
                        [name: string]: boolean;
                    } | null | undefined;
                    /**
                     * Include the AST in the returned object
                     *
                     * Default: `false`
                     */
                    ast?: boolean | null | undefined;
                    /**
                     * Attach a comment after all non-user injected code
                     *
                     * Default: `null`
                     */
                    auxiliaryCommentAfter?: string | null | undefined;
                    /**
                     * Attach a comment before all non-user injected code
                     *
                     * Default: `null`
                     */
                    auxiliaryCommentBefore?: string | null | undefined;
                    /**
                     * Specify the "root" folder that defines the location to search for "babel.config.js", and the default folder to allow `.babelrc` files inside of.
                     *
                     * Default: `"."`
                     */
                    root?: string | null | undefined;
                    /**
                     * This option, combined with the "root" value, defines how Babel chooses its project root.
                     * The different modes define different ways that Babel can process the "root" value to get
                     * the final project root.
                     *
                     * @see https://babeljs.io/docs/en/next/options#rootmode
                     */
                    rootMode?: "root" | "upward" | "upward-optional" | undefined;
                    /**
                     * The config file to load Babel's config from. Defaults to searching for "babel.config.js" inside the "root" folder. `false` will disable searching for config files.
                     *
                     * Default: `undefined`
                     */
                    configFile?: string | boolean | null | undefined;
                    /**
                     * Specify whether or not to use .babelrc and
                     * .babelignore files.
                     *
                     * Default: `true`
                     */
                    babelrc?: boolean | null | undefined;
                    /**
                     * Specify which packages should be search for .babelrc files when they are being compiled. `true` to always search, or a path string or an array of paths to packages to search
                     * inside of. Defaults to only searching the "root" package.
                     *
                     * Default: `(root)`
                     */
                    babelrcRoots?: boolean | MatchPattern | MatchPattern[] | null | undefined;
                    /**
                     * Toggles whether or not browserslist config sources are used, which includes searching for any browserslist files or referencing the browserslist key inside package.json.
                     * This is useful for projects that use a browserslist config for files that won't be compiled with Babel.
                     *
                     * If a string is specified, it must represent the path of a browserslist configuration file. Relative paths are resolved relative to the configuration file which specifies
                     * this option, or to `cwd` when it's passed as part of the programmatic options.
                     *
                     * Default: `true`
                     */
                    browserslistConfigFile?: boolean | null | undefined;
                    /**
                     * The Browserslist environment to use.
                     *
                     * Default: `undefined`
                     */
                    browserslistEnv?: string | null | undefined;
                    /**
                     * By default `babel.transformFromAst` will clone the input AST to avoid mutations.
                     * Specifying `cloneInputAst: false` can improve parsing performance if the input AST is not used elsewhere.
                     *
                     * Default: `true`
                     */
                    cloneInputAst?: boolean | null | undefined;
                    /**
                     * Defaults to environment variable `BABEL_ENV` if set, or else `NODE_ENV` if set, or else it defaults to `"development"`
                     *
                     * Default: env vars
                     */
                    envName?: string | undefined;
                    /**
                     * If any of patterns match, the current configuration object is considered inactive and is ignored during config processing.
                     */
                    exclude?: MatchPattern | MatchPattern[] | undefined;
                    /**
                     * Enable code generation
                     *
                     * Default: `true`
                     */
                    code?: boolean | null | undefined;
                    /**
                     * Output comments in generated output
                     *
                     * Default: `true`
                     */
                    comments?: boolean | null | undefined;
                    /**
                     * Do not include superfluous whitespace characters and line terminators. When set to `"auto"` compact is set to `true` on input sizes of >500KB
                     *
                     * Default: `"auto"`
                     */
                    compact?: boolean | "auto" | null | undefined;
                    /**
                     * The working directory that Babel's programmatic options are loaded relative to.
                     *
                     * Default: `"."`
                     */
                    cwd?: string | null | undefined;
                    /**
                     * Utilities may pass a caller object to identify themselves to Babel and
                     * pass capability-related flags for use by configs, presets and plugins.
                     *
                     * @see https://babeljs.io/docs/en/next/options#caller
                     */
                    caller?: TransformCaller | undefined;
                    /**
                     * This is an object of keys that represent different environments. For example, you may have: `{ env: { production: { \/* specific options *\/ } } }`
                     * which will use those options when the `envName` is `production`
                     *
                     * Default: `{}`
                     */
                    env?: {
                        [index: string]: TransformOptions | null | undefined;
                    } | null | undefined;
                    /**
                     * A path to a `.babelrc` file to extend
                     *
                     * Default: `null`
                     */
                    extends?: string | null | undefined;
                    /**
                     * Filename for use in errors etc
                     *
                     * Default: `"unknown"`
                     */
                    filename?: string | null | undefined;
                    /**
                     * Filename relative to `sourceRoot`
                     *
                     * Default: `(filename)`
                     */
                    filenameRelative?: string | null | undefined;
                    /**
                     * An object containing the options to be passed down to the babel code generator, @babel/generator
                     *
                     * Default: `{}`
                     */
                    generatorOpts?: GeneratorOptions | null | undefined;
                    /**
                     * Specify a custom callback to generate a module id with. Called as `getModuleId(moduleName)`. If falsy value is returned then the generated module id is used
                     *
                     * Default: `null`
                     */
                    getModuleId?: ((moduleName: string) => string | null | undefined) | null | undefined;
                    /**
                     * ANSI highlight syntax error code frames
                     *
                     * Default: `true`
                     */
                    highlightCode?: boolean | null | undefined;
                    /**
                     * Opposite to the `only` option. `ignore` is disregarded if `only` is specified
                     *
                     * Default: `null`
                     */
                    ignore?: MatchPattern[] | null | undefined;
                    /**
                     * This option is a synonym for "test"
                     */
                    include?: MatchPattern | MatchPattern[] | undefined;
                    /**
                     * A source map object that the output source map will be based on
                     *
                     * Default: `null`
                     */
                    inputSourceMap?: InputSourceMap | null | undefined;
                    /**
                     * Should the output be minified (not printing last semicolons in blocks, printing literal string values instead of escaped ones, stripping `()` from `new` when safe)
                     *
                     * Default: `false`
                     */
                    minified?: boolean | null | undefined;
                    /**
                     * Specify a custom name for module ids
                     *
                     * Default: `null`
                     */
                    moduleId?: string | null | undefined;
                    /**
                     * If truthy, insert an explicit id for modules. By default, all modules are anonymous. (Not available for `common` modules)
                     *
                     * Default: `false`
                     */
                    moduleIds?: boolean | null | undefined;
                    /**
                     * Optional prefix for the AMD module formatter that will be prepend to the filename on module definitions
                     *
                     * Default: `(sourceRoot)`
                     */
                    moduleRoot?: string | null | undefined;
                    /**
                     * A glob, regex, or mixed array of both, matching paths to **only** compile. Can also be an array of arrays containing paths to explicitly match. When attempting to compile
                     * a non-matching file it's returned verbatim
                     *
                     * Default: `null`
                     */
                    only?: MatchPattern[] | null | undefined;
                    /**
                     * Allows users to provide an array of options that will be merged into the current configuration one at a time.
                     * This feature is best used alongside the "test"/"include"/"exclude" options to provide conditions for which an override should apply
                     */
                    overrides?: TransformOptions[] | undefined;
                    /**
                     * An object containing the options to be passed down to the babel parser, @babel/parser
                     *
                     * Default: `{}`
                     */
                    parserOpts?: ParserOptions | null | undefined;
                    /**
                     * List of plugins to load and use
                     *
                     * Default: `[]`
                     */
                    plugins?: PluginItem[] | null | undefined;
                    /**
                     * List of presets (a set of plugins) to load and use
                     *
                     * Default: `[]`
                     */
                    presets?: PluginItem[] | null | undefined;
                    /**
                     * Retain line numbers. This will lead to wacky code but is handy for scenarios where you can't use source maps. (**NOTE**: This will not retain the columns)
                     *
                     * Default: `false`
                     */
                    retainLines?: boolean | null | undefined;
                    /**
                     * An optional callback that controls whether a comment should be output or not. Called as `shouldPrintComment(commentContents)`. **NOTE**: This overrides the `comment` option when used
                     *
                     * Default: `null`
                     */
                    shouldPrintComment?: ((commentContents: string) => boolean) | null | undefined;
                    /**
                     * Set `sources[0]` on returned source map
                     *
                     * Default: `(filenameRelative)`
                     */
                    sourceFileName?: string | null | undefined;
                    /**
                     * If truthy, adds a `map` property to returned output. If set to `"inline"`, a comment with a sourceMappingURL directive is added to the bottom of the returned code. If set to `"both"`
                     * then a `map` property is returned as well as a source map comment appended. **This does not emit sourcemap files by itself!**
                     *
                     * Default: `false`
                     */
                    sourceMaps?: boolean | "inline" | "both" | null | undefined;
                    /**
                     * The root from which all sources are relative
                     *
                     * Default: `(moduleRoot)`
                     */
                    sourceRoot?: string | null | undefined;
                    /**
                     * Indicate the mode the code should be parsed in. Can be one of "script", "module", or "unambiguous". `"unambiguous"` will make Babel attempt to guess, based on the presence of ES6
                     * `import` or `export` statements. Files with ES6 `import`s and `export`s are considered `"module"` and are otherwise `"script"`.
                     *
                     * Default: `("module")`
                     */
                    sourceType?: "script" | "module" | "unambiguous" | null | undefined;
                    /**
                     * If all patterns fail to match, the current configuration object is considered inactive and is ignored during config processing.
                     */
                    test?: MatchPattern | MatchPattern[] | undefined;
                    /**
                     * An optional callback that can be used to wrap visitor methods. **NOTE**: This is useful for things like introspection, and not really needed for implementing anything. Called as
                     * `wrapPluginVisitorMethod(pluginAlias, visitorType, callback)`.
                     */
                    wrapPluginVisitorMethod?: ((pluginAlias: string, visitorType: "enter" | "exit", callback: (path: babel.traverse.NodePath, state: any) => void) => (path: babel.traverse.NodePath, state: any) => void) | null | undefined;
                }
                export interface TransformCaller {
                    // the only required property
                    name: string;
                    // e.g. set to true by `babel-loader` and false by `babel-jest`
                    supportsStaticESM?: boolean | undefined;
                    supportsDynamicImport?: boolean | undefined;
                    supportsExportNamespaceFrom?: boolean | undefined;
                    supportsTopLevelAwait?: boolean | undefined;
                }
                export type FileResultCallback = (err: Error | null, result: BabelFileResult | null) => any;
                export interface MatchPatternContext {
                    envName: string;
                    dirname: string;
                    caller: TransformCaller | undefined;
                }
                export type MatchPattern = string | RegExp | ((filename: string | undefined, context: MatchPatternContext) => boolean);
                // A babel plugin is a simple function which must return an object matching
                // the following interface. Babel will throw if it finds unknown properties.
                // The list of allowed plugin keys is here:
                // https://github.com/babel/babel/blob/4e50b2d9d9c376cee7a2cbf56553fe5b982ea53c/packages/babel-core/src/config/option-manager.js#L71
                export interface PluginObj<S = PluginPass> {
                    name?: string | undefined;
                    manipulateOptions?(opts: any, parserOpts: any): void;
                    pre?(this: S, file: BabelFile): void;
                    visitor: babel.traverse.Visitor<S>;
                    post?(this: S, file: BabelFile): void;
                    inherits?: any;
                }
                export interface BabelFile {
                    ast: types.File;
                    opts: TransformOptions;
                    hub: babel.traverse.Hub;
                    metadata: object;
                    path: babel.traverse.NodePath<types.Program>;
                    scope: babel.traverse.Scope;
                    inputMap: object | null;
                    code: string;
                }
                export interface PluginPass {
                    file: BabelFile;
                    key: string;
                    opts: object;
                    cwd: string;
                    filename: string | undefined;
                    get(key: unknown): any;
                    set(key: unknown, value: unknown): void;
                    [key: string]: unknown;
                }
                export interface BabelFileResult {
                    ast?: types.File | null | undefined;
                    code?: string | null | undefined;
                    ignored?: boolean | undefined;
                    map?: {
                        version: number;
                        sources: string[];
                        names: string[];
                        sourceRoot?: string | undefined;
                        sourcesContent?: string[] | undefined;
                        mappings: string;
                        file: string;
                    } | null | undefined;
                    metadata?: BabelFileMetadata | undefined;
                }
                export interface BabelFileMetadata {
                    usedHelpers: string[];
                    marked: Array<{
                        type: string;
                        message: string;
                        loc: object;
                    }>;
                    modules: BabelFileModulesMetadata;
                }
                export interface BabelFileModulesMetadata {
                    imports: object[];
                    exports: {
                        exported: object[];
                        specifiers: object[];
                    };
                }
                export type FileParseCallback = (err: Error | null, result: ParseResult | null) => any;
                export interface PartialConfig {
                    options: TransformOptions;
                    babelrc?: string | undefined;
                    babelignore?: string | undefined;
                    config?: string | undefined;
                    hasFilesystemConfig: () => boolean;
                }
                export interface ConfigItem {
                    /**
                     * The name that the user gave the plugin instance, e.g. `plugins: [ ['env', {}, 'my-env'] ]`
                     */
                    name?: string | undefined;
                    /**
                     * The resolved value of the plugin.
                     */
                    value: object | ((...args: any[]) => any);
                    /**
                     * The options object passed to the plugin.
                     */
                    options?: object | false | undefined;
                    /**
                     * The path that the options are relative to.
                     */
                    dirname: string;
                    /**
                     * Information about the plugin's file, if Babel knows it.
                     *  *
                     */
                    file?: {
                        /**
                         * The file that the user requested, e.g. `"@babel/env"`
                         */
                        request: string;
                        /**
                         * The full path of the resolved file, e.g. `"/tmp/node_modules/@babel/preset-env/lib/index.js"`
                         */
                        resolved: string;
                    } | null | undefined;
                }
                export type PluginOptions = object | undefined | false;
                export type PluginTarget = string | object | ((...args: any[]) => any);
                export type PluginItem = ConfigItem | PluginObj<any> | PluginTarget | [
                    PluginTarget,
                    PluginOptions
                ] | [
                    PluginTarget,
                    PluginOptions,
                    string | undefined
                ];
                export interface CreateConfigItemOptions {
                    dirname?: string | undefined;
                    type?: "preset" | "plugin" | undefined;
                }
                // NOTE: the documentation says the ConfigAPI also exposes @babel/core's exports, but it actually doesn't
                /**
                 * @see https://babeljs.io/docs/en/next/config-files#config-function-api
                 */
                export interface ConfigAPI {
                    /**
                     * The version string for the Babel version that is loading the config file.
                     *
                     * @see https://babeljs.io/docs/en/next/config-files#apiversion
                     */
                    version: string;
                    /**
                     * @see https://babeljs.io/docs/en/next/config-files#apicache
                     */
                    cache: SimpleCacheConfigurator;
                    /**
                     * @see https://babeljs.io/docs/en/next/config-files#apienv
                     */
                    env: EnvFunction;
                    // undocumented; currently hardcoded to return 'false'
                    // async(): boolean
                    /**
                     * This API is used as a way to access the `caller` data that has been passed to Babel.
                     * Since many instances of Babel may be running in the same process with different `caller` values,
                     * this API is designed to automatically configure `api.cache`, the same way `api.env()` does.
                     *
                     * The `caller` value is available as the first parameter of the callback function.
                     * It is best used with something like this to toggle configuration behavior
                     * based on a specific environment:
                     *
                     * @example
                     * function isBabelRegister(caller?: { name: string }) {
                     *   return !!(caller && caller.name === "@babel/register")
                     * }
                     * api.caller(isBabelRegister)
                     *
                     * @see https://babeljs.io/docs/en/next/config-files#apicallercb
                     */
                    caller<T extends SimpleCacheKey>(callerCallback: (caller: TransformOptions["caller"]) => T): T;
                    /**
                     * While `api.version` can be useful in general, it's sometimes nice to just declare your version.
                     * This API exposes a simple way to do that with:
                     *
                     * @example
                     * api.assertVersion(7) // major version only
                     * api.assertVersion("^7.2")
                     *
                     * @see https://babeljs.io/docs/en/next/config-files#apiassertversionrange
                     */
                    assertVersion(versionRange: number | string): boolean;
                }
                /**
                 * JS configs are great because they can compute a config on the fly,
                 * but the downside there is that it makes caching harder.
                 * Babel wants to avoid re-executing the config function every time a file is compiled,
                 * because then it would also need to re-execute any plugin and preset functions
                 * referenced in that config.
                 *
                 * To avoid this, Babel expects users of config functions to tell it how to manage caching
                 * within a config file.
                 *
                 * @see https://babeljs.io/docs/en/next/config-files#apicache
                 */
                export interface SimpleCacheConfigurator {
                    // there is an undocumented call signature that is a shorthand for forever()/never()/using().
                    // (ever: boolean): void
                    // <T extends SimpleCacheKey>(callback: CacheCallback<T>): T
                    /**
                     * Permacache the computed config and never call the function again.
                     */
                    forever(): void;
                    /**
                     * Do not cache this config, and re-execute the function every time.
                     */
                    never(): void;
                    /**
                     * Any time the using callback returns a value other than the one that was expected,
                     * the overall config function will be called again and a new entry will be added to the cache.
                     *
                     * @example
                     * api.cache.using(() => process.env.NODE_ENV)
                     */
                    using<T extends SimpleCacheKey>(callback: SimpleCacheCallback<T>): T;
                    /**
                     * Any time the using callback returns a value other than the one that was expected,
                     * the overall config function will be called again and all entries in the cache will
                     * be replaced with the result.
                     *
                     * @example
                     * api.cache.invalidate(() => process.env.NODE_ENV)
                     */
                    invalidate<T extends SimpleCacheKey>(callback: SimpleCacheCallback<T>): T;
                }
                // https://github.com/babel/babel/blob/v7.3.3/packages/babel-core/src/config/caching.js#L231
                export type SimpleCacheKey = string | boolean | number | null | undefined;
                export type SimpleCacheCallback<T extends SimpleCacheKey> = () => T;
                /**
                 * Since `NODE_ENV` is a fairly common way to toggle behavior, Babel also includes an API function
                 * meant specifically for that. This API is used as a quick way to check the `"envName"` that Babel
                 * was loaded with, which takes `NODE_ENV` into account if no other overriding environment is set.
                 *
                 * @see https://babeljs.io/docs/en/next/config-files#apienv
                 */
                export interface EnvFunction {
                    /**
                     * @returns the current `envName` string
                     */
                    (): string;
                    /**
                     * @returns `true` if the `envName` is `===` any of the given strings
                     */
                    (envName: string | ReadonlyArray<string>): boolean;
                    // the official documentation is misleading for this one...
                    // this just passes the callback to `cache.using` but with an additional argument.
                    // it returns its result instead of necessarily returning a boolean.
                    <T extends SimpleCacheKey>(envCallback: (envName: NonNullable<TransformOptions["envName"]>) => T): T;
                }
                export type ConfigFunction = (api: ConfigAPI) => TransformOptions;
                export import NodePath = babel.traverse.NodePath;
                export import Visitor = babel.traverse.Visitor;
            }
            export namespace parser {
                export interface DecoratorsPluginOptions {
                    decoratorsBeforeExport?: boolean;
                    allowCallParenthesized?: boolean;
                }
                export interface FlowPluginOptions {
                    all?: boolean;
                    enums?: boolean;
                }
                export interface ParseError {
                    code: string;
                    reasonCode: string;
                }
                export type ParseResult<Result> = Result & {
                    errors: ParseError[];
                };
                export type ParserPlugin = PluginConfig;
                export type ParserPluginWithOptions = [
                    "decorators",
                    DecoratorsPluginOptions
                ] | [
                    "estree",
                    {
                        classFeatures?: boolean;
                    }
                ] | [
                    "importAttributes",
                    {
                        deprecatedAssertSyntax: boolean;
                    }
                ] | [
                    "moduleAttributes",
                    {
                        version: "may-2020";
                    }
                ] | [
                    "pipelineOperator",
                    PipelineOperatorPluginOptions
                ] | [
                    "recordAndTuple",
                    RecordAndTuplePluginOptions
                ] | [
                    "flow",
                    FlowPluginOptions
                ] | [
                    "typescript",
                    TypeScriptPluginOptions
                ];
                export interface PipelineOperatorPluginOptions {
                    proposal: "minimal" | "fsharp" | "hack" | "smart";
                    topicToken?: "%" | "#" | "@@" | "^^" | "^";
                }
                export interface RecordAndTuplePluginOptions {
                    syntaxType: "bar" | "hash";
                }
                export interface TypeScriptPluginOptions {
                    dts?: boolean;
                    disallowAmbiguousJSXLike?: boolean;
                }
                // Type definitions for @babel/parser
                // Project: https://github.com/babel/babel/tree/main/packages/babel-parser
                // Definitions by: Troy Gerwien <https://github.com/yortus>
                //                 Marvin Hagemeister <https://github.com/marvinhagemeister>
                //                 Avi Vahl <https://github.com/AviVahl>
                // TypeScript Version: 2.9
                /**
                 * Parse the provided code as an entire ECMAScript program.
                 */
                function parse(input: string, options?: core.ParserOptions): ParseResult<core.types.File>;
                /**
                 * Parse the provided code as a single expression.
                 */
                function parseExpression(input: string, options?: core.ParserOptions): ParseResult<core.types.Expression>;
                export const tokTypes: {
                    // todo(flow->ts) real token type
                    [name: string]: any;
                };
                export import ParserOptions = core.ParserOptions;
            }
            export namespace traverse {
                export class NodePath<T = core.types.Node> {
                    constructor(hub: Hub, parent: core.types.Node);
                    parent: core.types.Node;
                    hub: Hub;
                    contexts: TraversalContext[];
                    data: object;
                    shouldSkip: boolean;
                    shouldStop: boolean;
                    removed: boolean;
                    state: any;
                    opts: object;
                    skipKeys: object;
                    parentPath: T extends core.types.Program ? null : NodePath;
                    context: TraversalContext;
                    container: object | object[];
                    listKey: string;
                    inList: boolean;
                    parentKey: string;
                    key: string | number;
                    node: T;
                    scope: Scope;
                    type: T extends null | undefined ? undefined : T extends core.types.Node ? T["type"] : string | undefined;
                    typeAnnotation: object;
                    getScope(scope: Scope): Scope;
                    setData(key: string, val: any): any;
                    getData(key: string, def?: any): any;
                    hasNode(): this is NodePath<NonNullable<this["node"]>>;
                    buildCodeFrameError<TError extends Error>(msg: string, Error?: new (msg: string) => TError): TError;
                    traverse<T>(visitor: Visitor<T>, state: T): void;
                    traverse(visitor: Visitor): void;
                    set(key: string, node: core.types.Node): void;
                    getPathLocation(): string;
                    // Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
                    debug(buildMessage: () => string): void;
                    static get<C extends core.types.Node, K extends keyof C>(opts: {
                        hub: HubInterface;
                        parentPath: NodePath | null;
                        parent: core.types.Node;
                        container: C;
                        listKey?: string | undefined;
                        key: K;
                    }): NodePath<C[K]>;
                    //#region ------------------------- ancestry -------------------------
                    /**
                     * Starting at the parent path of the current `NodePath` and going up the
                     * tree, return the first `NodePath` that causes the provided `callback`
                     * to return a truthy value, or `null` if the `callback` never returns a
                     * truthy value.
                     */
                    findParent(callback: (path: NodePath) => boolean): NodePath | null;
                    /**
                     * Starting at current `NodePath` and going up the tree, return the first
                     * `NodePath` that causes the provided `callback` to return a truthy value,
                     * or `null` if the `callback` never returns a truthy value.
                     */
                    find(callback: (path: NodePath) => boolean): NodePath | null;
                    /** Get the parent function of the current path. */
                    getFunctionParent(): NodePath<core.types.Function> | null;
                    /** Walk up the tree until we hit a parent node path in a list. */
                    getStatementParent(): NodePath<core.types.Statement> | null;
                    /**
                     * Get the deepest common ancestor and then from it, get the earliest relationship path
                     * to that ancestor.
                     *
                     * Earliest is defined as being "before" all the other nodes in terms of list container
                     * position and visiting key.
                     */
                    getEarliestCommonAncestorFrom(paths: NodePath[]): NodePath;
                    /** Get the earliest path in the tree where the provided `paths` intersect. */
                    getDeepestCommonAncestorFrom(paths: NodePath[], filter?: (deepest: core.types.Node, i: number, ancestries: NodePath[]) => NodePath): NodePath;
                    /**
                     * Build an array of node paths containing the entire ancestry of the current node path.
                     *
                     * NOTE: The current node path is included in this.
                     */
                    getAncestry(): [
                        this,
                        ...NodePath[]
                    ];
                    /**
                     * A helper to find if `this` path is an ancestor of `maybeDescendant`
                     */
                    isAncestor(maybeDescendant: NodePath): boolean;
                    /**
                     * A helper to find if `this` path is a descendant of `maybeAncestor`
                     */
                    isDescendant(maybeAncestor: NodePath): boolean;
                    inType(...candidateTypes: string[]): boolean;
                    //#endregion
                    //#region ------------------------- inference -------------------------
                    /** Infer the type of the current `NodePath`. */
                    getTypeAnnotation(): core.types.FlowType;
                    isBaseType(baseName: string, soft?: boolean): boolean;
                    couldBeBaseType(name: string): boolean;
                    baseTypeStrictlyMatches(right: NodePath): boolean;
                    isGenericType(genericName: string): boolean;
                    //#endregion
                    //#region ------------------------- replacement -------------------------
                    /**
                     * Replace a node with an array of multiple. This method performs the following steps:
                     *
                     *  - Inherit the comments of first provided node with that of the current node.
                     *  - Insert the provided nodes after the current node.
                     *  - Remove the current node.
                     */
                    replaceWithMultiple<Nodes extends readonly core.types.Node[]>(nodes: Nodes): NodePaths<Nodes>;
                    /**
                     * Parse a string as an expression and replace the current node with the result.
                     *
                     * NOTE: This is typically not a good idea to use. Building source strings when
                     * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
                     * easier to use, your transforms will be extremely brittle.
                     */
                    replaceWithSourceString(replacement: any): [
                        NodePath
                    ];
                    /** Replace the current node with another. */
                    replaceWith<T extends core.types.Node>(replacement: T | NodePath<T>): [
                        NodePath<T>
                    ];
                    /**
                     * This method takes an array of statements nodes and then explodes it
                     * into expressions. This method retains completion records which is
                     * extremely important to retain original semantics.
                     */
                    replaceExpressionWithStatements<Nodes extends readonly core.types.Node[]>(nodes: Nodes): NodePaths<Nodes>;
                    replaceInline<Nodes extends core.types.Node | readonly core.types.Node[]>(nodes: Nodes): NodePaths<Nodes>;
                    //#endregion
                    //#region ------------------------- evaluation -------------------------
                    /**
                     * Walk the input `node` and statically evaluate if it's truthy.
                     *
                     * Returning `true` when we're sure that the expression will evaluate to a
                     * truthy value, `false` if we're sure that it will evaluate to a falsy
                     * value and `undefined` if we aren't sure. Because of this please do not
                     * rely on coercion when using this method and check with === if it's false.
                     */
                    evaluateTruthy(): boolean;
                    /**
                     * Walk the input `node` and statically evaluate it.
                     *
                     * Returns an object in the form `{ confident, value }`. `confident` indicates
                     * whether or not we had to drop out of evaluating the expression because of
                     * hitting an unknown node that we couldn't confidently find the value of.
                     *
                     * Example:
                     *
                     *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
                     *   t.evaluate(parse("!true")) // { confident: true, value: false }
                     *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
                     */
                    evaluate(): {
                        confident: boolean;
                        value: any;
                    };
                    //#endregion
                    //#region ------------------------- introspection -------------------------
                    /**
                     * Match the current node if it matches the provided `pattern`.
                     *
                     * For example, given the match `React.createClass` it would match the
                     * parsed nodes of `React.createClass` and `React["createClass"]`.
                     */
                    matchesPattern(pattern: string, allowPartial?: boolean): boolean;
                    /**
                     * Check whether we have the input `key`. If the `key` references an array then we check
                     * if the array has any items, otherwise we just check if it's falsy.
                     */
                    has(key: string): boolean;
                    isStatic(): boolean;
                    /** Alias of `has`. */
                    is(key: string): boolean;
                    /** Opposite of `has`. */
                    isnt(key: string): boolean;
                    /** Check whether the path node `key` strict equals `value`. */
                    equals(key: string, value: any): boolean;
                    /**
                     * Check the type against our stored internal type of the node. This is handy when a node has
                     * been removed yet we still internally know the type and need it to calculate node replacement.
                     */
                    isNodeType(type: string): boolean;
                    /**
                     * This checks whether or not we're in one of the following positions:
                     *
                     *   for (KEY in right);
                     *   for (KEY;;);
                     *
                     * This is because these spots allow VariableDeclarations AND normal expressions so we need
                     * to tell the path replacement that it's ok to replace this with an expression.
                     */
                    canHaveVariableDeclarationOrExpression(): boolean;
                    /**
                     * This checks whether we are swapping an arrow function's body between an
                     * expression and a block statement (or vice versa).
                     *
                     * This is because arrow functions may implicitly return an expression, which
                     * is the same as containing a block statement.
                     */
                    canSwapBetweenExpressionAndStatement(replacement: core.types.Node): boolean;
                    /** Check whether the current path references a completion record */
                    isCompletionRecord(allowInsideFunction?: boolean): boolean;
                    /**
                     * Check whether or not the current `key` allows either a single statement or block statement
                     * so we can explode it if necessary.
                     */
                    isStatementOrBlock(): boolean;
                    /** Check if the currently assigned path references the `importName` of `moduleSource`. */
                    referencesImport(moduleSource: string, importName: string): boolean;
                    /** Get the source code associated with this node. */
                    getSource(): string;
                    /** Check if the current path will maybe execute before another path */
                    willIMaybeExecuteBefore(path: NodePath): boolean;
                    //#endregion
                    //#region ------------------------- context -------------------------
                    call(key: string): boolean;
                    isBlacklisted(): boolean;
                    visit(): boolean;
                    skip(): void;
                    skipKey(key: string): void;
                    stop(): void;
                    setScope(): void;
                    setContext(context?: TraversalContext): this;
                    popContext(): void;
                    pushContext(context: TraversalContext): void;
                    //#endregion
                    //#region ------------------------- removal -------------------------
                    remove(): void;
                    //#endregion
                    //#region ------------------------- modification -------------------------
                    /** Insert the provided nodes before the current one. */
                    insertBefore<Nodes extends core.types.Node | readonly core.types.Node[]>(nodes: Nodes): NodePaths<Nodes>;
                    /**
                     * Insert the provided nodes after the current one. When inserting nodes after an
                     * expression, ensure that the completion record is correct by pushing the current node.
                     */
                    insertAfter<Nodes extends core.types.Node | readonly core.types.Node[]>(nodes: Nodes): NodePaths<Nodes>;
                    /** Update all sibling node paths after `fromIndex` by `incrementBy`. */
                    updateSiblingKeys(fromIndex: number, incrementBy: number): void;
                    /**
                     * Insert child nodes at the start of the current node.
                     * @param listKey - The key at which the child nodes are stored (usually body).
                     * @param nodes - the nodes to insert.
                     */
                    unshiftContainer<Nodes extends core.types.Node | readonly core.types.Node[]>(listKey: ArrayKeys<T>, nodes: Nodes): NodePaths<Nodes>;
                    /**
                     * Insert child nodes at the end of the current node.
                     * @param listKey - The key at which the child nodes are stored (usually body).
                     * @param nodes - the nodes to insert.
                     */
                    pushContainer<Nodes extends core.types.Node | readonly core.types.Node[]>(listKey: ArrayKeys<T>, nodes: Nodes): NodePaths<Nodes>;
                    /** Hoist the current node to the highest scope possible and return a UID referencing it. */
                    hoist(scope: Scope): void;
                    //#endregion
                    //#region ------------------------- family -------------------------
                    getOpposite(): NodePath;
                    getCompletionRecords(): NodePath[];
                    getSibling(key: string | number): NodePath;
                    getPrevSibling(): NodePath;
                    getNextSibling(): NodePath;
                    getAllPrevSiblings(): NodePath[];
                    getAllNextSiblings(): NodePath[];
                    get<K extends keyof T>(key: K, context?: boolean | TraversalContext): NodePathResult<T[K]>;
                    get(key: string, context?: boolean | TraversalContext): NodePath | NodePath[];
                    getBindingIdentifiers(duplicates: true): Record<string, core.types.Identifier[]>;
                    getBindingIdentifiers(duplicates?: false): Record<string, core.types.Identifier>;
                    getBindingIdentifiers(duplicates?: boolean): Record<string, core.types.Identifier | core.types.Identifier[]>;
                    getOuterBindingIdentifiers(duplicates: true): Record<string, core.types.Identifier[]>;
                    getOuterBindingIdentifiers(duplicates?: false): Record<string, core.types.Identifier>;
                    getOuterBindingIdentifiers(duplicates?: boolean): Record<string, core.types.Identifier | core.types.Identifier[]>;
                    getBindingIdentifierPaths(duplicates: true, outerOnly?: boolean): Record<string, Array<NodePath<core.types.Identifier>>>;
                    getBindingIdentifierPaths(duplicates?: false, outerOnly?: boolean): Record<string, NodePath<core.types.Identifier>>;
                    getBindingIdentifierPaths(duplicates?: boolean, outerOnly?: boolean): Record<string, NodePath<core.types.Identifier> | Array<NodePath<core.types.Identifier>>>;
                    getOuterBindingIdentifierPaths(duplicates: true): Record<string, Array<NodePath<core.types.Identifier>>>;
                    getOuterBindingIdentifierPaths(duplicates?: false): Record<string, NodePath<core.types.Identifier>>;
                    getOuterBindingIdentifierPaths(duplicates?: boolean, outerOnly?: boolean): Record<string, NodePath<core.types.Identifier> | Array<NodePath<core.types.Identifier>>>;
                    //#endregion
                    //#region ------------------------- comments -------------------------
                    /** Share comments amongst siblings. */
                    shareCommentsWithSiblings(): void;
                    addComment(type: string, content: string, line?: boolean): void;
                    /** Give node `comments` of the specified `type`. */
                    addComments(type: string, comments: any[]): void;
                    //#endregion
                    //#region ------------------------- isXXX -------------------------
                    isAnyTypeAnnotation(props?: object | null): this is NodePath<core.types.AnyTypeAnnotation>;
                    isArrayExpression(props?: object | null): this is NodePath<core.types.ArrayExpression>;
                    isArrayPattern(props?: object | null): this is NodePath<core.types.ArrayPattern>;
                    isArrayTypeAnnotation(props?: object | null): this is NodePath<core.types.ArrayTypeAnnotation>;
                    isArrowFunctionExpression(props?: object | null): this is NodePath<core.types.ArrowFunctionExpression>;
                    isAssignmentExpression(props?: object | null): this is NodePath<core.types.AssignmentExpression>;
                    isAssignmentPattern(props?: object | null): this is NodePath<core.types.AssignmentPattern>;
                    isAwaitExpression(props?: object | null): this is NodePath<core.types.AwaitExpression>;
                    isBigIntLiteral(props?: object | null): this is NodePath<core.types.BigIntLiteral>;
                    isBinary(props?: object | null): this is NodePath<core.types.Binary>;
                    isBinaryExpression(props?: object | null): this is NodePath<core.types.BinaryExpression>;
                    isBindExpression(props?: object | null): this is NodePath<core.types.BindExpression>;
                    isBlock(props?: object | null): this is NodePath<core.types.Block>;
                    isBlockParent(props?: object | null): this is NodePath<core.types.BlockParent>;
                    isBlockStatement(props?: object | null): this is NodePath<core.types.BlockStatement>;
                    isBooleanLiteral(props?: object | null): this is NodePath<core.types.BooleanLiteral>;
                    isBooleanLiteralTypeAnnotation(props?: object | null): this is NodePath<core.types.BooleanLiteralTypeAnnotation>;
                    isBooleanTypeAnnotation(props?: object | null): this is NodePath<core.types.BooleanTypeAnnotation>;
                    isBreakStatement(props?: object | null): this is NodePath<core.types.BreakStatement>;
                    isCallExpression(props?: object | null): this is NodePath<core.types.CallExpression>;
                    isCatchClause(props?: object | null): this is NodePath<core.types.CatchClause>;
                    isClass(props?: object | null): this is NodePath<core.types.Class>;
                    isClassBody(props?: object | null): this is NodePath<core.types.ClassBody>;
                    isClassDeclaration(props?: object | null): this is NodePath<core.types.ClassDeclaration>;
                    isClassExpression(props?: object | null): this is NodePath<core.types.ClassExpression>;
                    isClassImplements(props?: object | null): this is NodePath<core.types.ClassImplements>;
                    isClassMethod(props?: object | null): this is NodePath<core.types.ClassMethod>;
                    isClassPrivateMethod(props?: object | null): this is NodePath<core.types.ClassPrivateMethod>;
                    isClassPrivateProperty(props?: object | null): this is NodePath<core.types.ClassPrivateProperty>;
                    isClassProperty(props?: object | null): this is NodePath<core.types.ClassProperty>;
                    isCompletionStatement(props?: object | null): this is NodePath<core.types.CompletionStatement>;
                    isConditional(props?: object | null): this is NodePath<core.types.Conditional>;
                    isConditionalExpression(props?: object | null): this is NodePath<core.types.ConditionalExpression>;
                    isContinueStatement(props?: object | null): this is NodePath<core.types.ContinueStatement>;
                    isDebuggerStatement(props?: object | null): this is NodePath<core.types.DebuggerStatement>;
                    isDeclaration(props?: object | null): this is NodePath<core.types.Declaration>;
                    isDeclareClass(props?: object | null): this is NodePath<core.types.DeclareClass>;
                    isDeclareExportAllDeclaration(props?: object | null): this is NodePath<core.types.DeclareExportAllDeclaration>;
                    isDeclareExportDeclaration(props?: object | null): this is NodePath<core.types.DeclareExportDeclaration>;
                    isDeclareFunction(props?: object | null): this is NodePath<core.types.DeclareFunction>;
                    isDeclareInterface(props?: object | null): this is NodePath<core.types.DeclareInterface>;
                    isDeclareModule(props?: object | null): this is NodePath<core.types.DeclareModule>;
                    isDeclareModuleExports(props?: object | null): this is NodePath<core.types.DeclareModuleExports>;
                    isDeclareOpaqueType(props?: object | null): this is NodePath<core.types.DeclareOpaqueType>;
                    isDeclareTypeAlias(props?: object | null): this is NodePath<core.types.DeclareTypeAlias>;
                    isDeclareVariable(props?: object | null): this is NodePath<core.types.DeclareVariable>;
                    isDeclaredPredicate(props?: object | null): this is NodePath<core.types.DeclaredPredicate>;
                    isDecorator(props?: object | null): this is NodePath<core.types.Decorator>;
                    isDirective(props?: object | null): this is NodePath<core.types.Directive>;
                    isDirectiveLiteral(props?: object | null): this is NodePath<core.types.DirectiveLiteral>;
                    isDoExpression(props?: object | null): this is NodePath<core.types.DoExpression>;
                    isDoWhileStatement(props?: object | null): this is NodePath<core.types.DoWhileStatement>;
                    isEmptyStatement(props?: object | null): this is NodePath<core.types.EmptyStatement>;
                    isEmptyTypeAnnotation(props?: object | null): this is NodePath<core.types.EmptyTypeAnnotation>;
                    isExistsTypeAnnotation(props?: object | null): this is NodePath<core.types.ExistsTypeAnnotation>;
                    isExportAllDeclaration(props?: object | null): this is NodePath<core.types.ExportAllDeclaration>;
                    isExportDeclaration(props?: object | null): this is NodePath<core.types.ExportDeclaration>;
                    isExportDefaultDeclaration(props?: object | null): this is NodePath<core.types.ExportDefaultDeclaration>;
                    isExportDefaultSpecifier(props?: object | null): this is NodePath<core.types.ExportDefaultSpecifier>;
                    isExportNamedDeclaration(props?: object | null): this is NodePath<core.types.ExportNamedDeclaration>;
                    isExportNamespaceSpecifier(props?: object | null): this is NodePath<core.types.ExportNamespaceSpecifier>;
                    isExportSpecifier(props?: object | null): this is NodePath<core.types.ExportSpecifier>;
                    isExpression(props?: object | null): this is NodePath<core.types.Expression>;
                    isExpressionStatement(props?: object | null): this is NodePath<core.types.ExpressionStatement>;
                    isExpressionWrapper(props?: object | null): this is NodePath<core.types.ExpressionWrapper>;
                    isFile(props?: object | null): this is NodePath<core.types.File>;
                    isFlow(props?: object | null): this is NodePath<core.types.Flow>;
                    isFlowBaseAnnotation(props?: object | null): this is NodePath<core.types.FlowBaseAnnotation>;
                    isFlowDeclaration(props?: object | null): this is NodePath<core.types.FlowDeclaration>;
                    isFlowPredicate(props?: object | null): this is NodePath<core.types.FlowPredicate>;
                    isFlowType(props?: object | null): this is NodePath<core.types.FlowType>;
                    isFor(props?: object | null): this is NodePath<core.types.For>;
                    isForInStatement(props?: object | null): this is NodePath<core.types.ForInStatement>;
                    isForOfStatement(props?: object | null): this is NodePath<core.types.ForOfStatement>;
                    isForStatement(props?: object | null): this is NodePath<core.types.ForStatement>;
                    isForXStatement(props?: object | null): this is NodePath<core.types.ForXStatement>;
                    isFunction(props?: object | null): this is NodePath<core.types.Function>;
                    isFunctionDeclaration(props?: object | null): this is NodePath<core.types.FunctionDeclaration>;
                    isFunctionExpression(props?: object | null): this is NodePath<core.types.FunctionExpression>;
                    isFunctionParent(props?: object | null): this is NodePath<core.types.FunctionParent>;
                    isFunctionTypeAnnotation(props?: object | null): this is NodePath<core.types.FunctionTypeAnnotation>;
                    isFunctionTypeParam(props?: object | null): this is NodePath<core.types.FunctionTypeParam>;
                    isGenericTypeAnnotation(props?: object | null): this is NodePath<core.types.GenericTypeAnnotation>;
                    isIdentifier(props?: object | null): this is NodePath<core.types.Identifier>;
                    isIfStatement(props?: object | null): this is NodePath<core.types.IfStatement>;
                    isImmutable(props?: object | null): this is NodePath<core.types.Immutable>;
                    isImport(props?: object | null): this is NodePath<core.types.Import>;
                    isImportDeclaration(props?: object | null): this is NodePath<core.types.ImportDeclaration>;
                    isImportDefaultSpecifier(props?: object | null): this is NodePath<core.types.ImportDefaultSpecifier>;
                    isImportNamespaceSpecifier(props?: object | null): this is NodePath<core.types.ImportNamespaceSpecifier>;
                    isImportSpecifier(props?: object | null): this is NodePath<core.types.ImportSpecifier>;
                    isInferredPredicate(props?: object | null): this is NodePath<core.types.InferredPredicate>;
                    isInterfaceDeclaration(props?: object | null): this is NodePath<core.types.InterfaceDeclaration>;
                    isInterfaceExtends(props?: object | null): this is NodePath<core.types.InterfaceExtends>;
                    isInterfaceTypeAnnotation(props?: object | null): this is NodePath<core.types.InterfaceTypeAnnotation>;
                    isInterpreterDirective(props?: object | null): this is NodePath<core.types.InterpreterDirective>;
                    isIntersectionTypeAnnotation(props?: object | null): this is NodePath<core.types.IntersectionTypeAnnotation>;
                    isJSX(props?: object | null): this is NodePath<core.types.JSX>;
                    isJSXAttribute(props?: object | null): this is NodePath<core.types.JSXAttribute>;
                    isJSXClosingElement(props?: object | null): this is NodePath<core.types.JSXClosingElement>;
                    isJSXClosingFragment(props?: object | null): this is NodePath<core.types.JSXClosingFragment>;
                    isJSXElement(props?: object | null): this is NodePath<core.types.JSXElement>;
                    isJSXEmptyExpression(props?: object | null): this is NodePath<core.types.JSXEmptyExpression>;
                    isJSXExpressionContainer(props?: object | null): this is NodePath<core.types.JSXExpressionContainer>;
                    isJSXFragment(props?: object | null): this is NodePath<core.types.JSXFragment>;
                    isJSXIdentifier(props?: object | null): this is NodePath<core.types.JSXIdentifier>;
                    isJSXMemberExpression(props?: object | null): this is NodePath<core.types.JSXMemberExpression>;
                    isJSXNamespacedName(props?: object | null): this is NodePath<core.types.JSXNamespacedName>;
                    isJSXOpeningElement(props?: object | null): this is NodePath<core.types.JSXOpeningElement>;
                    isJSXOpeningFragment(props?: object | null): this is NodePath<core.types.JSXOpeningFragment>;
                    isJSXSpreadAttribute(props?: object | null): this is NodePath<core.types.JSXSpreadAttribute>;
                    isJSXSpreadChild(props?: object | null): this is NodePath<core.types.JSXSpreadChild>;
                    isJSXText(props?: object | null): this is NodePath<core.types.JSXText>;
                    isLVal(props?: object | null): this is NodePath<core.types.LVal>;
                    isLabeledStatement(props?: object | null): this is NodePath<core.types.LabeledStatement>;
                    isLiteral(props?: object | null): this is NodePath<core.types.Literal>;
                    isLogicalExpression(props?: object | null): this is NodePath<core.types.LogicalExpression>;
                    isLoop(props?: object | null): this is NodePath<core.types.Loop>;
                    isMemberExpression(props?: object | null): this is NodePath<core.types.MemberExpression>;
                    isMetaProperty(props?: object | null): this is NodePath<core.types.MetaProperty>;
                    isMethod(props?: object | null): this is NodePath<core.types.Method>;
                    isMixedTypeAnnotation(props?: object | null): this is NodePath<core.types.MixedTypeAnnotation>;
                    isModuleDeclaration(props?: object | null): this is NodePath<core.types.ModuleDeclaration>;
                    isModuleSpecifier(props?: object | null): this is NodePath<core.types.ModuleSpecifier>;
                    isNewExpression(props?: object | null): this is NodePath<core.types.NewExpression>;
                    isNoop(props?: object | null): this is NodePath<core.types.Noop>;
                    isNullLiteral(props?: object | null): this is NodePath<core.types.NullLiteral>;
                    isNullLiteralTypeAnnotation(props?: object | null): this is NodePath<core.types.NullLiteralTypeAnnotation>;
                    isNullableTypeAnnotation(props?: object | null): this is NodePath<core.types.NullableTypeAnnotation>;
                    /** @deprecated Use `isNumericLiteral` */
                    isNumberLiteral(props?: object | null): this is NodePath<core.types.NumericLiteral>;
                    isNumberLiteralTypeAnnotation(props?: object | null): this is NodePath<core.types.NumberLiteralTypeAnnotation>;
                    isNumberTypeAnnotation(props?: object | null): this is NodePath<core.types.NumberTypeAnnotation>;
                    isNumericLiteral(props?: object | null): this is NodePath<core.types.NumericLiteral>;
                    isObjectExpression(props?: object | null): this is NodePath<core.types.ObjectExpression>;
                    isObjectMember(props?: object | null): this is NodePath<core.types.ObjectMember>;
                    isObjectMethod(props?: object | null): this is NodePath<core.types.ObjectMethod>;
                    isObjectPattern(props?: object | null): this is NodePath<core.types.ObjectPattern>;
                    isObjectProperty(props?: object | null): this is NodePath<core.types.ObjectProperty>;
                    isObjectTypeAnnotation(props?: object | null): this is NodePath<core.types.ObjectTypeAnnotation>;
                    isObjectTypeCallProperty(props?: object | null): this is NodePath<core.types.ObjectTypeCallProperty>;
                    isObjectTypeIndexer(props?: object | null): this is NodePath<core.types.ObjectTypeIndexer>;
                    isObjectTypeInternalSlot(props?: object | null): this is NodePath<core.types.ObjectTypeInternalSlot>;
                    isObjectTypeProperty(props?: object | null): this is NodePath<core.types.ObjectTypeProperty>;
                    isObjectTypeSpreadProperty(props?: object | null): this is NodePath<core.types.ObjectTypeSpreadProperty>;
                    isOpaqueType(props?: object | null): this is NodePath<core.types.OpaqueType>;
                    isOptionalCallExpression(props?: object | null): this is NodePath<core.types.OptionalCallExpression>;
                    isOptionalMemberExpression(props?: object | null): this is NodePath<core.types.OptionalMemberExpression>;
                    isParenthesizedExpression(props?: object | null): this is NodePath<core.types.ParenthesizedExpression>;
                    isPattern(props?: object | null): this is NodePath<core.types.Pattern>;
                    isPatternLike(props?: object | null): this is NodePath<core.types.PatternLike>;
                    isPipelineBareFunction(props?: object | null): this is NodePath<core.types.PipelineBareFunction>;
                    isPipelinePrimaryTopicReference(props?: object | null): this is NodePath<core.types.PipelinePrimaryTopicReference>;
                    isPipelineTopicExpression(props?: object | null): this is NodePath<core.types.PipelineTopicExpression>;
                    isPrivate(props?: object | null): this is NodePath<core.types.Private>;
                    isPrivateName(props?: object | null): this is NodePath<core.types.PrivateName>;
                    isProgram(props?: object | null): this is NodePath<core.types.Program>;
                    isProperty(props?: object | null): this is NodePath<core.types.Property>;
                    isPureish(props?: object | null): this is NodePath<core.types.Pureish>;
                    isQualifiedTypeIdentifier(props?: object | null): this is NodePath<core.types.QualifiedTypeIdentifier>;
                    isRegExpLiteral(props?: object | null): this is NodePath<core.types.RegExpLiteral>;
                    /** @deprecated Use `isRegExpLiteral` */
                    isRegexLiteral(props?: object | null): this is NodePath<core.types.RegExpLiteral>;
                    isRestElement(props?: object | null): this is NodePath<core.types.RestElement>;
                    /** @deprecated Use `isRestElement` */
                    isRestProperty(props?: object | null): this is NodePath<core.types.RestElement>;
                    isReturnStatement(props?: object | null): this is NodePath<core.types.ReturnStatement>;
                    isScopable(props?: object | null): this is NodePath<core.types.Scopable>;
                    isSequenceExpression(props?: object | null): this is NodePath<core.types.SequenceExpression>;
                    isSpreadElement(props?: object | null): this is NodePath<core.types.SpreadElement>;
                    /** @deprecated Use `isSpreadElement` */
                    isSpreadProperty(props?: object | null): this is NodePath<core.types.SpreadElement>;
                    isStatement(props?: object | null): this is NodePath<core.types.Statement>;
                    isStringLiteral(props?: object | null): this is NodePath<core.types.StringLiteral>;
                    isStringLiteralTypeAnnotation(props?: object | null): this is NodePath<core.types.StringLiteralTypeAnnotation>;
                    isStringTypeAnnotation(props?: object | null): this is NodePath<core.types.StringTypeAnnotation>;
                    isSuper(props?: object | null): this is NodePath<core.types.Super>;
                    isSwitchCase(props?: object | null): this is NodePath<core.types.SwitchCase>;
                    isSwitchStatement(props?: object | null): this is NodePath<core.types.SwitchStatement>;
                    isTSAnyKeyword(props?: object | null): this is NodePath<core.types.TSAnyKeyword>;
                    isTSArrayType(props?: object | null): this is NodePath<core.types.TSArrayType>;
                    isTSAsExpression(props?: object | null): this is NodePath<core.types.TSAsExpression>;
                    isTSBooleanKeyword(props?: object | null): this is NodePath<core.types.TSBooleanKeyword>;
                    isTSCallSignatureDeclaration(props?: object | null): this is NodePath<core.types.TSCallSignatureDeclaration>;
                    isTSConditionalType(props?: object | null): this is NodePath<core.types.TSConditionalType>;
                    isTSConstructSignatureDeclaration(props?: object | null): this is NodePath<core.types.TSConstructSignatureDeclaration>;
                    isTSConstructorType(props?: object | null): this is NodePath<core.types.TSConstructorType>;
                    isTSDeclareFunction(props?: object | null): this is NodePath<core.types.TSDeclareFunction>;
                    isTSDeclareMethod(props?: object | null): this is NodePath<core.types.TSDeclareMethod>;
                    isTSEntityName(props?: object | null): this is NodePath<core.types.TSEntityName>;
                    isTSEnumDeclaration(props?: object | null): this is NodePath<core.types.TSEnumDeclaration>;
                    isTSEnumMember(props?: object | null): this is NodePath<core.types.TSEnumMember>;
                    isTSExportAssignment(props?: object | null): this is NodePath<core.types.TSExportAssignment>;
                    isTSExpressionWithTypeArguments(props?: object | null): this is NodePath<core.types.TSExpressionWithTypeArguments>;
                    isTSExternalModuleReference(props?: object | null): this is NodePath<core.types.TSExternalModuleReference>;
                    isTSFunctionType(props?: object | null): this is NodePath<core.types.TSFunctionType>;
                    isTSImportEqualsDeclaration(props?: object | null): this is NodePath<core.types.TSImportEqualsDeclaration>;
                    isTSImportType(props?: object | null): this is NodePath<core.types.TSImportType>;
                    isTSIndexSignature(props?: object | null): this is NodePath<core.types.TSIndexSignature>;
                    isTSIndexedAccessType(props?: object | null): this is NodePath<core.types.TSIndexedAccessType>;
                    isTSInferType(props?: object | null): this is NodePath<core.types.TSInferType>;
                    isTSInterfaceBody(props?: object | null): this is NodePath<core.types.TSInterfaceBody>;
                    isTSInterfaceDeclaration(props?: object | null): this is NodePath<core.types.TSInterfaceDeclaration>;
                    isTSIntersectionType(props?: object | null): this is NodePath<core.types.TSIntersectionType>;
                    isTSLiteralType(props?: object | null): this is NodePath<core.types.TSLiteralType>;
                    isTSMappedType(props?: object | null): this is NodePath<core.types.TSMappedType>;
                    isTSMethodSignature(props?: object | null): this is NodePath<core.types.TSMethodSignature>;
                    isTSModuleBlock(props?: object | null): this is NodePath<core.types.TSModuleBlock>;
                    isTSModuleDeclaration(props?: object | null): this is NodePath<core.types.TSModuleDeclaration>;
                    isTSNamespaceExportDeclaration(props?: object | null): this is NodePath<core.types.TSNamespaceExportDeclaration>;
                    isTSNeverKeyword(props?: object | null): this is NodePath<core.types.TSNeverKeyword>;
                    isTSNonNullExpression(props?: object | null): this is NodePath<core.types.TSNonNullExpression>;
                    isTSNullKeyword(props?: object | null): this is NodePath<core.types.TSNullKeyword>;
                    isTSNumberKeyword(props?: object | null): this is NodePath<core.types.TSNumberKeyword>;
                    isTSObjectKeyword(props?: object | null): this is NodePath<core.types.TSObjectKeyword>;
                    isTSOptionalType(props?: object | null): this is NodePath<core.types.TSOptionalType>;
                    isTSParameterProperty(props?: object | null): this is NodePath<core.types.TSParameterProperty>;
                    isTSParenthesizedType(props?: object | null): this is NodePath<core.types.TSParenthesizedType>;
                    isTSPropertySignature(props?: object | null): this is NodePath<core.types.TSPropertySignature>;
                    isTSQualifiedName(props?: object | null): this is NodePath<core.types.TSQualifiedName>;
                    isTSRestType(props?: object | null): this is NodePath<core.types.TSRestType>;
                    isTSStringKeyword(props?: object | null): this is NodePath<core.types.TSStringKeyword>;
                    isTSSymbolKeyword(props?: object | null): this is NodePath<core.types.TSSymbolKeyword>;
                    isTSThisType(props?: object | null): this is NodePath<core.types.TSThisType>;
                    isTSTupleType(props?: object | null): this is NodePath<core.types.TSTupleType>;
                    isTSType(props?: object | null): this is NodePath<core.types.TSType>;
                    isTSTypeAliasDeclaration(props?: object | null): this is NodePath<core.types.TSTypeAliasDeclaration>;
                    isTSTypeAnnotation(props?: object | null): this is NodePath<core.types.TSTypeAnnotation>;
                    isTSTypeAssertion(props?: object | null): this is NodePath<core.types.TSTypeAssertion>;
                    isTSTypeElement(props?: object | null): this is NodePath<core.types.TSTypeElement>;
                    isTSTypeLiteral(props?: object | null): this is NodePath<core.types.TSTypeLiteral>;
                    isTSTypeOperator(props?: object | null): this is NodePath<core.types.TSTypeOperator>;
                    isTSTypeParameter(props?: object | null): this is NodePath<core.types.TSTypeParameter>;
                    isTSTypeParameterDeclaration(props?: object | null): this is NodePath<core.types.TSTypeParameterDeclaration>;
                    isTSTypeParameterInstantiation(props?: object | null): this is NodePath<core.types.TSTypeParameterInstantiation>;
                    isTSTypePredicate(props?: object | null): this is NodePath<core.types.TSTypePredicate>;
                    isTSTypeQuery(props?: object | null): this is NodePath<core.types.TSTypeQuery>;
                    isTSTypeReference(props?: object | null): this is NodePath<core.types.TSTypeReference>;
                    isTSUndefinedKeyword(props?: object | null): this is NodePath<core.types.TSUndefinedKeyword>;
                    isTSUnionType(props?: object | null): this is NodePath<core.types.TSUnionType>;
                    isTSUnknownKeyword(props?: object | null): this is NodePath<core.types.TSUnknownKeyword>;
                    isTSVoidKeyword(props?: object | null): this is NodePath<core.types.TSVoidKeyword>;
                    isTaggedTemplateExpression(props?: object | null): this is NodePath<core.types.TaggedTemplateExpression>;
                    isTemplateElement(props?: object | null): this is NodePath<core.types.TemplateElement>;
                    isTemplateLiteral(props?: object | null): this is NodePath<core.types.TemplateLiteral>;
                    isTerminatorless(props?: object | null): this is NodePath<core.types.Terminatorless>;
                    isThisExpression(props?: object | null): this is NodePath<core.types.ThisExpression>;
                    isThisTypeAnnotation(props?: object | null): this is NodePath<core.types.ThisTypeAnnotation>;
                    isThrowStatement(props?: object | null): this is NodePath<core.types.ThrowStatement>;
                    isTryStatement(props?: object | null): this is NodePath<core.types.TryStatement>;
                    isTupleTypeAnnotation(props?: object | null): this is NodePath<core.types.TupleTypeAnnotation>;
                    isTypeAlias(props?: object | null): this is NodePath<core.types.TypeAlias>;
                    isTypeAnnotation(props?: object | null): this is NodePath<core.types.TypeAnnotation>;
                    isTypeCastExpression(props?: object | null): this is NodePath<core.types.TypeCastExpression>;
                    isTypeParameter(props?: object | null): this is NodePath<core.types.TypeParameter>;
                    isTypeParameterDeclaration(props?: object | null): this is NodePath<core.types.TypeParameterDeclaration>;
                    isTypeParameterInstantiation(props?: object | null): this is NodePath<core.types.TypeParameterInstantiation>;
                    isTypeofTypeAnnotation(props?: object | null): this is NodePath<core.types.TypeofTypeAnnotation>;
                    isUnaryExpression(props?: object | null): this is NodePath<core.types.UnaryExpression>;
                    isUnaryLike(props?: object | null): this is NodePath<core.types.UnaryLike>;
                    isUnionTypeAnnotation(props?: object | null): this is NodePath<core.types.UnionTypeAnnotation>;
                    isUpdateExpression(props?: object | null): this is NodePath<core.types.UpdateExpression>;
                    isUserWhitespacable(props?: object | null): this is NodePath<core.types.UserWhitespacable>;
                    isVariableDeclaration(props?: object | null): this is NodePath<core.types.VariableDeclaration>;
                    isVariableDeclarator(props?: object | null): this is NodePath<core.types.VariableDeclarator>;
                    isVariance(props?: object | null): this is NodePath<core.types.Variance>;
                    isVoidTypeAnnotation(props?: object | null): this is NodePath<core.types.VoidTypeAnnotation>;
                    isWhile(props?: object | null): this is NodePath<core.types.While>;
                    isWhileStatement(props?: object | null): this is NodePath<core.types.WhileStatement>;
                    isWithStatement(props?: object | null): this is NodePath<core.types.WithStatement>;
                    isYieldExpression(props?: object | null): this is NodePath<core.types.YieldExpression>;
                    isBindingIdentifier(props?: object | null): this is NodePath<core.types.Identifier>;
                    isBlockScoped(props?: object | null): this is NodePath<core.types.FunctionDeclaration | core.types.ClassDeclaration | core.types.VariableDeclaration>;
                    isGenerated(props?: object | null): boolean;
                    isPure(props?: object | null): boolean;
                    isReferenced(props?: object | null): boolean;
                    isReferencedIdentifier(props?: object | null): this is NodePath<core.types.Identifier | core.types.JSXIdentifier>;
                    isReferencedMemberExpression(props?: object | null): this is NodePath<core.types.MemberExpression>;
                    isScope(props?: object | null): this is NodePath<core.types.Scopable>;
                    isUser(props?: object | null): boolean;
                    isVar(props?: object | null): this is NodePath<core.types.VariableDeclaration>;
                    //#endregion
                    //#region ------------------------- assertXXX -------------------------
                    assertAnyTypeAnnotation(props?: object | null): void;
                    assertArrayExpression(props?: object | null): void;
                    assertArrayPattern(props?: object | null): void;
                    assertArrayTypeAnnotation(props?: object | null): void;
                    assertArrowFunctionExpression(props?: object | null): void;
                    assertAssignmentExpression(props?: object | null): void;
                    assertAssignmentPattern(props?: object | null): void;
                    assertAwaitExpression(props?: object | null): void;
                    assertBigIntLiteral(props?: object | null): void;
                    assertBinary(props?: object | null): void;
                    assertBinaryExpression(props?: object | null): void;
                    assertBindExpression(props?: object | null): void;
                    assertBlock(props?: object | null): void;
                    assertBlockParent(props?: object | null): void;
                    assertBlockStatement(props?: object | null): void;
                    assertBooleanLiteral(props?: object | null): void;
                    assertBooleanLiteralTypeAnnotation(props?: object | null): void;
                    assertBooleanTypeAnnotation(props?: object | null): void;
                    assertBreakStatement(props?: object | null): void;
                    assertCallExpression(props?: object | null): void;
                    assertCatchClause(props?: object | null): void;
                    assertClass(props?: object | null): void;
                    assertClassBody(props?: object | null): void;
                    assertClassDeclaration(props?: object | null): void;
                    assertClassExpression(props?: object | null): void;
                    assertClassImplements(props?: object | null): void;
                    assertClassMethod(props?: object | null): void;
                    assertClassPrivateMethod(props?: object | null): void;
                    assertClassPrivateProperty(props?: object | null): void;
                    assertClassProperty(props?: object | null): void;
                    assertCompletionStatement(props?: object | null): void;
                    assertConditional(props?: object | null): void;
                    assertConditionalExpression(props?: object | null): void;
                    assertContinueStatement(props?: object | null): void;
                    assertDebuggerStatement(props?: object | null): void;
                    assertDeclaration(props?: object | null): void;
                    assertDeclareClass(props?: object | null): void;
                    assertDeclareExportAllDeclaration(props?: object | null): void;
                    assertDeclareExportDeclaration(props?: object | null): void;
                    assertDeclareFunction(props?: object | null): void;
                    assertDeclareInterface(props?: object | null): void;
                    assertDeclareModule(props?: object | null): void;
                    assertDeclareModuleExports(props?: object | null): void;
                    assertDeclareOpaqueType(props?: object | null): void;
                    assertDeclareTypeAlias(props?: object | null): void;
                    assertDeclareVariable(props?: object | null): void;
                    assertDeclaredPredicate(props?: object | null): void;
                    assertDecorator(props?: object | null): void;
                    assertDirective(props?: object | null): void;
                    assertDirectiveLiteral(props?: object | null): void;
                    assertDoExpression(props?: object | null): void;
                    assertDoWhileStatement(props?: object | null): void;
                    assertEmptyStatement(props?: object | null): void;
                    assertEmptyTypeAnnotation(props?: object | null): void;
                    assertExistsTypeAnnotation(props?: object | null): void;
                    assertExportAllDeclaration(props?: object | null): void;
                    assertExportDeclaration(props?: object | null): void;
                    assertExportDefaultDeclaration(props?: object | null): void;
                    assertExportDefaultSpecifier(props?: object | null): void;
                    assertExportNamedDeclaration(props?: object | null): void;
                    assertExportNamespaceSpecifier(props?: object | null): void;
                    assertExportSpecifier(props?: object | null): void;
                    assertExpression(props?: object | null): void;
                    assertExpressionStatement(props?: object | null): void;
                    assertExpressionWrapper(props?: object | null): void;
                    assertFile(props?: object | null): void;
                    assertFlow(props?: object | null): void;
                    assertFlowBaseAnnotation(props?: object | null): void;
                    assertFlowDeclaration(props?: object | null): void;
                    assertFlowPredicate(props?: object | null): void;
                    assertFlowType(props?: object | null): void;
                    assertFor(props?: object | null): void;
                    assertForInStatement(props?: object | null): void;
                    assertForOfStatement(props?: object | null): void;
                    assertForStatement(props?: object | null): void;
                    assertForXStatement(props?: object | null): void;
                    assertFunction(props?: object | null): void;
                    assertFunctionDeclaration(props?: object | null): void;
                    assertFunctionExpression(props?: object | null): void;
                    assertFunctionParent(props?: object | null): void;
                    assertFunctionTypeAnnotation(props?: object | null): void;
                    assertFunctionTypeParam(props?: object | null): void;
                    assertGenericTypeAnnotation(props?: object | null): void;
                    assertIdentifier(props?: object | null): void;
                    assertIfStatement(props?: object | null): void;
                    assertImmutable(props?: object | null): void;
                    assertImport(props?: object | null): void;
                    assertImportDeclaration(props?: object | null): void;
                    assertImportDefaultSpecifier(props?: object | null): void;
                    assertImportNamespaceSpecifier(props?: object | null): void;
                    assertImportSpecifier(props?: object | null): void;
                    assertInferredPredicate(props?: object | null): void;
                    assertInterfaceDeclaration(props?: object | null): void;
                    assertInterfaceExtends(props?: object | null): void;
                    assertInterfaceTypeAnnotation(props?: object | null): void;
                    assertInterpreterDirective(props?: object | null): void;
                    assertIntersectionTypeAnnotation(props?: object | null): void;
                    assertJSX(props?: object | null): void;
                    assertJSXAttribute(props?: object | null): void;
                    assertJSXClosingElement(props?: object | null): void;
                    assertJSXClosingFragment(props?: object | null): void;
                    assertJSXElement(props?: object | null): void;
                    assertJSXEmptyExpression(props?: object | null): void;
                    assertJSXExpressionContainer(props?: object | null): void;
                    assertJSXFragment(props?: object | null): void;
                    assertJSXIdentifier(props?: object | null): void;
                    assertJSXMemberExpression(props?: object | null): void;
                    assertJSXNamespacedName(props?: object | null): void;
                    assertJSXOpeningElement(props?: object | null): void;
                    assertJSXOpeningFragment(props?: object | null): void;
                    assertJSXSpreadAttribute(props?: object | null): void;
                    assertJSXSpreadChild(props?: object | null): void;
                    assertJSXText(props?: object | null): void;
                    assertLVal(props?: object | null): void;
                    assertLabeledStatement(props?: object | null): void;
                    assertLiteral(props?: object | null): void;
                    assertLogicalExpression(props?: object | null): void;
                    assertLoop(props?: object | null): void;
                    assertMemberExpression(props?: object | null): void;
                    assertMetaProperty(props?: object | null): void;
                    assertMethod(props?: object | null): void;
                    assertMixedTypeAnnotation(props?: object | null): void;
                    assertModuleDeclaration(props?: object | null): void;
                    assertModuleSpecifier(props?: object | null): void;
                    assertNewExpression(props?: object | null): void;
                    assertNoop(props?: object | null): void;
                    assertNullLiteral(props?: object | null): void;
                    assertNullLiteralTypeAnnotation(props?: object | null): void;
                    assertNullableTypeAnnotation(props?: object | null): void;
                    /** @deprecated Use `assertNumericLiteral` */
                    assertNumberLiteral(props?: object | null): void;
                    assertNumberLiteralTypeAnnotation(props?: object | null): void;
                    assertNumberTypeAnnotation(props?: object | null): void;
                    assertNumericLiteral(props?: object | null): void;
                    assertObjectExpression(props?: object | null): void;
                    assertObjectMember(props?: object | null): void;
                    assertObjectMethod(props?: object | null): void;
                    assertObjectPattern(props?: object | null): void;
                    assertObjectProperty(props?: object | null): void;
                    assertObjectTypeAnnotation(props?: object | null): void;
                    assertObjectTypeCallProperty(props?: object | null): void;
                    assertObjectTypeIndexer(props?: object | null): void;
                    assertObjectTypeInternalSlot(props?: object | null): void;
                    assertObjectTypeProperty(props?: object | null): void;
                    assertObjectTypeSpreadProperty(props?: object | null): void;
                    assertOpaqueType(props?: object | null): void;
                    assertOptionalCallExpression(props?: object | null): void;
                    assertOptionalMemberExpression(props?: object | null): void;
                    assertParenthesizedExpression(props?: object | null): void;
                    assertPattern(props?: object | null): void;
                    assertPatternLike(props?: object | null): void;
                    assertPipelineBareFunction(props?: object | null): void;
                    assertPipelinePrimaryTopicReference(props?: object | null): void;
                    assertPipelineTopicExpression(props?: object | null): void;
                    assertPrivate(props?: object | null): void;
                    assertPrivateName(props?: object | null): void;
                    assertProgram(props?: object | null): void;
                    assertProperty(props?: object | null): void;
                    assertPureish(props?: object | null): void;
                    assertQualifiedTypeIdentifier(props?: object | null): void;
                    assertRegExpLiteral(props?: object | null): void;
                    /** @deprecated Use `assertRegExpLiteral` */
                    assertRegexLiteral(props?: object | null): void;
                    assertRestElement(props?: object | null): void;
                    /** @deprecated Use `assertRestElement` */
                    assertRestProperty(props?: object | null): void;
                    assertReturnStatement(props?: object | null): void;
                    assertScopable(props?: object | null): void;
                    assertSequenceExpression(props?: object | null): void;
                    assertSpreadElement(props?: object | null): void;
                    /** @deprecated Use `assertSpreadElement` */
                    assertSpreadProperty(props?: object | null): void;
                    assertStatement(props?: object | null): void;
                    assertStringLiteral(props?: object | null): void;
                    assertStringLiteralTypeAnnotation(props?: object | null): void;
                    assertStringTypeAnnotation(props?: object | null): void;
                    assertSuper(props?: object | null): void;
                    assertSwitchCase(props?: object | null): void;
                    assertSwitchStatement(props?: object | null): void;
                    assertTSAnyKeyword(props?: object | null): void;
                    assertTSArrayType(props?: object | null): void;
                    assertTSAsExpression(props?: object | null): void;
                    assertTSBooleanKeyword(props?: object | null): void;
                    assertTSCallSignatureDeclaration(props?: object | null): void;
                    assertTSConditionalType(props?: object | null): void;
                    assertTSConstructSignatureDeclaration(props?: object | null): void;
                    assertTSConstructorType(props?: object | null): void;
                    assertTSDeclareFunction(props?: object | null): void;
                    assertTSDeclareMethod(props?: object | null): void;
                    assertTSEntityName(props?: object | null): void;
                    assertTSEnumDeclaration(props?: object | null): void;
                    assertTSEnumMember(props?: object | null): void;
                    assertTSExportAssignment(props?: object | null): void;
                    assertTSExpressionWithTypeArguments(props?: object | null): void;
                    assertTSExternalModuleReference(props?: object | null): void;
                    assertTSFunctionType(props?: object | null): void;
                    assertTSImportEqualsDeclaration(props?: object | null): void;
                    assertTSImportType(props?: object | null): void;
                    assertTSIndexSignature(props?: object | null): void;
                    assertTSIndexedAccessType(props?: object | null): void;
                    assertTSInferType(props?: object | null): void;
                    assertTSInterfaceBody(props?: object | null): void;
                    assertTSInterfaceDeclaration(props?: object | null): void;
                    assertTSIntersectionType(props?: object | null): void;
                    assertTSLiteralType(props?: object | null): void;
                    assertTSMappedType(props?: object | null): void;
                    assertTSMethodSignature(props?: object | null): void;
                    assertTSModuleBlock(props?: object | null): void;
                    assertTSModuleDeclaration(props?: object | null): void;
                    assertTSNamespaceExportDeclaration(props?: object | null): void;
                    assertTSNeverKeyword(props?: object | null): void;
                    assertTSNonNullExpression(props?: object | null): void;
                    assertTSNullKeyword(props?: object | null): void;
                    assertTSNumberKeyword(props?: object | null): void;
                    assertTSObjectKeyword(props?: object | null): void;
                    assertTSOptionalType(props?: object | null): void;
                    assertTSParameterProperty(props?: object | null): void;
                    assertTSParenthesizedType(props?: object | null): void;
                    assertTSPropertySignature(props?: object | null): void;
                    assertTSQualifiedName(props?: object | null): void;
                    assertTSRestType(props?: object | null): void;
                    assertTSStringKeyword(props?: object | null): void;
                    assertTSSymbolKeyword(props?: object | null): void;
                    assertTSThisType(props?: object | null): void;
                    assertTSTupleType(props?: object | null): void;
                    assertTSType(props?: object | null): void;
                    assertTSTypeAliasDeclaration(props?: object | null): void;
                    assertTSTypeAnnotation(props?: object | null): void;
                    assertTSTypeAssertion(props?: object | null): void;
                    assertTSTypeElement(props?: object | null): void;
                    assertTSTypeLiteral(props?: object | null): void;
                    assertTSTypeOperator(props?: object | null): void;
                    assertTSTypeParameter(props?: object | null): void;
                    assertTSTypeParameterDeclaration(props?: object | null): void;
                    assertTSTypeParameterInstantiation(props?: object | null): void;
                    assertTSTypePredicate(props?: object | null): void;
                    assertTSTypeQuery(props?: object | null): void;
                    assertTSTypeReference(props?: object | null): void;
                    assertTSUndefinedKeyword(props?: object | null): void;
                    assertTSUnionType(props?: object | null): void;
                    assertTSUnknownKeyword(props?: object | null): void;
                    assertTSVoidKeyword(props?: object | null): void;
                    assertTaggedTemplateExpression(props?: object | null): void;
                    assertTemplateElement(props?: object | null): void;
                    assertTemplateLiteral(props?: object | null): void;
                    assertTerminatorless(props?: object | null): void;
                    assertThisExpression(props?: object | null): void;
                    assertThisTypeAnnotation(props?: object | null): void;
                    assertThrowStatement(props?: object | null): void;
                    assertTryStatement(props?: object | null): void;
                    assertTupleTypeAnnotation(props?: object | null): void;
                    assertTypeAlias(props?: object | null): void;
                    assertTypeAnnotation(props?: object | null): void;
                    assertTypeCastExpression(props?: object | null): void;
                    assertTypeParameter(props?: object | null): void;
                    assertTypeParameterDeclaration(props?: object | null): void;
                    assertTypeParameterInstantiation(props?: object | null): void;
                    assertTypeofTypeAnnotation(props?: object | null): void;
                    assertUnaryExpression(props?: object | null): void;
                    assertUnaryLike(props?: object | null): void;
                    assertUnionTypeAnnotation(props?: object | null): void;
                    assertUpdateExpression(props?: object | null): void;
                    assertUserWhitespacable(props?: object | null): void;
                    assertVariableDeclaration(props?: object | null): void;
                    assertVariableDeclarator(props?: object | null): void;
                    assertVariance(props?: object | null): void;
                    assertVoidTypeAnnotation(props?: object | null): void;
                    assertWhile(props?: object | null): void;
                    assertWhileStatement(props?: object | null): void;
                    assertWithStatement(props?: object | null): void;
                    assertYieldExpression(props?: object | null): void;
                    assertBindingIdentifier(props?: object | null): void;
                    assertBlockScoped(props?: object | null): void;
                    assertGenerated(props?: object | null): void;
                    assertPure(props?: object | null): void;
                    assertReferenced(props?: object | null): void;
                    assertReferencedIdentifier(props?: object | null): void;
                    assertReferencedMemberExpression(props?: object | null): void;
                    assertScope(props?: object | null): void;
                    assertUser(props?: object | null): void;
                    assertVar(props?: object | null): void;
                }
                export type Visitor<S = {}> = VisitNodeObject<S, core.types.Node> & {
                    [Type in core.types.Node["type"]]?: VisitNode<S, Extract<core.types.Node, {
                        type: Type;
                    }>>;
                } & {
                    [K in keyof core.types.Aliases]?: VisitNode<S, core.types.Aliases[K]>;
                };
                export namespace visitors {
                    /**
                     * `explode()` will take a `Visitor` object with all of the various shorthands
                     * that we support, and validates & normalizes it into a common format, ready
                     * to be used in traversal.
                     *
                     * The various shorthands are:
                     * - `Identifier() { ... }` -> `Identifier: { enter() { ... } }`
                     * - `"Identifier|NumericLiteral": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`
                     * - Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`
                     *
                     * Other normalizations are:
                     * - Visitors of virtual types are wrapped, so that they are only visited when their dynamic check passes
                     * - `enter` and `exit` functions are wrapped in arrays, to ease merging of visitors
                     */
                    function explode<S = {}>(visitor: Visitor<S>): {
                        [Type in core.types.Node["type"]]?: VisitNodeObject<S, Extract<core.types.Node, {
                            type: Type;
                        }>>;
                    };
                    function verify(visitor: Visitor): void;
                    function merge<S = {}>(visitors: Array<Visitor<S>>, states?: S[]): Visitor<unknown>;
                }
                export interface TraverseOptions<S = core.types.Node> extends Visitor<S> {
                    scope?: Scope | undefined;
                    noScope?: boolean | undefined;
                }
                export type ArrayKeys<T> = keyof {
                    [P in keyof T as T[P] extends any[] ? P : never]: P;
                };
                export class Scope {
                    constructor(path: NodePath, parentScope?: Scope);
                    path: NodePath;
                    block: core.types.Node;
                    parentBlock: core.types.Node;
                    parent: Scope;
                    hub: HubInterface;
                    bindings: {
                        [name: string]: Binding;
                    };
                    /** Traverse node with current scope and path. */
                    traverse<S>(node: core.types.Node | core.types.Node[], opts: TraverseOptions<S>, state: S): void;
                    traverse(node: core.types.Node | core.types.Node[], opts?: TraverseOptions, state?: any): void;
                    /** Generate a unique identifier and add it to the current scope. */
                    generateDeclaredUidIdentifier(name?: string): core.types.Identifier;
                    /** Generate a unique identifier. */
                    generateUidIdentifier(name?: string): core.types.Identifier;
                    /** Generate a unique `_id1` binding. */
                    generateUid(name?: string): string;
                    /** Generate a unique identifier based on a node. */
                    generateUidIdentifierBasedOnNode(parent: core.types.Node, defaultName?: string): core.types.Identifier;
                    /**
                     * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
                     * evaluating it wont result in potentially arbitrary code from being ran. The following are
                     * whitelisted and determined not to cause side effects:
                     *
                     *  - `this` expressions
                     *  - `super` expressions
                     *  - Bound identifiers
                     */
                    isStatic(node: core.types.Node): boolean;
                    /** Possibly generate a memoised identifier if it is not static and has consequences. */
                    maybeGenerateMemoised(node: core.types.Node, dontPush?: boolean): core.types.Identifier;
                    checkBlockScopedCollisions(local: Binding, kind: BindingKind, name: string, id: object): void;
                    rename(oldName: string, newName?: string, block?: core.types.Node): void;
                    dump(): void;
                    toArray(node: core.types.Node, i?: number): core.types.Node;
                    registerDeclaration(path: NodePath): void;
                    buildUndefinedNode(): core.types.Node;
                    registerConstantViolation(path: NodePath): void;
                    registerBinding(kind: string, path: NodePath, bindingPath?: NodePath): void;
                    addGlobal(node: core.types.Node): void;
                    hasUid(name: string): boolean;
                    hasGlobal(name: string): boolean;
                    hasReference(name: string): boolean;
                    isPure(node: core.types.Node, constantsOnly?: boolean): boolean;
                    setData(key: string, val: any): any;
                    getData(key: string): any;
                    removeData(key: string): void;
                    crawl(): void;
                    push(opts: {
                        id: core.types.LVal;
                        init?: core.types.Expression | undefined;
                        unique?: boolean | undefined;
                        kind?: "var" | "let" | "const" | undefined;
                    }): void;
                    getProgramParent(): Scope;
                    getFunctionParent(): Scope | null;
                    getBlockParent(): Scope;
                    /** Walks the scope tree and gathers **all** bindings. */
                    getAllBindings(...kinds: string[]): object;
                    bindingIdentifierEquals(name: string, node: core.types.Node): boolean;
                    getBinding(name: string): Binding | undefined;
                    getOwnBinding(name: string): Binding | undefined;
                    getBindingIdentifier(name: string): core.types.Identifier;
                    getOwnBindingIdentifier(name: string): core.types.Identifier;
                    hasOwnBinding(name: string): boolean;
                    hasBinding(name: string, noGlobals?: boolean): boolean;
                    parentHasBinding(name: string, noGlobals?: boolean): boolean;
                    /** Move a binding of `name` to another `scope`. */
                    moveBindingTo(name: string, scope: Scope): void;
                    removeOwnBinding(name: string): void;
                    removeBinding(name: string): void;
                }
                export type BindingKind = "var" | "let" | "const" | "module" | "hoisted" | "param" | "local" | "unknown";
                export class Binding {
                    constructor(opts: {
                        identifier: core.types.Identifier;
                        scope: Scope;
                        path: NodePath;
                        kind: BindingKind;
                    });
                    identifier: core.types.Identifier;
                    scope: Scope;
                    path: NodePath;
                    kind: BindingKind;
                    referenced: boolean;
                    references: number;
                    referencePaths: NodePath[];
                    constant: boolean;
                    constantViolations: NodePath[];
                    hasDeoptedValue?: boolean;
                    hasValue?: boolean;
                    value?: any;
                    deopValue(): void;
                    setValue(value: any): void;
                    clearValue(): void;
                    reassign(path: NodePath): void;
                    reference(path: NodePath): void;
                    dereference(): void;
                }
                export type VisitNode<S, P extends core.types.Node> = VisitNodeFunction<S, P> | VisitNodeObject<S, P>;
                export type VisitNodeFunction<S, P extends core.types.Node> = (this: S, path: NodePath<P>, state: S) => void;
                export interface VisitNodeObject<S, P extends core.types.Node> {
                    enter?: VisitNodeFunction<S, P> | undefined;
                    exit?: VisitNodeFunction<S, P> | undefined;
                    denylist?: NodeType[] | undefined;
                    /**
                     * @deprecated will be removed in Babel 8
                     */
                    blacklist?: NodeType[] | undefined;
                }
                export type NodePaths<T extends core.types.Node | readonly core.types.Node[]> = T extends readonly core.types.Node[] ? {
                    -readonly [K in keyof T]: NodePath<Extract<T[K], core.types.Node>>;
                } : T extends core.types.Node ? [
                    NodePath<T>
                ] : never;
                export interface HubInterface {
                    getCode(): string | undefined;
                    getScope(): Scope | undefined;
                    addHelper(name: string): any;
                    buildError<E extends Error>(node: core.types.Node, msg: string, Error: new (message?: string) => E): E;
                }
                export class Hub implements HubInterface {
                    constructor();
                    getCode(): string | undefined;
                    getScope(): Scope | undefined;
                    addHelper(name: string): any;
                    buildError<E extends Error>(node: core.types.Node, msg: string, Constructor: new (message?: string) => E): E;
                }
                export interface TraversalContext {
                    parentPath: NodePath;
                    scope: Scope;
                    state: any;
                    opts: any;
                }
                export type NodePathResult<T> = (Extract<T, core.types.Node | null | undefined> extends never ? never : NodePath<Extract<T, core.types.Node | null | undefined>>) | (T extends Array<core.types.Node | null | undefined> ? Array<NodePath<T[number]>> : never);
                export import Node = core.types.Node;
                export import default = core.traverse;
            }
            export namespace presets {
                export namespace presetEnv {
                    // Type definitions for @babel/preset-env 7.9
                    // Project: https://github.com/babel/babel/tree/master/packages/babel-preset-env, https://babeljs.io/docs/en/babel-preset-env
                    // Definitions by: Slava Fomin II <https://github.com/slavafomin>
                    // Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
                    export interface Options {
                        targets?: TargetsOptions | undefined;
                        bugfixes?: boolean | undefined;
                        spec?: boolean | undefined;
                        loose?: boolean | undefined;
                        modules?: ModuleOption | undefined;
                        debug?: boolean | undefined;
                        include?: PluginList | undefined;
                        exclude?: PluginList | undefined;
                        useBuiltIns?: UseBuiltInsOption | undefined;
                        corejs?: CorejsOption | undefined;
                        forceAllTransforms?: boolean | undefined;
                        configPath?: string | undefined;
                        ignoreBrowserslistConfig?: boolean | undefined;
                        shippedProposals?: boolean | undefined;
                    }
                    /**
                     * "targets" config option:
                     * https://babeljs.io/docs/en/babel-preset-env#targets
                     */
                    export type TargetsOptions = (BrowserslistQuery | ReadonlyArray<BrowserslistQuery> | {
                        [key in Target]?: string;
                    } | {
                        esmodules: true;
                    } | {
                        node: (string | "current" | true);
                    } | {
                        safari: (string | "tp");
                    } | {
                        browsers: (string | ReadonlyArray<string>);
                    });
                    export type BrowserslistQuery = string;
                    /**
                     * List of supported Browserslist targets:
                     * Source: https://github.com/browserslist/browserslist#browsers
                     */
                    export type Target = ("Android" | "Baidu" | "BlackBerry" | "bb" | "Chrome" | "ChromeAndroid" | "and_chr" | "Edge" | "Electron" | "Explorer" | "ie" | "ExplorerMobile" | "ie_mob" | "Firefox" | "ff" | "FirefoxAndroid" | "and_ff" | "iOS" | "ios_saf" | "Node" | "Opera" | "OperaMini" | "op_mini" | "OperaMobile" | "op_mob" | "QQAndroid" | "and_qq" | "Safari" | "Samsung" | "UCAndroid" | "and_uc" | "kaios");
                    /**
                     * https://babeljs.io/docs/en/babel-preset-env#modules
                     */
                    export type ModuleOption = ("amd" | "umd" | "systemjs" | "commonjs" | "cjs" | "auto" | false);
                    export type PluginList = ReadonlyArray<PluginListItem>;
                    export type PluginListItem = (string | RegExp);
                    export type UseBuiltInsOption = ("usage" | "entry" | false);
                    export type CorejsOption = (CorejsVersion | {
                        version: CorejsVersion;
                        proposals: boolean;
                    });
                    export type CorejsVersion = (2 | 3);
                }
                export namespace presetCC {
                    export namespace helpers {
                        export function generateHelperModuleSource(): string;
                        export function getHelperBuilder(helperName: string): any;
                        export function addHelper(state: core.PluginPass, helperName: string): any;
                        export const CC_HELPER_MODULE = "CC_HELPER_MODULE";
                    }
                    export const babelPresetCC: any;
                    export namespace babelPresetCC {
                        export type Options = Partial<{
                            /**
                             * See `@babel/plugin-transform-typescript`.
                             */
                            allowDeclareFields: boolean;
                            /**
                             * See `@babel/plugin-transform-typescript`.
                             */
                            onlyRemoveTypeImports: boolean;
                            /**
                             * If true, `loose: true` is passed to `@babel/plugin-proposal-class-properties`.
                             */
                            useDefineForClassFields: boolean;
                            /**
                             * If it's 'external', then the helpers should be an external module.
                             */
                            ccDecoratorHelpers: "external" | "inline";
                            /**
                             * The list of decorator names to be optimized.
                             */
                            fieldDecorators: string[];
                            /**
                             * The list of decorator names to be removed, which should only work in Cocos Creator editor environment.
                             */
                            editorDecorators: string[];
                        }>;
                    }
                }
            }
            export namespace plugins {
                export const syntaxTS: any;
                export const syntaxDecorators: any;
                export const transformForOf: any;
                export function cocosDynamicImportVars({ types }: typeof core): core.PluginObj<{
                    filename?: string;
                    opts?: Options;
                }>;
                export const transformModulesSystemjs: any;
            }
            export namespace helpers {
                export function addDefault(path: traverse.NodePath, importedSource: string, opts?: Partial<ImportOptions>): core.types.Identifier;
                /**
                 * add a named import to the program path of given path
                 *
                 * @param path The starting path to find a program path
                 * @param name The name of the generated binding. Babel will prefix it with `_`
                 * @param importedSource The source of the import
                 * @param [opts]
                 * @returns If opts.ensureNoContext is true, returns a SequenceExpression,
                 *   else if opts.ensureLiveReference is true, returns a MemberExpression, else returns an Identifier
                 */
                export function addNamed(path: traverse.NodePath, name: string, importedSource: string, opts?: Omit<Partial<ImportOptions>, "ensureLiveReference" | "ensureNoContext">): core.types.Identifier;
                export function addNamed(path: traverse.NodePath, name: string, importedSource: string, opts?: Omit<Partial<ImportOptions>, "ensureLiveReference"> & {
                    ensureLiveReference: true;
                }): core.types.MemberExpression;
                export function addNamed(path: traverse.NodePath, name: string, importedSource: string, opts?: Omit<Partial<ImportOptions>, "ensureNoContext"> & {
                    ensureNoContext: true;
                }): core.types.SequenceExpression;
                export function addNamespace(path: traverse.NodePath, importedSource: string, opts?: Partial<ImportOptions>): core.types.Identifier;
                export function addSideEffect(path: traverse.NodePath, importedSource: string, opts?: Partial<ImportOptions>): void;
                export function isModule(path: traverse.NodePath<core.types.Program>): boolean;
                export interface ImportOptions {
                    /**
                     * The module being referenced.
                     */
                    importedSource: string | null;
                    /**
                     * The type of module being imported:
                     *
                     *  * 'es6'      - An ES6 module.
                     *  * 'commonjs' - A CommonJS module. (Default)
                     */
                    importedType: "es6" | "commonjs";
                    /**
                     * The type of interop behavior for namespace/default/named when loading
                     * CommonJS modules.
                     *
                     * ## 'babel' (Default)
                     *
                     * Load using Babel's interop.
                     *
                     * If '.__esModule' is true, treat as 'compiled', else:
                     *
                     * * Namespace: A copy of the module.exports with .default
                     *     populated by the module.exports object.
                     * * Default: The module.exports value.
                     * * Named: The .named property of module.exports.
                     *
                     * The 'ensureLiveReference' has no effect on the liveness of these.
                     *
                     * ## 'compiled'
                     *
                     * Assume the module is ES6 compiled to CommonJS. Useful to avoid injecting
                     * interop logic if you are confident that the module is a certain format.
                     *
                     * * Namespace: The root module.exports object.
                     * * Default: The .default property of the namespace.
                     * * Named: The .named property of the namespace.
                     *
                     * Will return erroneous results if the imported module is _not_ compiled
                     * from ES6 with Babel.
                     *
                     * ## 'uncompiled'
                     *
                     * Assume the module is _not_ ES6 compiled to CommonJS. Used a simplified
                     * access pattern that doesn't require additional function calls.
                     *
                     * Will return erroneous results if the imported module _is_ compiled
                     * from ES6 with Babel.
                     *
                     * * Namespace: The module.exports object.
                     * * Default: The module.exports object.
                     * * Named: The .named property of module.exports.
                     */
                    importedInterop: "babel" | "node" | "compiled" | "uncompiled";
                    /**
                     * The type of CommonJS interop included in the environment that will be
                     * loading the output code.
                     *
                     *  * 'babel' - CommonJS modules load with Babel's interop. (Default)
                     *  * 'node'  - CommonJS modules load with Node's interop.
                     *
                     * See descriptions in 'importedInterop' for more details.
                     */
                    importingInterop: "babel" | "node";
                    /**
                     * Define whether we explicitly care that the import be a live reference.
                     * Only applies when importing default and named imports, not the namespace.
                     *
                     *  * true  - Force imported values to be live references.
                     *  * false - No particular requirements. Keeps the code simplest. (Default)
                     */
                    ensureLiveReference: boolean;
                    /**
                     * Define if we explicitly care that the result not be a property reference.
                     *
                     *  * true  - Force calls to exclude context. Useful if the value is going to
                     *            be used as function callee.
                     *  * false - No particular requirements for context of the access. (Default)
                     */
                    ensureNoContext: boolean;
                    /**
                     * Define whether the import should be loaded before or after the existing imports.
                     * "after" is only allowed inside ECMAScript modules, since it's not possible to
                     * reliably pick the location _after_ require() calls but _before_ other code in CJS.
                     */
                    importPosition: "before" | "after";
                    nameHint?: string;
                    blockHoist?: number;
                }
                export class ImportInjector {
                    constructor(path: traverse.NodePath, importedSource?: string, opts?: Partial<ImportOptions>);
                    addDefault(importedSourceIn: string, opts: Partial<ImportOptions>): core.types.Identifier;
                    addNamed(importName: string, importedSourceIn: string, opts: Partial<ImportOptions>): core.types.Identifier;
                    addNamespace(importedSourceIn: string, opts: Partial<ImportOptions>): core.types.Identifier;
                    addSideEffect(importedSourceIn: string, opts: Partial<ImportOptions>): void;
                }
            }
        }
        export namespace typescript {
            /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0
            
            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.
            
            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
             ***************************************************************************** */
            export namespace core {
                export const versionMajorMinor = "4.9";
                /** The version of the TypeScript compiler release */
                export const version: string;
                /**
                 * Type of objects whose values are all of the same type.
                 * The `in` and `for-in` operators can *not* be safely used,
                 * since `Object.prototype` may be modified by outside code.
                 */
                export interface MapLike<T> {
                    [index: string]: T;
                }
                export interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
                    " __sortedArrayBrand": any;
                }
                export interface SortedArray<T> extends Array<T> {
                    " __sortedArrayBrand": any;
                }
                /** Common read methods for ES6 Map/Set. */
                export interface ReadonlyCollection<K> {
                    readonly size: number;
                    has(key: K): boolean;
                    keys(): Iterator<K>;
                }
                /** Common write methods for ES6 Map/Set. */
                export interface Collection<K> extends ReadonlyCollection<K> {
                    delete(key: K): boolean;
                    clear(): void;
                }
                /** ES6 Map interface, only read methods included. */
                export interface ReadonlyESMap<K, V> extends ReadonlyCollection<K> {
                    get(key: K): V | undefined;
                    values(): Iterator<V>;
                    entries(): Iterator<[
                        K,
                        V
                    ]>;
                    forEach(action: (value: V, key: K) => void): void;
                }
                /**
                 * ES6 Map interface, only read methods included.
                 */
                export interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
                }
                /**
                 * @deprecated Use `ts.ReadonlyESMap<K, V>` instead.
                 */
                export interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
                }
                /** ES6 Map interface. */
                export interface ESMap<K, V> extends ReadonlyESMap<K, V>, Collection<K> {
                    set(key: K, value: V): this;
                }
                /**
                 * ES6 Map interface.
                 */
                export interface Map<T> extends ESMap<string, T> {
                }
                /**
                 * @deprecated Use `ts.ESMap<K, V>` instead.
                 */
                export interface Map<T> extends ESMap<string, T> {
                }
                /** ES6 Set interface, only read methods included. */
                export interface ReadonlySet<T> extends ReadonlyCollection<T> {
                    has(value: T): boolean;
                    values(): Iterator<T>;
                    entries(): Iterator<[
                        T,
                        T
                    ]>;
                    forEach(action: (value: T, key: T) => void): void;
                }
                /** ES6 Set interface. */
                export interface Set<T> extends ReadonlySet<T>, Collection<T> {
                    add(value: T): this;
                    delete(value: T): boolean;
                }
                /** ES6 Iterator type. */
                export interface Iterator<T> {
                    next(): {
                        value: T;
                        done?: false;
                    } | {
                        value: void;
                        done: true;
                    };
                }
                /** Array that is only intended to be pushed to, never read. */
                export interface Push<T> {
                    push(...values: T[]): void;
                }
                export type Path = string & {
                    __pathBrand: any;
                };
                export interface TextRange {
                    pos: number;
                    end: number;
                }
                export interface ReadonlyTextRange {
                    readonly pos: number;
                    readonly end: number;
                }
                export enum SyntaxKind {
                    Unknown = 0,
                    EndOfFileToken = 1,
                    SingleLineCommentTrivia = 2,
                    MultiLineCommentTrivia = 3,
                    NewLineTrivia = 4,
                    WhitespaceTrivia = 5,
                    ShebangTrivia = 6,
                    ConflictMarkerTrivia = 7,
                    NumericLiteral = 8,
                    BigIntLiteral = 9,
                    StringLiteral = 10,
                    JsxText = 11,
                    JsxTextAllWhiteSpaces = 12,
                    RegularExpressionLiteral = 13,
                    NoSubstitutionTemplateLiteral = 14,
                    TemplateHead = 15,
                    TemplateMiddle = 16,
                    TemplateTail = 17,
                    OpenBraceToken = 18,
                    CloseBraceToken = 19,
                    OpenParenToken = 20,
                    CloseParenToken = 21,
                    OpenBracketToken = 22,
                    CloseBracketToken = 23,
                    DotToken = 24,
                    DotDotDotToken = 25,
                    SemicolonToken = 26,
                    CommaToken = 27,
                    QuestionDotToken = 28,
                    LessThanToken = 29,
                    LessThanSlashToken = 30,
                    GreaterThanToken = 31,
                    LessThanEqualsToken = 32,
                    GreaterThanEqualsToken = 33,
                    EqualsEqualsToken = 34,
                    ExclamationEqualsToken = 35,
                    EqualsEqualsEqualsToken = 36,
                    ExclamationEqualsEqualsToken = 37,
                    EqualsGreaterThanToken = 38,
                    PlusToken = 39,
                    MinusToken = 40,
                    AsteriskToken = 41,
                    AsteriskAsteriskToken = 42,
                    SlashToken = 43,
                    PercentToken = 44,
                    PlusPlusToken = 45,
                    MinusMinusToken = 46,
                    LessThanLessThanToken = 47,
                    GreaterThanGreaterThanToken = 48,
                    GreaterThanGreaterThanGreaterThanToken = 49,
                    AmpersandToken = 50,
                    BarToken = 51,
                    CaretToken = 52,
                    ExclamationToken = 53,
                    TildeToken = 54,
                    AmpersandAmpersandToken = 55,
                    BarBarToken = 56,
                    QuestionToken = 57,
                    ColonToken = 58,
                    AtToken = 59,
                    QuestionQuestionToken = 60,
                    /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
                    BacktickToken = 61,
                    /** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */
                    HashToken = 62,
                    EqualsToken = 63,
                    PlusEqualsToken = 64,
                    MinusEqualsToken = 65,
                    AsteriskEqualsToken = 66,
                    AsteriskAsteriskEqualsToken = 67,
                    SlashEqualsToken = 68,
                    PercentEqualsToken = 69,
                    LessThanLessThanEqualsToken = 70,
                    GreaterThanGreaterThanEqualsToken = 71,
                    GreaterThanGreaterThanGreaterThanEqualsToken = 72,
                    AmpersandEqualsToken = 73,
                    BarEqualsToken = 74,
                    BarBarEqualsToken = 75,
                    AmpersandAmpersandEqualsToken = 76,
                    QuestionQuestionEqualsToken = 77,
                    CaretEqualsToken = 78,
                    Identifier = 79,
                    PrivateIdentifier = 80,
                    BreakKeyword = 81,
                    CaseKeyword = 82,
                    CatchKeyword = 83,
                    ClassKeyword = 84,
                    ConstKeyword = 85,
                    ContinueKeyword = 86,
                    DebuggerKeyword = 87,
                    DefaultKeyword = 88,
                    DeleteKeyword = 89,
                    DoKeyword = 90,
                    ElseKeyword = 91,
                    EnumKeyword = 92,
                    ExportKeyword = 93,
                    ExtendsKeyword = 94,
                    FalseKeyword = 95,
                    FinallyKeyword = 96,
                    ForKeyword = 97,
                    FunctionKeyword = 98,
                    IfKeyword = 99,
                    ImportKeyword = 100,
                    InKeyword = 101,
                    InstanceOfKeyword = 102,
                    NewKeyword = 103,
                    NullKeyword = 104,
                    ReturnKeyword = 105,
                    SuperKeyword = 106,
                    SwitchKeyword = 107,
                    ThisKeyword = 108,
                    ThrowKeyword = 109,
                    TrueKeyword = 110,
                    TryKeyword = 111,
                    TypeOfKeyword = 112,
                    VarKeyword = 113,
                    VoidKeyword = 114,
                    WhileKeyword = 115,
                    WithKeyword = 116,
                    ImplementsKeyword = 117,
                    InterfaceKeyword = 118,
                    LetKeyword = 119,
                    PackageKeyword = 120,
                    PrivateKeyword = 121,
                    ProtectedKeyword = 122,
                    PublicKeyword = 123,
                    StaticKeyword = 124,
                    YieldKeyword = 125,
                    AbstractKeyword = 126,
                    AccessorKeyword = 127,
                    AsKeyword = 128,
                    AssertsKeyword = 129,
                    AssertKeyword = 130,
                    AnyKeyword = 131,
                    AsyncKeyword = 132,
                    AwaitKeyword = 133,
                    BooleanKeyword = 134,
                    ConstructorKeyword = 135,
                    DeclareKeyword = 136,
                    GetKeyword = 137,
                    InferKeyword = 138,
                    IntrinsicKeyword = 139,
                    IsKeyword = 140,
                    KeyOfKeyword = 141,
                    ModuleKeyword = 142,
                    NamespaceKeyword = 143,
                    NeverKeyword = 144,
                    OutKeyword = 145,
                    ReadonlyKeyword = 146,
                    RequireKeyword = 147,
                    NumberKeyword = 148,
                    ObjectKeyword = 149,
                    SatisfiesKeyword = 150,
                    SetKeyword = 151,
                    StringKeyword = 152,
                    SymbolKeyword = 153,
                    TypeKeyword = 154,
                    UndefinedKeyword = 155,
                    UniqueKeyword = 156,
                    UnknownKeyword = 157,
                    FromKeyword = 158,
                    GlobalKeyword = 159,
                    BigIntKeyword = 160,
                    OverrideKeyword = 161,
                    OfKeyword = 162,
                    QualifiedName = 163,
                    ComputedPropertyName = 164,
                    TypeParameter = 165,
                    Parameter = 166,
                    Decorator = 167,
                    PropertySignature = 168,
                    PropertyDeclaration = 169,
                    MethodSignature = 170,
                    MethodDeclaration = 171,
                    ClassStaticBlockDeclaration = 172,
                    Constructor = 173,
                    GetAccessor = 174,
                    SetAccessor = 175,
                    CallSignature = 176,
                    ConstructSignature = 177,
                    IndexSignature = 178,
                    TypePredicate = 179,
                    TypeReference = 180,
                    FunctionType = 181,
                    ConstructorType = 182,
                    TypeQuery = 183,
                    TypeLiteral = 184,
                    ArrayType = 185,
                    TupleType = 186,
                    OptionalType = 187,
                    RestType = 188,
                    UnionType = 189,
                    IntersectionType = 190,
                    ConditionalType = 191,
                    InferType = 192,
                    ParenthesizedType = 193,
                    ThisType = 194,
                    TypeOperator = 195,
                    IndexedAccessType = 196,
                    MappedType = 197,
                    LiteralType = 198,
                    NamedTupleMember = 199,
                    TemplateLiteralType = 200,
                    TemplateLiteralTypeSpan = 201,
                    ImportType = 202,
                    ObjectBindingPattern = 203,
                    ArrayBindingPattern = 204,
                    BindingElement = 205,
                    ArrayLiteralExpression = 206,
                    ObjectLiteralExpression = 207,
                    PropertyAccessExpression = 208,
                    ElementAccessExpression = 209,
                    CallExpression = 210,
                    NewExpression = 211,
                    TaggedTemplateExpression = 212,
                    TypeAssertionExpression = 213,
                    ParenthesizedExpression = 214,
                    FunctionExpression = 215,
                    ArrowFunction = 216,
                    DeleteExpression = 217,
                    TypeOfExpression = 218,
                    VoidExpression = 219,
                    AwaitExpression = 220,
                    PrefixUnaryExpression = 221,
                    PostfixUnaryExpression = 222,
                    BinaryExpression = 223,
                    ConditionalExpression = 224,
                    TemplateExpression = 225,
                    YieldExpression = 226,
                    SpreadElement = 227,
                    ClassExpression = 228,
                    OmittedExpression = 229,
                    ExpressionWithTypeArguments = 230,
                    AsExpression = 231,
                    NonNullExpression = 232,
                    MetaProperty = 233,
                    SyntheticExpression = 234,
                    SatisfiesExpression = 235,
                    TemplateSpan = 236,
                    SemicolonClassElement = 237,
                    Block = 238,
                    EmptyStatement = 239,
                    VariableStatement = 240,
                    ExpressionStatement = 241,
                    IfStatement = 242,
                    DoStatement = 243,
                    WhileStatement = 244,
                    ForStatement = 245,
                    ForInStatement = 246,
                    ForOfStatement = 247,
                    ContinueStatement = 248,
                    BreakStatement = 249,
                    ReturnStatement = 250,
                    WithStatement = 251,
                    SwitchStatement = 252,
                    LabeledStatement = 253,
                    ThrowStatement = 254,
                    TryStatement = 255,
                    DebuggerStatement = 256,
                    VariableDeclaration = 257,
                    VariableDeclarationList = 258,
                    FunctionDeclaration = 259,
                    ClassDeclaration = 260,
                    InterfaceDeclaration = 261,
                    TypeAliasDeclaration = 262,
                    EnumDeclaration = 263,
                    ModuleDeclaration = 264,
                    ModuleBlock = 265,
                    CaseBlock = 266,
                    NamespaceExportDeclaration = 267,
                    ImportEqualsDeclaration = 268,
                    ImportDeclaration = 269,
                    ImportClause = 270,
                    NamespaceImport = 271,
                    NamedImports = 272,
                    ImportSpecifier = 273,
                    ExportAssignment = 274,
                    ExportDeclaration = 275,
                    NamedExports = 276,
                    NamespaceExport = 277,
                    ExportSpecifier = 278,
                    MissingDeclaration = 279,
                    ExternalModuleReference = 280,
                    JsxElement = 281,
                    JsxSelfClosingElement = 282,
                    JsxOpeningElement = 283,
                    JsxClosingElement = 284,
                    JsxFragment = 285,
                    JsxOpeningFragment = 286,
                    JsxClosingFragment = 287,
                    JsxAttribute = 288,
                    JsxAttributes = 289,
                    JsxSpreadAttribute = 290,
                    JsxExpression = 291,
                    CaseClause = 292,
                    DefaultClause = 293,
                    HeritageClause = 294,
                    CatchClause = 295,
                    AssertClause = 296,
                    AssertEntry = 297,
                    ImportTypeAssertionContainer = 298,
                    PropertyAssignment = 299,
                    ShorthandPropertyAssignment = 300,
                    SpreadAssignment = 301,
                    EnumMember = 302,
                    UnparsedPrologue = 303,
                    UnparsedPrepend = 304,
                    UnparsedText = 305,
                    UnparsedInternalText = 306,
                    UnparsedSyntheticReference = 307,
                    SourceFile = 308,
                    Bundle = 309,
                    UnparsedSource = 310,
                    InputFiles = 311,
                    JSDocTypeExpression = 312,
                    JSDocNameReference = 313,
                    JSDocMemberName = 314,
                    JSDocAllType = 315,
                    JSDocUnknownType = 316,
                    JSDocNullableType = 317,
                    JSDocNonNullableType = 318,
                    JSDocOptionalType = 319,
                    JSDocFunctionType = 320,
                    JSDocVariadicType = 321,
                    JSDocNamepathType = 322,
                    JSDoc = 323,
                    /** @deprecated Use SyntaxKind.JSDoc */
                    JSDocComment = 323,
                    JSDocText = 324,
                    JSDocTypeLiteral = 325,
                    JSDocSignature = 326,
                    JSDocLink = 327,
                    JSDocLinkCode = 328,
                    JSDocLinkPlain = 329,
                    JSDocTag = 330,
                    JSDocAugmentsTag = 331,
                    JSDocImplementsTag = 332,
                    JSDocAuthorTag = 333,
                    JSDocDeprecatedTag = 334,
                    JSDocClassTag = 335,
                    JSDocPublicTag = 336,
                    JSDocPrivateTag = 337,
                    JSDocProtectedTag = 338,
                    JSDocReadonlyTag = 339,
                    JSDocOverrideTag = 340,
                    JSDocCallbackTag = 341,
                    JSDocEnumTag = 342,
                    JSDocParameterTag = 343,
                    JSDocReturnTag = 344,
                    JSDocThisTag = 345,
                    JSDocTypeTag = 346,
                    JSDocTemplateTag = 347,
                    JSDocTypedefTag = 348,
                    JSDocSeeTag = 349,
                    JSDocPropertyTag = 350,
                    SyntaxList = 351,
                    NotEmittedStatement = 352,
                    PartiallyEmittedExpression = 353,
                    CommaListExpression = 354,
                    MergeDeclarationMarker = 355,
                    EndOfDeclarationMarker = 356,
                    SyntheticReferenceExpression = 357,
                    Count = 358,
                    FirstAssignment = 63,
                    LastAssignment = 78,
                    FirstCompoundAssignment = 64,
                    LastCompoundAssignment = 78,
                    FirstReservedWord = 81,
                    LastReservedWord = 116,
                    FirstKeyword = 81,
                    LastKeyword = 162,
                    FirstFutureReservedWord = 117,
                    LastFutureReservedWord = 125,
                    FirstTypeNode = 179,
                    LastTypeNode = 202,
                    FirstPunctuation = 18,
                    LastPunctuation = 78,
                    FirstToken = 0,
                    LastToken = 162,
                    FirstTriviaToken = 2,
                    LastTriviaToken = 7,
                    FirstLiteralToken = 8,
                    LastLiteralToken = 14,
                    FirstTemplateToken = 14,
                    LastTemplateToken = 17,
                    FirstBinaryOperator = 29,
                    LastBinaryOperator = 78,
                    FirstStatement = 240,
                    LastStatement = 256,
                    FirstNode = 163,
                    FirstJSDocNode = 312,
                    LastJSDocNode = 350,
                    FirstJSDocTagNode = 330,
                    LastJSDocTagNode = 350
                }
                export type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;
                export type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;
                export type PseudoLiteralSyntaxKind = SyntaxKind.TemplateHead | SyntaxKind.TemplateMiddle | SyntaxKind.TemplateTail;
                export type PunctuationSyntaxKind = SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.OpenParenToken | SyntaxKind.CloseParenToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.DotToken | SyntaxKind.DotDotDotToken | SyntaxKind.SemicolonToken | SyntaxKind.CommaToken | SyntaxKind.QuestionDotToken | SyntaxKind.LessThanToken | SyntaxKind.LessThanSlashToken | SyntaxKind.GreaterThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.EqualsEqualsToken | SyntaxKind.ExclamationEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.EqualsGreaterThanToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.AsteriskToken | SyntaxKind.AsteriskAsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken | SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken | SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken | SyntaxKind.ExclamationToken | SyntaxKind.TildeToken | SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken | SyntaxKind.QuestionQuestionToken | SyntaxKind.QuestionToken | SyntaxKind.ColonToken | SyntaxKind.AtToken | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.EqualsToken | SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken;
                export type KeywordSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AnyKeyword | SyntaxKind.AsKeyword | SyntaxKind.AssertsKeyword | SyntaxKind.AssertKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.AwaitKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.BreakKeyword | SyntaxKind.CaseKeyword | SyntaxKind.CatchKeyword | SyntaxKind.ClassKeyword | SyntaxKind.ConstKeyword | SyntaxKind.ConstructorKeyword | SyntaxKind.ContinueKeyword | SyntaxKind.DebuggerKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.DeleteKeyword | SyntaxKind.DoKeyword | SyntaxKind.ElseKeyword | SyntaxKind.EnumKeyword | SyntaxKind.ExportKeyword | SyntaxKind.ExtendsKeyword | SyntaxKind.FalseKeyword | SyntaxKind.FinallyKeyword | SyntaxKind.ForKeyword | SyntaxKind.FromKeyword | SyntaxKind.FunctionKeyword | SyntaxKind.GetKeyword | SyntaxKind.GlobalKeyword | SyntaxKind.IfKeyword | SyntaxKind.ImplementsKeyword | SyntaxKind.ImportKeyword | SyntaxKind.InferKeyword | SyntaxKind.InKeyword | SyntaxKind.InstanceOfKeyword | SyntaxKind.InterfaceKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.IsKeyword | SyntaxKind.KeyOfKeyword | SyntaxKind.LetKeyword | SyntaxKind.ModuleKeyword | SyntaxKind.NamespaceKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NewKeyword | SyntaxKind.NullKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.OfKeyword | SyntaxKind.PackageKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.RequireKeyword | SyntaxKind.ReturnKeyword | SyntaxKind.SatisfiesKeyword | SyntaxKind.SetKeyword | SyntaxKind.StaticKeyword | SyntaxKind.StringKeyword | SyntaxKind.SuperKeyword | SyntaxKind.SwitchKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.ThisKeyword | SyntaxKind.ThrowKeyword | SyntaxKind.TrueKeyword | SyntaxKind.TryKeyword | SyntaxKind.TypeKeyword | SyntaxKind.TypeOfKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VarKeyword | SyntaxKind.VoidKeyword | SyntaxKind.WhileKeyword | SyntaxKind.WithKeyword | SyntaxKind.YieldKeyword;
                export type ModifierSyntaxKind = SyntaxKind.AbstractKeyword | SyntaxKind.AccessorKeyword | SyntaxKind.AsyncKeyword | SyntaxKind.ConstKeyword | SyntaxKind.DeclareKeyword | SyntaxKind.DefaultKeyword | SyntaxKind.ExportKeyword | SyntaxKind.InKeyword | SyntaxKind.PrivateKeyword | SyntaxKind.ProtectedKeyword | SyntaxKind.PublicKeyword | SyntaxKind.ReadonlyKeyword | SyntaxKind.OutKeyword | SyntaxKind.OverrideKeyword | SyntaxKind.StaticKeyword;
                export type KeywordTypeSyntaxKind = SyntaxKind.AnyKeyword | SyntaxKind.BigIntKeyword | SyntaxKind.BooleanKeyword | SyntaxKind.IntrinsicKeyword | SyntaxKind.NeverKeyword | SyntaxKind.NumberKeyword | SyntaxKind.ObjectKeyword | SyntaxKind.StringKeyword | SyntaxKind.SymbolKeyword | SyntaxKind.UndefinedKeyword | SyntaxKind.UnknownKeyword | SyntaxKind.VoidKeyword;
                export type TokenSyntaxKind = SyntaxKind.Unknown | SyntaxKind.EndOfFileToken | TriviaSyntaxKind | LiteralSyntaxKind | PseudoLiteralSyntaxKind | PunctuationSyntaxKind | SyntaxKind.Identifier | KeywordSyntaxKind;
                export type JsxTokenSyntaxKind = SyntaxKind.LessThanSlashToken | SyntaxKind.EndOfFileToken | SyntaxKind.ConflictMarkerTrivia | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.OpenBraceToken | SyntaxKind.LessThanToken;
                export type JSDocSyntaxKind = SyntaxKind.EndOfFileToken | SyntaxKind.WhitespaceTrivia | SyntaxKind.AtToken | SyntaxKind.NewLineTrivia | SyntaxKind.AsteriskToken | SyntaxKind.OpenBraceToken | SyntaxKind.CloseBraceToken | SyntaxKind.LessThanToken | SyntaxKind.GreaterThanToken | SyntaxKind.OpenBracketToken | SyntaxKind.CloseBracketToken | SyntaxKind.EqualsToken | SyntaxKind.CommaToken | SyntaxKind.DotToken | SyntaxKind.Identifier | SyntaxKind.BacktickToken | SyntaxKind.HashToken | SyntaxKind.Unknown | KeywordSyntaxKind;
                export enum NodeFlags {
                    None = 0,
                    Let = 1,
                    Const = 2,
                    NestedNamespace = 4,
                    Synthesized = 8,
                    Namespace = 16,
                    OptionalChain = 32,
                    ExportContext = 64,
                    ContainsThis = 128,
                    HasImplicitReturn = 256,
                    HasExplicitReturn = 512,
                    GlobalAugmentation = 1024,
                    HasAsyncFunctions = 2048,
                    DisallowInContext = 4096,
                    YieldContext = 8192,
                    DecoratorContext = 16384,
                    AwaitContext = 32768,
                    DisallowConditionalTypesContext = 65536,
                    ThisNodeHasError = 131072,
                    JavaScriptFile = 262144,
                    ThisNodeOrAnySubNodesHasError = 524288,
                    HasAggregatedChildData = 1048576,
                    JSDoc = 8388608,
                    JsonFile = 67108864,
                    BlockScoped = 3,
                    ReachabilityCheckFlags = 768,
                    ReachabilityAndEmitFlags = 2816,
                    ContextFlags = 50720768,
                    TypeExcludesFlags = 40960
                }
                export enum ModifierFlags {
                    None = 0,
                    Export = 1,
                    Ambient = 2,
                    Public = 4,
                    Private = 8,
                    Protected = 16,
                    Static = 32,
                    Readonly = 64,
                    Accessor = 128,
                    Abstract = 256,
                    Async = 512,
                    Default = 1024,
                    Const = 2048,
                    HasComputedJSDocModifiers = 4096,
                    Deprecated = 8192,
                    Override = 16384,
                    In = 32768,
                    Out = 65536,
                    Decorator = 131072,
                    HasComputedFlags = 536870912,
                    AccessibilityModifier = 28,
                    ParameterPropertyModifier = 16476,
                    NonPublicAccessibilityModifier = 24,
                    TypeScriptModifier = 117086,
                    ExportDefault = 1025,
                    All = 258047,
                    Modifier = 126975
                }
                export enum JsxFlags {
                    None = 0,
                    /** An element from a named property of the JSX.IntrinsicElements interface */
                    IntrinsicNamedElement = 1,
                    /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */
                    IntrinsicIndexedElement = 2,
                    IntrinsicElement = 3
                }
                export interface Node extends ReadonlyTextRange {
                    readonly kind: SyntaxKind;
                    readonly flags: NodeFlags;
                    readonly parent: Node;
                }
                export interface Node {
                    getSourceFile(): SourceFile;
                    getChildCount(sourceFile?: SourceFile): number;
                    getChildAt(index: number, sourceFile?: SourceFile): Node;
                    getChildren(sourceFile?: SourceFile): Node[];
                    getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
                    getFullStart(): number;
                    getEnd(): number;
                    getWidth(sourceFile?: SourceFileLike): number;
                    getFullWidth(): number;
                    getLeadingTriviaWidth(sourceFile?: SourceFile): number;
                    getFullText(sourceFile?: SourceFile): string;
                    getText(sourceFile?: SourceFile): string;
                    getFirstToken(sourceFile?: SourceFile): Node | undefined;
                    getLastToken(sourceFile?: SourceFile): Node | undefined;
                    forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
                }
                export interface Node {
                    /**
                     * @deprecated `decorators` has been removed from `Node` and merged with `modifiers` on the `Node` subtypes that support them.
                     * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.
                     * Use `ts.getDecorators()` to get the decorators of a `Node`.
                     *
                     * For example:
                     * ```ts
                     * const decorators = ts.canHaveDecorators(node) ? ts.getDecorators(node) : undefined;
                     * ```
                     */
                    readonly decorators?: undefined;
                    /**
                     * @deprecated `modifiers` has been removed from `Node` and moved to the `Node` subtypes that support them.
                     * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.
                     * Use `ts.getModifiers()` to get the modifiers of a `Node`.
                     *
                     * For example:
                     * ```ts
                     * const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
                     * ```
                     */
                    readonly modifiers?: NodeArray<ModifierLike> | undefined;
                }
                export interface JSDocContainer {
                }
                export type HasJSDoc = ParameterDeclaration | CallSignatureDeclaration | ClassStaticBlockDeclaration | ConstructSignatureDeclaration | MethodSignature | PropertySignature | ArrowFunction | ParenthesizedExpression | SpreadAssignment | ShorthandPropertyAssignment | PropertyAssignment | FunctionExpression | EmptyStatement | DebuggerStatement | Block | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | BreakStatement | ContinueStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | FunctionDeclaration | ConstructorDeclaration | MethodDeclaration | VariableDeclaration | PropertyDeclaration | AccessorDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumMember | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | NamespaceExportDeclaration | ExportAssignment | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | ExportDeclaration | NamedTupleMember | ExportSpecifier | CaseClause | EndOfFileToken;
                export type HasType = SignatureDeclaration | VariableDeclaration | ParameterDeclaration | PropertySignature | PropertyDeclaration | TypePredicateNode | ParenthesizedTypeNode | TypeOperatorNode | MappedTypeNode | AssertionExpression | TypeAliasDeclaration | JSDocTypeExpression | JSDocNonNullableType | JSDocNullableType | JSDocOptionalType | JSDocVariadicType;
                export type HasTypeArguments = CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement | JsxSelfClosingElement;
                export type HasInitializer = HasExpressionInitializer | ForStatement | ForInStatement | ForOfStatement | JsxAttribute;
                export type HasExpressionInitializer = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | EnumMember;
                export type HasDecorators = ParameterDeclaration | PropertyDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassExpression | ClassDeclaration;
                export type HasModifiers = TypeParameterDeclaration | ParameterDeclaration | ConstructorTypeNode | PropertySignature | PropertyDeclaration | MethodSignature | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | IndexSignatureDeclaration | FunctionExpression | ArrowFunction | ClassExpression | VariableStatement | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | ExportAssignment | ExportDeclaration;
                export interface NodeArray<T extends Node> extends ReadonlyArray<T>, ReadonlyTextRange {
                    readonly hasTrailingComma: boolean;
                }
                export interface Token<TKind extends SyntaxKind> extends Node {
                    readonly kind: TKind;
                }
                export type EndOfFileToken = Token<SyntaxKind.EndOfFileToken> & JSDocContainer;
                export interface PunctuationToken<TKind extends PunctuationSyntaxKind> extends Token<TKind> {
                }
                export type DotToken = PunctuationToken<SyntaxKind.DotToken>;
                export type DotDotDotToken = PunctuationToken<SyntaxKind.DotDotDotToken>;
                export type QuestionToken = PunctuationToken<SyntaxKind.QuestionToken>;
                export type ExclamationToken = PunctuationToken<SyntaxKind.ExclamationToken>;
                export type ColonToken = PunctuationToken<SyntaxKind.ColonToken>;
                export type EqualsToken = PunctuationToken<SyntaxKind.EqualsToken>;
                export type AsteriskToken = PunctuationToken<SyntaxKind.AsteriskToken>;
                export type EqualsGreaterThanToken = PunctuationToken<SyntaxKind.EqualsGreaterThanToken>;
                export type PlusToken = PunctuationToken<SyntaxKind.PlusToken>;
                export type MinusToken = PunctuationToken<SyntaxKind.MinusToken>;
                export type QuestionDotToken = PunctuationToken<SyntaxKind.QuestionDotToken>;
                export interface KeywordToken<TKind extends KeywordSyntaxKind> extends Token<TKind> {
                }
                export type AssertsKeyword = KeywordToken<SyntaxKind.AssertsKeyword>;
                export type AssertKeyword = KeywordToken<SyntaxKind.AssertKeyword>;
                export type AwaitKeyword = KeywordToken<SyntaxKind.AwaitKeyword>;
                /** @deprecated Use `AwaitKeyword` instead. */
                export type AwaitKeywordToken = AwaitKeyword;
                /** @deprecated Use `AssertsKeyword` instead. */
                export type AssertsToken = AssertsKeyword;
                export interface ModifierToken<TKind extends ModifierSyntaxKind> extends KeywordToken<TKind> {
                }
                export type AbstractKeyword = ModifierToken<SyntaxKind.AbstractKeyword>;
                export type AccessorKeyword = ModifierToken<SyntaxKind.AccessorKeyword>;
                export type AsyncKeyword = ModifierToken<SyntaxKind.AsyncKeyword>;
                export type ConstKeyword = ModifierToken<SyntaxKind.ConstKeyword>;
                export type DeclareKeyword = ModifierToken<SyntaxKind.DeclareKeyword>;
                export type DefaultKeyword = ModifierToken<SyntaxKind.DefaultKeyword>;
                export type ExportKeyword = ModifierToken<SyntaxKind.ExportKeyword>;
                export type InKeyword = ModifierToken<SyntaxKind.InKeyword>;
                export type PrivateKeyword = ModifierToken<SyntaxKind.PrivateKeyword>;
                export type ProtectedKeyword = ModifierToken<SyntaxKind.ProtectedKeyword>;
                export type PublicKeyword = ModifierToken<SyntaxKind.PublicKeyword>;
                export type ReadonlyKeyword = ModifierToken<SyntaxKind.ReadonlyKeyword>;
                export type OutKeyword = ModifierToken<SyntaxKind.OutKeyword>;
                export type OverrideKeyword = ModifierToken<SyntaxKind.OverrideKeyword>;
                export type StaticKeyword = ModifierToken<SyntaxKind.StaticKeyword>;
                /** @deprecated Use `ReadonlyKeyword` instead. */
                export type ReadonlyToken = ReadonlyKeyword;
                export type Modifier = AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword;
                export type ModifierLike = Modifier | Decorator;
                export type AccessibilityModifier = PublicKeyword | PrivateKeyword | ProtectedKeyword;
                export type ParameterPropertyModifier = AccessibilityModifier | ReadonlyKeyword;
                export type ClassMemberModifier = AccessibilityModifier | ReadonlyKeyword | StaticKeyword | AccessorKeyword;
                export type ModifiersArray = NodeArray<Modifier>;
                export enum GeneratedIdentifierFlags {
                    None = 0,
                    ReservedInNestedScopes = 8,
                    Optimistic = 16,
                    FileLevel = 32,
                    AllowNameSubstitution = 64
                }
                export interface Identifier extends PrimaryExpression, Declaration {
                    readonly kind: SyntaxKind.Identifier;
                    /**
                     * Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)
                     * Text of identifier, but if the identifier begins with two underscores, this will begin with three.
                     */
                    readonly escapedText: __String;
                    readonly originalKeywordKind?: SyntaxKind;
                    isInJSDocNamespace?: boolean;
                }
                export interface Identifier {
                    readonly text: string;
                }
                export interface TransientIdentifier extends Identifier {
                    resolvedSymbol: Symbol;
                }
                export interface QualifiedName extends Node {
                    readonly kind: SyntaxKind.QualifiedName;
                    readonly left: EntityName;
                    readonly right: Identifier;
                }
                export type EntityName = Identifier | QualifiedName;
                export type PropertyName = Identifier | StringLiteral | NumericLiteral | ComputedPropertyName | PrivateIdentifier;
                export type MemberName = Identifier | PrivateIdentifier;
                export type DeclarationName = Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ComputedPropertyName | ElementAccessExpression | BindingPattern | EntityNameExpression;
                export interface Declaration extends Node {
                    _declarationBrand: any;
                }
                export interface NamedDeclaration extends Declaration {
                    readonly name?: DeclarationName;
                }
                export interface DeclarationStatement extends NamedDeclaration, Statement {
                    readonly name?: Identifier | StringLiteral | NumericLiteral;
                }
                export interface ComputedPropertyName extends Node {
                    readonly kind: SyntaxKind.ComputedPropertyName;
                    readonly parent: Declaration;
                    readonly expression: Expression;
                }
                export interface PrivateIdentifier extends PrimaryExpression {
                    readonly kind: SyntaxKind.PrivateIdentifier;
                    readonly escapedText: __String;
                }
                export interface PrivateIdentifier {
                    readonly text: string;
                }
                export interface Decorator extends Node {
                    readonly kind: SyntaxKind.Decorator;
                    readonly parent: NamedDeclaration;
                    readonly expression: LeftHandSideExpression;
                }
                export interface TypeParameterDeclaration extends NamedDeclaration {
                    readonly kind: SyntaxKind.TypeParameter;
                    readonly parent: DeclarationWithTypeParameterChildren | InferTypeNode;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: Identifier;
                    /** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */
                    readonly constraint?: TypeNode;
                    readonly default?: TypeNode;
                    expression?: Expression;
                }
                export interface SignatureDeclarationBase extends NamedDeclaration, JSDocContainer {
                    readonly kind: SignatureDeclaration["kind"];
                    readonly name?: PropertyName;
                    readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
                    readonly parameters: NodeArray<ParameterDeclaration>;
                    readonly type?: TypeNode | undefined;
                }
                export type SignatureDeclaration = CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction;
                export interface CallSignatureDeclaration extends SignatureDeclarationBase, TypeElement {
                    readonly kind: SyntaxKind.CallSignature;
                }
                export interface ConstructSignatureDeclaration extends SignatureDeclarationBase, TypeElement {
                    readonly kind: SyntaxKind.ConstructSignature;
                }
                export type BindingName = Identifier | BindingPattern;
                export interface VariableDeclaration extends NamedDeclaration, JSDocContainer {
                    readonly kind: SyntaxKind.VariableDeclaration;
                    readonly parent: VariableDeclarationList | CatchClause;
                    readonly name: BindingName;
                    readonly exclamationToken?: ExclamationToken;
                    readonly type?: TypeNode;
                    readonly initializer?: Expression;
                }
                export interface VariableDeclarationList extends Node {
                    readonly kind: SyntaxKind.VariableDeclarationList;
                    readonly parent: VariableStatement | ForStatement | ForOfStatement | ForInStatement;
                    readonly declarations: NodeArray<VariableDeclaration>;
                }
                export interface ParameterDeclaration extends NamedDeclaration, JSDocContainer {
                    readonly kind: SyntaxKind.Parameter;
                    readonly parent: SignatureDeclaration;
                    readonly modifiers?: NodeArray<ModifierLike>;
                    readonly dotDotDotToken?: DotDotDotToken;
                    readonly name: BindingName;
                    readonly questionToken?: QuestionToken;
                    readonly type?: TypeNode;
                    readonly initializer?: Expression;
                }
                export interface BindingElement extends NamedDeclaration {
                    readonly kind: SyntaxKind.BindingElement;
                    readonly parent: BindingPattern;
                    readonly propertyName?: PropertyName;
                    readonly dotDotDotToken?: DotDotDotToken;
                    readonly name: BindingName;
                    readonly initializer?: Expression;
                }
                export interface PropertySignature extends TypeElement, JSDocContainer {
                    readonly kind: SyntaxKind.PropertySignature;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: PropertyName;
                    readonly questionToken?: QuestionToken;
                    readonly type?: TypeNode;
                }
                export interface PropertySignature {
                    /** @deprecated A property signature cannot have an initializer */
                    readonly initializer?: Expression | undefined;
                }
                export interface PropertyDeclaration extends ClassElement, JSDocContainer {
                    readonly kind: SyntaxKind.PropertyDeclaration;
                    readonly parent: ClassLikeDeclaration;
                    readonly modifiers?: NodeArray<ModifierLike>;
                    readonly name: PropertyName;
                    readonly questionToken?: QuestionToken;
                    readonly exclamationToken?: ExclamationToken;
                    readonly type?: TypeNode;
                    readonly initializer?: Expression;
                }
                export interface AutoAccessorPropertyDeclaration extends PropertyDeclaration {
                    _autoAccessorBrand: any;
                }
                export interface ObjectLiteralElement extends NamedDeclaration {
                    _objectLiteralBrand: any;
                    readonly name?: PropertyName;
                }
                /** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */
                export type ObjectLiteralElementLike = PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment | MethodDeclaration | AccessorDeclaration;
                export interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer {
                    readonly kind: SyntaxKind.PropertyAssignment;
                    readonly parent: ObjectLiteralExpression;
                    readonly name: PropertyName;
                    readonly initializer: Expression;
                }
                export interface PropertyAssignment {
                    /** @deprecated A property assignment cannot have a question token */
                    readonly questionToken?: QuestionToken | undefined;
                    /** @deprecated A property assignment cannot have an exclamation token */
                    readonly exclamationToken?: ExclamationToken | undefined;
                }
                export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {
                    readonly kind: SyntaxKind.ShorthandPropertyAssignment;
                    readonly parent: ObjectLiteralExpression;
                    readonly name: Identifier;
                    readonly equalsToken?: EqualsToken;
                    readonly objectAssignmentInitializer?: Expression;
                }
                export interface ShorthandPropertyAssignment {
                    /** @deprecated A shorthand property assignment cannot have modifiers */
                    readonly modifiers?: NodeArray<Modifier> | undefined;
                    /** @deprecated A shorthand property assignment cannot have a question token */
                    readonly questionToken?: QuestionToken | undefined;
                    /** @deprecated A shorthand property assignment cannot have an exclamation token */
                    readonly exclamationToken?: ExclamationToken | undefined;
                }
                export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {
                    readonly kind: SyntaxKind.SpreadAssignment;
                    readonly parent: ObjectLiteralExpression;
                    readonly expression: Expression;
                }
                export type VariableLikeDeclaration = VariableDeclaration | ParameterDeclaration | BindingElement | PropertyDeclaration | PropertyAssignment | PropertySignature | JsxAttribute | ShorthandPropertyAssignment | EnumMember | JSDocPropertyTag | JSDocParameterTag;
                export interface PropertyLikeDeclaration extends NamedDeclaration {
                    readonly name: PropertyName;
                }
                export interface ObjectBindingPattern extends Node {
                    readonly kind: SyntaxKind.ObjectBindingPattern;
                    readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
                    readonly elements: NodeArray<BindingElement>;
                }
                export interface ArrayBindingPattern extends Node {
                    readonly kind: SyntaxKind.ArrayBindingPattern;
                    readonly parent: VariableDeclaration | ParameterDeclaration | BindingElement;
                    readonly elements: NodeArray<ArrayBindingElement>;
                }
                export type BindingPattern = ObjectBindingPattern | ArrayBindingPattern;
                export type ArrayBindingElement = BindingElement | OmittedExpression;
                /**
                 * Several node kinds share function-like features such as a signature,
                 * a name, and a body. These nodes should extend FunctionLikeDeclarationBase.
                 * Examples:
                 * - FunctionDeclaration
                 * - MethodDeclaration
                 * - AccessorDeclaration
                 */
                export interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {
                    _functionLikeDeclarationBrand: any;
                    readonly asteriskToken?: AsteriskToken | undefined;
                    readonly questionToken?: QuestionToken | undefined;
                    readonly exclamationToken?: ExclamationToken | undefined;
                    readonly body?: Block | Expression | undefined;
                }
                export type FunctionLikeDeclaration = FunctionDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration | FunctionExpression | ArrowFunction;
                /** @deprecated Use SignatureDeclaration */
                export type FunctionLike = SignatureDeclaration;
                export interface FunctionDeclaration extends FunctionLikeDeclarationBase, DeclarationStatement {
                    readonly kind: SyntaxKind.FunctionDeclaration;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name?: Identifier;
                    readonly body?: FunctionBody;
                }
                export interface MethodSignature extends SignatureDeclarationBase, TypeElement {
                    readonly kind: SyntaxKind.MethodSignature;
                    readonly parent: ObjectTypeDeclaration;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: PropertyName;
                }
                export interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassElement, ObjectLiteralElement, JSDocContainer {
                    readonly kind: SyntaxKind.MethodDeclaration;
                    readonly parent: ClassLikeDeclaration | ObjectLiteralExpression;
                    readonly modifiers?: NodeArray<ModifierLike> | undefined;
                    readonly name: PropertyName;
                    readonly body?: FunctionBody | undefined;
                }
                export interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer {
                    readonly kind: SyntaxKind.Constructor;
                    readonly parent: ClassLikeDeclaration;
                    readonly modifiers?: NodeArray<Modifier> | undefined;
                    readonly body?: FunctionBody | undefined;
                }
                /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */
                export interface SemicolonClassElement extends ClassElement {
                    readonly kind: SyntaxKind.SemicolonClassElement;
                    readonly parent: ClassLikeDeclaration;
                }
                export interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer {
                    readonly kind: SyntaxKind.GetAccessor;
                    readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
                    readonly modifiers?: NodeArray<ModifierLike>;
                    readonly name: PropertyName;
                    readonly body?: FunctionBody;
                }
                export interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, ClassElement, TypeElement, ObjectLiteralElement, JSDocContainer {
                    readonly kind: SyntaxKind.SetAccessor;
                    readonly parent: ClassLikeDeclaration | ObjectLiteralExpression | TypeLiteralNode | InterfaceDeclaration;
                    readonly modifiers?: NodeArray<ModifierLike>;
                    readonly name: PropertyName;
                    readonly body?: FunctionBody;
                }
                export type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;
                export interface IndexSignatureDeclaration extends SignatureDeclarationBase, ClassElement, TypeElement {
                    readonly kind: SyntaxKind.IndexSignature;
                    readonly parent: ObjectTypeDeclaration;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly type: TypeNode;
                }
                export interface ClassStaticBlockDeclaration extends ClassElement, JSDocContainer {
                    readonly kind: SyntaxKind.ClassStaticBlockDeclaration;
                    readonly parent: ClassDeclaration | ClassExpression;
                    readonly body: Block;
                }
                export interface TypeNode extends Node {
                    _typeNodeBrand: any;
                }
                export interface KeywordTypeNode<TKind extends KeywordTypeSyntaxKind = KeywordTypeSyntaxKind> extends KeywordToken<TKind>, TypeNode {
                    readonly kind: TKind;
                }
                export interface ImportTypeAssertionContainer extends Node {
                    readonly kind: SyntaxKind.ImportTypeAssertionContainer;
                    readonly parent: ImportTypeNode;
                    readonly assertClause: AssertClause;
                    readonly multiLine?: boolean;
                }
                export interface ImportTypeNode extends NodeWithTypeArguments {
                    readonly kind: SyntaxKind.ImportType;
                    readonly isTypeOf: boolean;
                    readonly argument: TypeNode;
                    readonly assertions?: ImportTypeAssertionContainer;
                    readonly qualifier?: EntityName;
                }
                export interface ThisTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.ThisType;
                }
                export type FunctionOrConstructorTypeNode = FunctionTypeNode | ConstructorTypeNode;
                export interface FunctionOrConstructorTypeNodeBase extends TypeNode, SignatureDeclarationBase {
                    readonly kind: SyntaxKind.FunctionType | SyntaxKind.ConstructorType;
                    readonly type: TypeNode;
                }
                export interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase {
                    readonly kind: SyntaxKind.FunctionType;
                }
                export interface FunctionTypeNode {
                    /** @deprecated A function type cannot have modifiers */
                    readonly modifiers?: NodeArray<Modifier> | undefined;
                }
                export interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase {
                    readonly kind: SyntaxKind.ConstructorType;
                    readonly modifiers?: NodeArray<Modifier>;
                }
                export interface NodeWithTypeArguments extends TypeNode {
                    readonly typeArguments?: NodeArray<TypeNode>;
                }
                export type TypeReferenceType = TypeReferenceNode | ExpressionWithTypeArguments;
                export interface TypeReferenceNode extends NodeWithTypeArguments {
                    readonly kind: SyntaxKind.TypeReference;
                    readonly typeName: EntityName;
                }
                export interface TypePredicateNode extends TypeNode {
                    readonly kind: SyntaxKind.TypePredicate;
                    readonly parent: SignatureDeclaration | JSDocTypeExpression;
                    readonly assertsModifier?: AssertsKeyword;
                    readonly parameterName: Identifier | ThisTypeNode;
                    readonly type?: TypeNode;
                }
                export interface TypeQueryNode extends NodeWithTypeArguments {
                    readonly kind: SyntaxKind.TypeQuery;
                    readonly exprName: EntityName;
                }
                export interface TypeLiteralNode extends TypeNode, Declaration {
                    readonly kind: SyntaxKind.TypeLiteral;
                    readonly members: NodeArray<TypeElement>;
                }
                export interface ArrayTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.ArrayType;
                    readonly elementType: TypeNode;
                }
                export interface TupleTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.TupleType;
                    readonly elements: NodeArray<TypeNode | NamedTupleMember>;
                }
                export interface NamedTupleMember extends TypeNode, JSDocContainer, Declaration {
                    readonly kind: SyntaxKind.NamedTupleMember;
                    readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
                    readonly name: Identifier;
                    readonly questionToken?: Token<SyntaxKind.QuestionToken>;
                    readonly type: TypeNode;
                }
                export interface OptionalTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.OptionalType;
                    readonly type: TypeNode;
                }
                export interface RestTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.RestType;
                    readonly type: TypeNode;
                }
                export type UnionOrIntersectionTypeNode = UnionTypeNode | IntersectionTypeNode;
                export interface UnionTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.UnionType;
                    readonly types: NodeArray<TypeNode>;
                }
                export interface IntersectionTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.IntersectionType;
                    readonly types: NodeArray<TypeNode>;
                }
                export interface ConditionalTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.ConditionalType;
                    readonly checkType: TypeNode;
                    readonly extendsType: TypeNode;
                    readonly trueType: TypeNode;
                    readonly falseType: TypeNode;
                }
                export interface InferTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.InferType;
                    readonly typeParameter: TypeParameterDeclaration;
                }
                export interface ParenthesizedTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.ParenthesizedType;
                    readonly type: TypeNode;
                }
                export interface TypeOperatorNode extends TypeNode {
                    readonly kind: SyntaxKind.TypeOperator;
                    readonly operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword;
                    readonly type: TypeNode;
                }
                export interface IndexedAccessTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.IndexedAccessType;
                    readonly objectType: TypeNode;
                    readonly indexType: TypeNode;
                }
                export interface MappedTypeNode extends TypeNode, Declaration {
                    readonly kind: SyntaxKind.MappedType;
                    readonly readonlyToken?: ReadonlyKeyword | PlusToken | MinusToken;
                    readonly typeParameter: TypeParameterDeclaration;
                    readonly nameType?: TypeNode;
                    readonly questionToken?: QuestionToken | PlusToken | MinusToken;
                    readonly type?: TypeNode;
                    /** Used only to produce grammar errors */
                    readonly members?: NodeArray<TypeElement>;
                }
                export interface LiteralTypeNode extends TypeNode {
                    readonly kind: SyntaxKind.LiteralType;
                    readonly literal: NullLiteral | BooleanLiteral | LiteralExpression | PrefixUnaryExpression;
                }
                export interface StringLiteral extends LiteralExpression, Declaration {
                    readonly kind: SyntaxKind.StringLiteral;
                }
                export type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;
                export type PropertyNameLiteral = Identifier | StringLiteralLike | NumericLiteral;
                export interface TemplateLiteralTypeNode extends TypeNode {
                    kind: SyntaxKind.TemplateLiteralType;
                    readonly head: TemplateHead;
                    readonly templateSpans: NodeArray<TemplateLiteralTypeSpan>;
                }
                export interface TemplateLiteralTypeSpan extends TypeNode {
                    readonly kind: SyntaxKind.TemplateLiteralTypeSpan;
                    readonly parent: TemplateLiteralTypeNode;
                    readonly type: TypeNode;
                    readonly literal: TemplateMiddle | TemplateTail;
                }
                export interface Expression extends Node {
                    _expressionBrand: any;
                }
                export interface OmittedExpression extends Expression {
                    readonly kind: SyntaxKind.OmittedExpression;
                }
                export interface PartiallyEmittedExpression extends LeftHandSideExpression {
                    readonly kind: SyntaxKind.PartiallyEmittedExpression;
                    readonly expression: Expression;
                }
                export interface UnaryExpression extends Expression {
                    _unaryExpressionBrand: any;
                }
                /** Deprecated, please use UpdateExpression */
                export type IncrementExpression = UpdateExpression;
                export interface UpdateExpression extends UnaryExpression {
                    _updateExpressionBrand: any;
                }
                export type PrefixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken | SyntaxKind.PlusToken | SyntaxKind.MinusToken | SyntaxKind.TildeToken | SyntaxKind.ExclamationToken;
                export interface PrefixUnaryExpression extends UpdateExpression {
                    readonly kind: SyntaxKind.PrefixUnaryExpression;
                    readonly operator: PrefixUnaryOperator;
                    readonly operand: UnaryExpression;
                }
                export type PostfixUnaryOperator = SyntaxKind.PlusPlusToken | SyntaxKind.MinusMinusToken;
                export interface PostfixUnaryExpression extends UpdateExpression {
                    readonly kind: SyntaxKind.PostfixUnaryExpression;
                    readonly operand: LeftHandSideExpression;
                    readonly operator: PostfixUnaryOperator;
                }
                export interface LeftHandSideExpression extends UpdateExpression {
                    _leftHandSideExpressionBrand: any;
                }
                export interface MemberExpression extends LeftHandSideExpression {
                    _memberExpressionBrand: any;
                }
                export interface PrimaryExpression extends MemberExpression {
                    _primaryExpressionBrand: any;
                }
                export interface NullLiteral extends PrimaryExpression {
                    readonly kind: SyntaxKind.NullKeyword;
                }
                export interface TrueLiteral extends PrimaryExpression {
                    readonly kind: SyntaxKind.TrueKeyword;
                }
                export interface FalseLiteral extends PrimaryExpression {
                    readonly kind: SyntaxKind.FalseKeyword;
                }
                export type BooleanLiteral = TrueLiteral | FalseLiteral;
                export interface ThisExpression extends PrimaryExpression {
                    readonly kind: SyntaxKind.ThisKeyword;
                }
                export interface SuperExpression extends PrimaryExpression {
                    readonly kind: SyntaxKind.SuperKeyword;
                }
                export interface ImportExpression extends PrimaryExpression {
                    readonly kind: SyntaxKind.ImportKeyword;
                }
                export interface DeleteExpression extends UnaryExpression {
                    readonly kind: SyntaxKind.DeleteExpression;
                    readonly expression: UnaryExpression;
                }
                export interface TypeOfExpression extends UnaryExpression {
                    readonly kind: SyntaxKind.TypeOfExpression;
                    readonly expression: UnaryExpression;
                }
                export interface VoidExpression extends UnaryExpression {
                    readonly kind: SyntaxKind.VoidExpression;
                    readonly expression: UnaryExpression;
                }
                export interface AwaitExpression extends UnaryExpression {
                    readonly kind: SyntaxKind.AwaitExpression;
                    readonly expression: UnaryExpression;
                }
                export interface YieldExpression extends Expression {
                    readonly kind: SyntaxKind.YieldExpression;
                    readonly asteriskToken?: AsteriskToken;
                    readonly expression?: Expression;
                }
                export interface SyntheticExpression extends Expression {
                    readonly kind: SyntaxKind.SyntheticExpression;
                    readonly isSpread: boolean;
                    readonly type: Type;
                    readonly tupleNameSource?: ParameterDeclaration | NamedTupleMember;
                }
                export type ExponentiationOperator = SyntaxKind.AsteriskAsteriskToken;
                export type MultiplicativeOperator = SyntaxKind.AsteriskToken | SyntaxKind.SlashToken | SyntaxKind.PercentToken;
                export type MultiplicativeOperatorOrHigher = ExponentiationOperator | MultiplicativeOperator;
                export type AdditiveOperator = SyntaxKind.PlusToken | SyntaxKind.MinusToken;
                export type AdditiveOperatorOrHigher = MultiplicativeOperatorOrHigher | AdditiveOperator;
                export type ShiftOperator = SyntaxKind.LessThanLessThanToken | SyntaxKind.GreaterThanGreaterThanToken | SyntaxKind.GreaterThanGreaterThanGreaterThanToken;
                export type ShiftOperatorOrHigher = AdditiveOperatorOrHigher | ShiftOperator;
                export type RelationalOperator = SyntaxKind.LessThanToken | SyntaxKind.LessThanEqualsToken | SyntaxKind.GreaterThanToken | SyntaxKind.GreaterThanEqualsToken | SyntaxKind.InstanceOfKeyword | SyntaxKind.InKeyword;
                export type RelationalOperatorOrHigher = ShiftOperatorOrHigher | RelationalOperator;
                export type EqualityOperator = SyntaxKind.EqualsEqualsToken | SyntaxKind.EqualsEqualsEqualsToken | SyntaxKind.ExclamationEqualsEqualsToken | SyntaxKind.ExclamationEqualsToken;
                export type EqualityOperatorOrHigher = RelationalOperatorOrHigher | EqualityOperator;
                export type BitwiseOperator = SyntaxKind.AmpersandToken | SyntaxKind.BarToken | SyntaxKind.CaretToken;
                export type BitwiseOperatorOrHigher = EqualityOperatorOrHigher | BitwiseOperator;
                export type LogicalOperator = SyntaxKind.AmpersandAmpersandToken | SyntaxKind.BarBarToken;
                export type LogicalOperatorOrHigher = BitwiseOperatorOrHigher | LogicalOperator;
                export type CompoundAssignmentOperator = SyntaxKind.PlusEqualsToken | SyntaxKind.MinusEqualsToken | SyntaxKind.AsteriskAsteriskEqualsToken | SyntaxKind.AsteriskEqualsToken | SyntaxKind.SlashEqualsToken | SyntaxKind.PercentEqualsToken | SyntaxKind.AmpersandEqualsToken | SyntaxKind.BarEqualsToken | SyntaxKind.CaretEqualsToken | SyntaxKind.LessThanLessThanEqualsToken | SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken | SyntaxKind.GreaterThanGreaterThanEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
                export type AssignmentOperator = SyntaxKind.EqualsToken | CompoundAssignmentOperator;
                export type AssignmentOperatorOrHigher = SyntaxKind.QuestionQuestionToken | LogicalOperatorOrHigher | AssignmentOperator;
                export type BinaryOperator = AssignmentOperatorOrHigher | SyntaxKind.CommaToken;
                export type LogicalOrCoalescingAssignmentOperator = SyntaxKind.AmpersandAmpersandEqualsToken | SyntaxKind.BarBarEqualsToken | SyntaxKind.QuestionQuestionEqualsToken;
                export type BinaryOperatorToken = Token<BinaryOperator>;
                export interface BinaryExpression extends Expression, Declaration {
                    readonly kind: SyntaxKind.BinaryExpression;
                    readonly left: Expression;
                    readonly operatorToken: BinaryOperatorToken;
                    readonly right: Expression;
                }
                export type AssignmentOperatorToken = Token<AssignmentOperator>;
                export interface AssignmentExpression<TOperator extends AssignmentOperatorToken> extends BinaryExpression {
                    readonly left: LeftHandSideExpression;
                    readonly operatorToken: TOperator;
                }
                export interface ObjectDestructuringAssignment extends AssignmentExpression<EqualsToken> {
                    readonly left: ObjectLiteralExpression;
                }
                export interface ArrayDestructuringAssignment extends AssignmentExpression<EqualsToken> {
                    readonly left: ArrayLiteralExpression;
                }
                export type DestructuringAssignment = ObjectDestructuringAssignment | ArrayDestructuringAssignment;
                export type BindingOrAssignmentElement = VariableDeclaration | ParameterDeclaration | ObjectBindingOrAssignmentElement | ArrayBindingOrAssignmentElement;
                export type ObjectBindingOrAssignmentElement = BindingElement | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment;
                export type ArrayBindingOrAssignmentElement = BindingElement | OmittedExpression | SpreadElement | ArrayLiteralExpression | ObjectLiteralExpression | AssignmentExpression<EqualsToken> | Identifier | PropertyAccessExpression | ElementAccessExpression;
                export type BindingOrAssignmentElementRestIndicator = DotDotDotToken | SpreadElement | SpreadAssignment;
                export type BindingOrAssignmentElementTarget = BindingOrAssignmentPattern | Identifier | PropertyAccessExpression | ElementAccessExpression | OmittedExpression;
                export type ObjectBindingOrAssignmentPattern = ObjectBindingPattern | ObjectLiteralExpression;
                export type ArrayBindingOrAssignmentPattern = ArrayBindingPattern | ArrayLiteralExpression;
                export type AssignmentPattern = ObjectLiteralExpression | ArrayLiteralExpression;
                export type BindingOrAssignmentPattern = ObjectBindingOrAssignmentPattern | ArrayBindingOrAssignmentPattern;
                export interface ConditionalExpression extends Expression {
                    readonly kind: SyntaxKind.ConditionalExpression;
                    readonly condition: Expression;
                    readonly questionToken: QuestionToken;
                    readonly whenTrue: Expression;
                    readonly colonToken: ColonToken;
                    readonly whenFalse: Expression;
                }
                export type FunctionBody = Block;
                export type ConciseBody = FunctionBody | Expression;
                export interface FunctionExpression extends PrimaryExpression, FunctionLikeDeclarationBase, JSDocContainer {
                    readonly kind: SyntaxKind.FunctionExpression;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name?: Identifier;
                    readonly body: FunctionBody;
                }
                export interface ArrowFunction extends Expression, FunctionLikeDeclarationBase, JSDocContainer {
                    readonly kind: SyntaxKind.ArrowFunction;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly equalsGreaterThanToken: EqualsGreaterThanToken;
                    readonly body: ConciseBody;
                    readonly name: never;
                }
                export interface LiteralLikeNode extends Node {
                    text: string;
                    isUnterminated?: boolean;
                    hasExtendedUnicodeEscape?: boolean;
                }
                export interface TemplateLiteralLikeNode extends LiteralLikeNode {
                    rawText?: string;
                }
                export interface LiteralExpression extends LiteralLikeNode, PrimaryExpression {
                    _literalExpressionBrand: any;
                }
                export interface RegularExpressionLiteral extends LiteralExpression {
                    readonly kind: SyntaxKind.RegularExpressionLiteral;
                }
                export interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {
                    readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;
                }
                export enum TokenFlags {
                    None = 0,
                    Scientific = 16,
                    Octal = 32,
                    HexSpecifier = 64,
                    BinarySpecifier = 128,
                    OctalSpecifier = 256
                }
                export interface NumericLiteral extends LiteralExpression, Declaration {
                    readonly kind: SyntaxKind.NumericLiteral;
                }
                export interface BigIntLiteral extends LiteralExpression {
                    readonly kind: SyntaxKind.BigIntLiteral;
                }
                export type LiteralToken = NumericLiteral | BigIntLiteral | StringLiteral | JsxText | RegularExpressionLiteral | NoSubstitutionTemplateLiteral;
                export interface TemplateHead extends TemplateLiteralLikeNode {
                    readonly kind: SyntaxKind.TemplateHead;
                    readonly parent: TemplateExpression | TemplateLiteralTypeNode;
                }
                export interface TemplateMiddle extends TemplateLiteralLikeNode {
                    readonly kind: SyntaxKind.TemplateMiddle;
                    readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
                }
                export interface TemplateTail extends TemplateLiteralLikeNode {
                    readonly kind: SyntaxKind.TemplateTail;
                    readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
                }
                export type PseudoLiteralToken = TemplateHead | TemplateMiddle | TemplateTail;
                export type TemplateLiteralToken = NoSubstitutionTemplateLiteral | PseudoLiteralToken;
                export interface TemplateExpression extends PrimaryExpression {
                    readonly kind: SyntaxKind.TemplateExpression;
                    readonly head: TemplateHead;
                    readonly templateSpans: NodeArray<TemplateSpan>;
                }
                export type TemplateLiteral = TemplateExpression | NoSubstitutionTemplateLiteral;
                export interface TemplateSpan extends Node {
                    readonly kind: SyntaxKind.TemplateSpan;
                    readonly parent: TemplateExpression;
                    readonly expression: Expression;
                    readonly literal: TemplateMiddle | TemplateTail;
                }
                export interface ParenthesizedExpression extends PrimaryExpression, JSDocContainer {
                    readonly kind: SyntaxKind.ParenthesizedExpression;
                    readonly expression: Expression;
                }
                export interface ArrayLiteralExpression extends PrimaryExpression {
                    readonly kind: SyntaxKind.ArrayLiteralExpression;
                    readonly elements: NodeArray<Expression>;
                }
                export interface SpreadElement extends Expression {
                    readonly kind: SyntaxKind.SpreadElement;
                    readonly parent: ArrayLiteralExpression | CallExpression | NewExpression;
                    readonly expression: Expression;
                }
                /**
                 * This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to
                 * ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be
                 * JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type
                 * ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)
                 */
                export interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> extends PrimaryExpression, Declaration {
                    readonly properties: NodeArray<T>;
                }
                export interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike> {
                    readonly kind: SyntaxKind.ObjectLiteralExpression;
                }
                export type EntityNameExpression = Identifier | PropertyAccessEntityNameExpression;
                export type EntityNameOrEntityNameExpression = EntityName | EntityNameExpression;
                export type AccessExpression = PropertyAccessExpression | ElementAccessExpression;
                export interface PropertyAccessExpression extends MemberExpression, NamedDeclaration {
                    readonly kind: SyntaxKind.PropertyAccessExpression;
                    readonly expression: LeftHandSideExpression;
                    readonly questionDotToken?: QuestionDotToken;
                    readonly name: MemberName;
                }
                export interface PropertyAccessChain extends PropertyAccessExpression {
                    _optionalChainBrand: any;
                    readonly name: MemberName;
                }
                export interface SuperPropertyAccessExpression extends PropertyAccessExpression {
                    readonly expression: SuperExpression;
                }
                /** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */
                export interface PropertyAccessEntityNameExpression extends PropertyAccessExpression {
                    _propertyAccessExpressionLikeQualifiedNameBrand?: any;
                    readonly expression: EntityNameExpression;
                    readonly name: Identifier;
                }
                export interface ElementAccessExpression extends MemberExpression {
                    readonly kind: SyntaxKind.ElementAccessExpression;
                    readonly expression: LeftHandSideExpression;
                    readonly questionDotToken?: QuestionDotToken;
                    readonly argumentExpression: Expression;
                }
                export interface ElementAccessChain extends ElementAccessExpression {
                    _optionalChainBrand: any;
                }
                export interface SuperElementAccessExpression extends ElementAccessExpression {
                    readonly expression: SuperExpression;
                }
                export type SuperProperty = SuperPropertyAccessExpression | SuperElementAccessExpression;
                export interface CallExpression extends LeftHandSideExpression, Declaration {
                    readonly kind: SyntaxKind.CallExpression;
                    readonly expression: LeftHandSideExpression;
                    readonly questionDotToken?: QuestionDotToken;
                    readonly typeArguments?: NodeArray<TypeNode>;
                    readonly arguments: NodeArray<Expression>;
                }
                export interface CallChain extends CallExpression {
                    _optionalChainBrand: any;
                }
                export type OptionalChain = PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
                export interface SuperCall extends CallExpression {
                    readonly expression: SuperExpression;
                }
                export interface ImportCall extends CallExpression {
                    readonly expression: ImportExpression;
                }
                export interface ExpressionWithTypeArguments extends MemberExpression, NodeWithTypeArguments {
                    readonly kind: SyntaxKind.ExpressionWithTypeArguments;
                    readonly expression: LeftHandSideExpression;
                }
                export interface NewExpression extends PrimaryExpression, Declaration {
                    readonly kind: SyntaxKind.NewExpression;
                    readonly expression: LeftHandSideExpression;
                    readonly typeArguments?: NodeArray<TypeNode>;
                    readonly arguments?: NodeArray<Expression>;
                }
                export interface TaggedTemplateExpression extends MemberExpression {
                    readonly kind: SyntaxKind.TaggedTemplateExpression;
                    readonly tag: LeftHandSideExpression;
                    readonly typeArguments?: NodeArray<TypeNode>;
                    readonly template: TemplateLiteral;
                }
                export type CallLikeExpression = CallExpression | NewExpression | TaggedTemplateExpression | Decorator | JsxOpeningLikeElement;
                export interface AsExpression extends Expression {
                    readonly kind: SyntaxKind.AsExpression;
                    readonly expression: Expression;
                    readonly type: TypeNode;
                }
                export interface TypeAssertion extends UnaryExpression {
                    readonly kind: SyntaxKind.TypeAssertionExpression;
                    readonly type: TypeNode;
                    readonly expression: UnaryExpression;
                }
                export interface SatisfiesExpression extends Expression {
                    readonly kind: SyntaxKind.SatisfiesExpression;
                    readonly expression: Expression;
                    readonly type: TypeNode;
                }
                export type AssertionExpression = TypeAssertion | AsExpression;
                export interface NonNullExpression extends LeftHandSideExpression {
                    readonly kind: SyntaxKind.NonNullExpression;
                    readonly expression: Expression;
                }
                export interface NonNullChain extends NonNullExpression {
                    _optionalChainBrand: any;
                }
                export interface MetaProperty extends PrimaryExpression {
                    readonly kind: SyntaxKind.MetaProperty;
                    readonly keywordToken: SyntaxKind.NewKeyword | SyntaxKind.ImportKeyword;
                    readonly name: Identifier;
                }
                export interface JsxElement extends PrimaryExpression {
                    readonly kind: SyntaxKind.JsxElement;
                    readonly openingElement: JsxOpeningElement;
                    readonly children: NodeArray<JsxChild>;
                    readonly closingElement: JsxClosingElement;
                }
                export type JsxOpeningLikeElement = JsxSelfClosingElement | JsxOpeningElement;
                export type JsxAttributeLike = JsxAttribute | JsxSpreadAttribute;
                export type JsxTagNameExpression = Identifier | ThisExpression | JsxTagNamePropertyAccess;
                export interface JsxTagNamePropertyAccess extends PropertyAccessExpression {
                    readonly expression: JsxTagNameExpression;
                }
                export interface JsxAttributes extends ObjectLiteralExpressionBase<JsxAttributeLike> {
                    readonly kind: SyntaxKind.JsxAttributes;
                    readonly parent: JsxOpeningLikeElement;
                }
                export interface JsxOpeningElement extends Expression {
                    readonly kind: SyntaxKind.JsxOpeningElement;
                    readonly parent: JsxElement;
                    readonly tagName: JsxTagNameExpression;
                    readonly typeArguments?: NodeArray<TypeNode>;
                    readonly attributes: JsxAttributes;
                }
                export interface JsxSelfClosingElement extends PrimaryExpression {
                    readonly kind: SyntaxKind.JsxSelfClosingElement;
                    readonly tagName: JsxTagNameExpression;
                    readonly typeArguments?: NodeArray<TypeNode>;
                    readonly attributes: JsxAttributes;
                }
                export interface JsxFragment extends PrimaryExpression {
                    readonly kind: SyntaxKind.JsxFragment;
                    readonly openingFragment: JsxOpeningFragment;
                    readonly children: NodeArray<JsxChild>;
                    readonly closingFragment: JsxClosingFragment;
                }
                export interface JsxOpeningFragment extends Expression {
                    readonly kind: SyntaxKind.JsxOpeningFragment;
                    readonly parent: JsxFragment;
                }
                export interface JsxClosingFragment extends Expression {
                    readonly kind: SyntaxKind.JsxClosingFragment;
                    readonly parent: JsxFragment;
                }
                export interface JsxAttribute extends ObjectLiteralElement {
                    readonly kind: SyntaxKind.JsxAttribute;
                    readonly parent: JsxAttributes;
                    readonly name: Identifier;
                    readonly initializer?: JsxAttributeValue;
                }
                export type JsxAttributeValue = StringLiteral | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
                export interface JsxSpreadAttribute extends ObjectLiteralElement {
                    readonly kind: SyntaxKind.JsxSpreadAttribute;
                    readonly parent: JsxAttributes;
                    readonly expression: Expression;
                }
                export interface JsxClosingElement extends Node {
                    readonly kind: SyntaxKind.JsxClosingElement;
                    readonly parent: JsxElement;
                    readonly tagName: JsxTagNameExpression;
                }
                export interface JsxExpression extends Expression {
                    readonly kind: SyntaxKind.JsxExpression;
                    readonly parent: JsxElement | JsxFragment | JsxAttributeLike;
                    readonly dotDotDotToken?: Token<SyntaxKind.DotDotDotToken>;
                    readonly expression?: Expression;
                }
                export interface JsxText extends LiteralLikeNode {
                    readonly kind: SyntaxKind.JsxText;
                    readonly parent: JsxElement | JsxFragment;
                    readonly containsOnlyTriviaWhiteSpaces: boolean;
                }
                export type JsxChild = JsxText | JsxExpression | JsxElement | JsxSelfClosingElement | JsxFragment;
                export interface Statement extends Node, JSDocContainer {
                    _statementBrand: any;
                }
                export interface NotEmittedStatement extends Statement {
                    readonly kind: SyntaxKind.NotEmittedStatement;
                }
                /**
                 * A list of comma-separated expressions. This node is only created by transformations.
                 */
                export interface CommaListExpression extends Expression {
                    readonly kind: SyntaxKind.CommaListExpression;
                    readonly elements: NodeArray<Expression>;
                }
                export interface EmptyStatement extends Statement {
                    readonly kind: SyntaxKind.EmptyStatement;
                }
                export interface DebuggerStatement extends Statement {
                    readonly kind: SyntaxKind.DebuggerStatement;
                }
                export interface MissingDeclaration extends DeclarationStatement {
                    readonly kind: SyntaxKind.MissingDeclaration;
                    readonly name?: Identifier;
                }
                export type BlockLike = SourceFile | Block | ModuleBlock | CaseOrDefaultClause;
                export interface Block extends Statement {
                    readonly kind: SyntaxKind.Block;
                    readonly statements: NodeArray<Statement>;
                }
                export interface VariableStatement extends Statement {
                    readonly kind: SyntaxKind.VariableStatement;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly declarationList: VariableDeclarationList;
                }
                export interface ExpressionStatement extends Statement {
                    readonly kind: SyntaxKind.ExpressionStatement;
                    readonly expression: Expression;
                }
                export interface IfStatement extends Statement {
                    readonly kind: SyntaxKind.IfStatement;
                    readonly expression: Expression;
                    readonly thenStatement: Statement;
                    readonly elseStatement?: Statement;
                }
                export interface IterationStatement extends Statement {
                    readonly statement: Statement;
                }
                export interface DoStatement extends IterationStatement {
                    readonly kind: SyntaxKind.DoStatement;
                    readonly expression: Expression;
                }
                export interface WhileStatement extends IterationStatement {
                    readonly kind: SyntaxKind.WhileStatement;
                    readonly expression: Expression;
                }
                export type ForInitializer = VariableDeclarationList | Expression;
                export interface ForStatement extends IterationStatement {
                    readonly kind: SyntaxKind.ForStatement;
                    readonly initializer?: ForInitializer;
                    readonly condition?: Expression;
                    readonly incrementor?: Expression;
                }
                export type ForInOrOfStatement = ForInStatement | ForOfStatement;
                export interface ForInStatement extends IterationStatement {
                    readonly kind: SyntaxKind.ForInStatement;
                    readonly initializer: ForInitializer;
                    readonly expression: Expression;
                }
                export interface ForOfStatement extends IterationStatement {
                    readonly kind: SyntaxKind.ForOfStatement;
                    readonly awaitModifier?: AwaitKeyword;
                    readonly initializer: ForInitializer;
                    readonly expression: Expression;
                }
                export interface BreakStatement extends Statement {
                    readonly kind: SyntaxKind.BreakStatement;
                    readonly label?: Identifier;
                }
                export interface ContinueStatement extends Statement {
                    readonly kind: SyntaxKind.ContinueStatement;
                    readonly label?: Identifier;
                }
                export type BreakOrContinueStatement = BreakStatement | ContinueStatement;
                export interface ReturnStatement extends Statement {
                    readonly kind: SyntaxKind.ReturnStatement;
                    readonly expression?: Expression;
                }
                export interface WithStatement extends Statement {
                    readonly kind: SyntaxKind.WithStatement;
                    readonly expression: Expression;
                    readonly statement: Statement;
                }
                export interface SwitchStatement extends Statement {
                    readonly kind: SyntaxKind.SwitchStatement;
                    readonly expression: Expression;
                    readonly caseBlock: CaseBlock;
                    possiblyExhaustive?: boolean;
                }
                export interface CaseBlock extends Node {
                    readonly kind: SyntaxKind.CaseBlock;
                    readonly parent: SwitchStatement;
                    readonly clauses: NodeArray<CaseOrDefaultClause>;
                }
                export interface CaseClause extends Node, JSDocContainer {
                    readonly kind: SyntaxKind.CaseClause;
                    readonly parent: CaseBlock;
                    readonly expression: Expression;
                    readonly statements: NodeArray<Statement>;
                }
                export interface DefaultClause extends Node {
                    readonly kind: SyntaxKind.DefaultClause;
                    readonly parent: CaseBlock;
                    readonly statements: NodeArray<Statement>;
                }
                export type CaseOrDefaultClause = CaseClause | DefaultClause;
                export interface LabeledStatement extends Statement {
                    readonly kind: SyntaxKind.LabeledStatement;
                    readonly label: Identifier;
                    readonly statement: Statement;
                }
                export interface ThrowStatement extends Statement {
                    readonly kind: SyntaxKind.ThrowStatement;
                    readonly expression: Expression;
                }
                export interface TryStatement extends Statement {
                    readonly kind: SyntaxKind.TryStatement;
                    readonly tryBlock: Block;
                    readonly catchClause?: CatchClause;
                    readonly finallyBlock?: Block;
                }
                export interface CatchClause extends Node {
                    readonly kind: SyntaxKind.CatchClause;
                    readonly parent: TryStatement;
                    readonly variableDeclaration?: VariableDeclaration;
                    readonly block: Block;
                }
                export type ObjectTypeDeclaration = ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode;
                export type DeclarationWithTypeParameters = DeclarationWithTypeParameterChildren | JSDocTypedefTag | JSDocCallbackTag | JSDocSignature;
                export type DeclarationWithTypeParameterChildren = SignatureDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTemplateTag;
                export interface ClassLikeDeclarationBase extends NamedDeclaration, JSDocContainer {
                    readonly kind: SyntaxKind.ClassDeclaration | SyntaxKind.ClassExpression;
                    readonly name?: Identifier;
                    readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
                    readonly heritageClauses?: NodeArray<HeritageClause>;
                    readonly members: NodeArray<ClassElement>;
                }
                export interface ClassDeclaration extends ClassLikeDeclarationBase, DeclarationStatement {
                    readonly kind: SyntaxKind.ClassDeclaration;
                    readonly modifiers?: NodeArray<ModifierLike>;
                    /** May be undefined in `export default class { ... }`. */
                    readonly name?: Identifier;
                }
                export interface ClassExpression extends ClassLikeDeclarationBase, PrimaryExpression {
                    readonly kind: SyntaxKind.ClassExpression;
                    readonly modifiers?: NodeArray<ModifierLike>;
                }
                export type ClassLikeDeclaration = ClassDeclaration | ClassExpression;
                export interface ClassElement extends NamedDeclaration {
                    _classElementBrand: any;
                    readonly name?: PropertyName;
                }
                export interface TypeElement extends NamedDeclaration {
                    _typeElementBrand: any;
                    readonly name?: PropertyName;
                    readonly questionToken?: QuestionToken | undefined;
                }
                export interface InterfaceDeclaration extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.InterfaceDeclaration;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: Identifier;
                    readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
                    readonly heritageClauses?: NodeArray<HeritageClause>;
                    readonly members: NodeArray<TypeElement>;
                }
                export interface HeritageClause extends Node {
                    readonly kind: SyntaxKind.HeritageClause;
                    readonly parent: InterfaceDeclaration | ClassLikeDeclaration;
                    readonly token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword;
                    readonly types: NodeArray<ExpressionWithTypeArguments>;
                }
                export interface TypeAliasDeclaration extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.TypeAliasDeclaration;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: Identifier;
                    readonly typeParameters?: NodeArray<TypeParameterDeclaration>;
                    readonly type: TypeNode;
                }
                export interface EnumMember extends NamedDeclaration, JSDocContainer {
                    readonly kind: SyntaxKind.EnumMember;
                    readonly parent: EnumDeclaration;
                    readonly name: PropertyName;
                    readonly initializer?: Expression;
                }
                export interface EnumDeclaration extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.EnumDeclaration;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: Identifier;
                    readonly members: NodeArray<EnumMember>;
                }
                export type ModuleName = Identifier | StringLiteral;
                export type ModuleBody = NamespaceBody | JSDocNamespaceBody;
                export interface ModuleDeclaration extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.ModuleDeclaration;
                    readonly parent: ModuleBody | SourceFile;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: ModuleName;
                    readonly body?: ModuleBody | JSDocNamespaceDeclaration;
                }
                export type NamespaceBody = ModuleBlock | NamespaceDeclaration;
                export interface NamespaceDeclaration extends ModuleDeclaration {
                    readonly name: Identifier;
                    readonly body: NamespaceBody;
                }
                export type JSDocNamespaceBody = Identifier | JSDocNamespaceDeclaration;
                export interface JSDocNamespaceDeclaration extends ModuleDeclaration {
                    readonly name: Identifier;
                    readonly body?: JSDocNamespaceBody;
                }
                export interface ModuleBlock extends Node, Statement {
                    readonly kind: SyntaxKind.ModuleBlock;
                    readonly parent: ModuleDeclaration;
                    readonly statements: NodeArray<Statement>;
                }
                export type ModuleReference = EntityName | ExternalModuleReference;
                /**
                 * One of:
                 * - import x = require("mod");
                 * - import x = M.x;
                 */
                export interface ImportEqualsDeclaration extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.ImportEqualsDeclaration;
                    readonly parent: SourceFile | ModuleBlock;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly name: Identifier;
                    readonly isTypeOnly: boolean;
                    readonly moduleReference: ModuleReference;
                }
                export interface ExternalModuleReference extends Node {
                    readonly kind: SyntaxKind.ExternalModuleReference;
                    readonly parent: ImportEqualsDeclaration;
                    readonly expression: Expression;
                }
                export interface ImportDeclaration extends Statement {
                    readonly kind: SyntaxKind.ImportDeclaration;
                    readonly parent: SourceFile | ModuleBlock;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly importClause?: ImportClause;
                    /** If this is not a StringLiteral it will be a grammar error. */
                    readonly moduleSpecifier: Expression;
                    readonly assertClause?: AssertClause;
                }
                export type NamedImportBindings = NamespaceImport | NamedImports;
                export type NamedExportBindings = NamespaceExport | NamedExports;
                export interface ImportClause extends NamedDeclaration {
                    readonly kind: SyntaxKind.ImportClause;
                    readonly parent: ImportDeclaration;
                    readonly isTypeOnly: boolean;
                    readonly name?: Identifier;
                    readonly namedBindings?: NamedImportBindings;
                }
                export type AssertionKey = Identifier | StringLiteral;
                export interface AssertEntry extends Node {
                    readonly kind: SyntaxKind.AssertEntry;
                    readonly parent: AssertClause;
                    readonly name: AssertionKey;
                    readonly value: Expression;
                }
                export interface AssertClause extends Node {
                    readonly kind: SyntaxKind.AssertClause;
                    readonly parent: ImportDeclaration | ExportDeclaration;
                    readonly elements: NodeArray<AssertEntry>;
                    readonly multiLine?: boolean;
                }
                export interface NamespaceImport extends NamedDeclaration {
                    readonly kind: SyntaxKind.NamespaceImport;
                    readonly parent: ImportClause;
                    readonly name: Identifier;
                }
                export interface NamespaceExport extends NamedDeclaration {
                    readonly kind: SyntaxKind.NamespaceExport;
                    readonly parent: ExportDeclaration;
                    readonly name: Identifier;
                }
                export interface NamespaceExportDeclaration extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.NamespaceExportDeclaration;
                    readonly name: Identifier;
                }
                export interface ExportDeclaration extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.ExportDeclaration;
                    readonly parent: SourceFile | ModuleBlock;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly isTypeOnly: boolean;
                    /** Will not be assigned in the case of `export * from "foo";` */
                    readonly exportClause?: NamedExportBindings;
                    /** If this is not a StringLiteral it will be a grammar error. */
                    readonly moduleSpecifier?: Expression;
                    readonly assertClause?: AssertClause;
                }
                export interface NamedImports extends Node {
                    readonly kind: SyntaxKind.NamedImports;
                    readonly parent: ImportClause;
                    readonly elements: NodeArray<ImportSpecifier>;
                }
                export interface NamedExports extends Node {
                    readonly kind: SyntaxKind.NamedExports;
                    readonly parent: ExportDeclaration;
                    readonly elements: NodeArray<ExportSpecifier>;
                }
                export type NamedImportsOrExports = NamedImports | NamedExports;
                export interface ImportSpecifier extends NamedDeclaration {
                    readonly kind: SyntaxKind.ImportSpecifier;
                    readonly parent: NamedImports;
                    readonly propertyName?: Identifier;
                    readonly name: Identifier;
                    readonly isTypeOnly: boolean;
                }
                export interface ExportSpecifier extends NamedDeclaration, JSDocContainer {
                    readonly kind: SyntaxKind.ExportSpecifier;
                    readonly parent: NamedExports;
                    readonly isTypeOnly: boolean;
                    readonly propertyName?: Identifier;
                    readonly name: Identifier;
                }
                export type ImportOrExportSpecifier = ImportSpecifier | ExportSpecifier;
                export type TypeOnlyCompatibleAliasDeclaration = ImportClause | ImportEqualsDeclaration | NamespaceImport | ImportOrExportSpecifier;
                export type TypeOnlyAliasDeclaration = (ImportClause & {
                    readonly isTypeOnly: true;
                    readonly name: Identifier;
                }) | (ImportEqualsDeclaration & {
                    readonly isTypeOnly: true;
                }) | (NamespaceImport & {
                    readonly parent: ImportClause & {
                        readonly isTypeOnly: true;
                    };
                }) | (ImportSpecifier & ({
                    readonly isTypeOnly: true;
                } | {
                    readonly parent: NamedImports & {
                        readonly parent: ImportClause & {
                            readonly isTypeOnly: true;
                        };
                    };
                })) | (ExportSpecifier & ({
                    readonly isTypeOnly: true;
                } | {
                    readonly parent: NamedExports & {
                        readonly parent: ExportDeclaration & {
                            readonly isTypeOnly: true;
                        };
                    };
                }));
                /**
                 * This is either an `export =` or an `export default` declaration.
                 * Unless `isExportEquals` is set, this node was parsed as an `export default`.
                 */
                export interface ExportAssignment extends DeclarationStatement, JSDocContainer {
                    readonly kind: SyntaxKind.ExportAssignment;
                    readonly parent: SourceFile;
                    readonly modifiers?: NodeArray<Modifier>;
                    readonly isExportEquals?: boolean;
                    readonly expression: Expression;
                }
                export interface FileReference extends TextRange {
                    fileName: string;
                    resolutionMode?: SourceFile["impliedNodeFormat"];
                }
                export interface CheckJsDirective extends TextRange {
                    enabled: boolean;
                }
                export type CommentKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia;
                export interface CommentRange extends TextRange {
                    hasTrailingNewLine?: boolean;
                    kind: CommentKind;
                }
                export interface SynthesizedComment extends CommentRange {
                    text: string;
                    pos: -1;
                    end: -1;
                    hasLeadingNewline?: boolean;
                }
                export interface JSDocTypeExpression extends TypeNode {
                    readonly kind: SyntaxKind.JSDocTypeExpression;
                    readonly type: TypeNode;
                }
                export interface JSDocNameReference extends Node {
                    readonly kind: SyntaxKind.JSDocNameReference;
                    readonly name: EntityName | JSDocMemberName;
                }
                /** Class#method reference in JSDoc */
                export interface JSDocMemberName extends Node {
                    readonly kind: SyntaxKind.JSDocMemberName;
                    readonly left: EntityName | JSDocMemberName;
                    readonly right: Identifier;
                }
                export interface JSDocType extends TypeNode {
                    _jsDocTypeBrand: any;
                }
                export interface JSDocAllType extends JSDocType {
                    readonly kind: SyntaxKind.JSDocAllType;
                }
                export interface JSDocUnknownType extends JSDocType {
                    readonly kind: SyntaxKind.JSDocUnknownType;
                }
                export interface JSDocNonNullableType extends JSDocType {
                    readonly kind: SyntaxKind.JSDocNonNullableType;
                    readonly type: TypeNode;
                    readonly postfix: boolean;
                }
                export interface JSDocNullableType extends JSDocType {
                    readonly kind: SyntaxKind.JSDocNullableType;
                    readonly type: TypeNode;
                    readonly postfix: boolean;
                }
                export interface JSDocOptionalType extends JSDocType {
                    readonly kind: SyntaxKind.JSDocOptionalType;
                    readonly type: TypeNode;
                }
                export interface JSDocFunctionType extends JSDocType, SignatureDeclarationBase {
                    readonly kind: SyntaxKind.JSDocFunctionType;
                }
                export interface JSDocVariadicType extends JSDocType {
                    readonly kind: SyntaxKind.JSDocVariadicType;
                    readonly type: TypeNode;
                }
                export interface JSDocNamepathType extends JSDocType {
                    readonly kind: SyntaxKind.JSDocNamepathType;
                    readonly type: TypeNode;
                }
                export type JSDocTypeReferencingNode = JSDocVariadicType | JSDocOptionalType | JSDocNullableType | JSDocNonNullableType;
                export interface JSDoc extends Node {
                    readonly kind: SyntaxKind.JSDoc;
                    readonly parent: HasJSDoc;
                    readonly tags?: NodeArray<JSDocTag>;
                    readonly comment?: string | NodeArray<JSDocComment>;
                }
                export interface JSDocTag extends Node {
                    readonly parent: JSDoc | JSDocTypeLiteral;
                    readonly tagName: Identifier;
                    readonly comment?: string | NodeArray<JSDocComment>;
                }
                export interface JSDocLink extends Node {
                    readonly kind: SyntaxKind.JSDocLink;
                    readonly name?: EntityName | JSDocMemberName;
                    text: string;
                }
                export interface JSDocLinkCode extends Node {
                    readonly kind: SyntaxKind.JSDocLinkCode;
                    readonly name?: EntityName | JSDocMemberName;
                    text: string;
                }
                export interface JSDocLinkPlain extends Node {
                    readonly kind: SyntaxKind.JSDocLinkPlain;
                    readonly name?: EntityName | JSDocMemberName;
                    text: string;
                }
                export type JSDocComment = JSDocText | JSDocLink | JSDocLinkCode | JSDocLinkPlain;
                export interface JSDocText extends Node {
                    readonly kind: SyntaxKind.JSDocText;
                    text: string;
                }
                export interface JSDocUnknownTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocTag;
                }
                /**
                 * Note that `@extends` is a synonym of `@augments`.
                 * Both tags are represented by this interface.
                 */
                export interface JSDocAugmentsTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocAugmentsTag;
                    readonly class: ExpressionWithTypeArguments & {
                        readonly expression: Identifier | PropertyAccessEntityNameExpression;
                    };
                }
                export interface JSDocImplementsTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocImplementsTag;
                    readonly class: ExpressionWithTypeArguments & {
                        readonly expression: Identifier | PropertyAccessEntityNameExpression;
                    };
                }
                export interface JSDocAuthorTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocAuthorTag;
                }
                export interface JSDocDeprecatedTag extends JSDocTag {
                    kind: SyntaxKind.JSDocDeprecatedTag;
                }
                export interface JSDocClassTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocClassTag;
                }
                export interface JSDocPublicTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocPublicTag;
                }
                export interface JSDocPrivateTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocPrivateTag;
                }
                export interface JSDocProtectedTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocProtectedTag;
                }
                export interface JSDocReadonlyTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocReadonlyTag;
                }
                export interface JSDocOverrideTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocOverrideTag;
                }
                export interface JSDocEnumTag extends JSDocTag, Declaration {
                    readonly kind: SyntaxKind.JSDocEnumTag;
                    readonly parent: JSDoc;
                    readonly typeExpression: JSDocTypeExpression;
                }
                export interface JSDocThisTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocThisTag;
                    readonly typeExpression: JSDocTypeExpression;
                }
                export interface JSDocTemplateTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocTemplateTag;
                    readonly constraint: JSDocTypeExpression | undefined;
                    readonly typeParameters: NodeArray<TypeParameterDeclaration>;
                }
                export interface JSDocSeeTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocSeeTag;
                    readonly name?: JSDocNameReference;
                }
                export interface JSDocReturnTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocReturnTag;
                    readonly typeExpression?: JSDocTypeExpression;
                }
                export interface JSDocTypeTag extends JSDocTag {
                    readonly kind: SyntaxKind.JSDocTypeTag;
                    readonly typeExpression: JSDocTypeExpression;
                }
                export interface JSDocTypedefTag extends JSDocTag, NamedDeclaration {
                    readonly kind: SyntaxKind.JSDocTypedefTag;
                    readonly parent: JSDoc;
                    readonly fullName?: JSDocNamespaceDeclaration | Identifier;
                    readonly name?: Identifier;
                    readonly typeExpression?: JSDocTypeExpression | JSDocTypeLiteral;
                }
                export interface JSDocCallbackTag extends JSDocTag, NamedDeclaration {
                    readonly kind: SyntaxKind.JSDocCallbackTag;
                    readonly parent: JSDoc;
                    readonly fullName?: JSDocNamespaceDeclaration | Identifier;
                    readonly name?: Identifier;
                    readonly typeExpression: JSDocSignature;
                }
                export interface JSDocSignature extends JSDocType, Declaration {
                    readonly kind: SyntaxKind.JSDocSignature;
                    readonly typeParameters?: readonly JSDocTemplateTag[];
                    readonly parameters: readonly JSDocParameterTag[];
                    readonly type: JSDocReturnTag | undefined;
                }
                export interface JSDocPropertyLikeTag extends JSDocTag, Declaration {
                    readonly parent: JSDoc;
                    readonly name: EntityName;
                    readonly typeExpression?: JSDocTypeExpression;
                    /** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */
                    readonly isNameFirst: boolean;
                    readonly isBracketed: boolean;
                }
                export interface JSDocPropertyTag extends JSDocPropertyLikeTag {
                    readonly kind: SyntaxKind.JSDocPropertyTag;
                }
                export interface JSDocParameterTag extends JSDocPropertyLikeTag {
                    readonly kind: SyntaxKind.JSDocParameterTag;
                }
                export interface JSDocTypeLiteral extends JSDocType {
                    readonly kind: SyntaxKind.JSDocTypeLiteral;
                    readonly jsDocPropertyTags?: readonly JSDocPropertyLikeTag[];
                    /** If true, then this type literal represents an *array* of its type. */
                    readonly isArrayType: boolean;
                }
                export enum FlowFlags {
                    Unreachable = 1,
                    Start = 2,
                    BranchLabel = 4,
                    LoopLabel = 8,
                    Assignment = 16,
                    TrueCondition = 32,
                    FalseCondition = 64,
                    SwitchClause = 128,
                    ArrayMutation = 256,
                    Call = 512,
                    ReduceLabel = 1024,
                    Referenced = 2048,
                    Shared = 4096,
                    Label = 12,
                    Condition = 96
                }
                export type FlowNode = FlowStart | FlowLabel | FlowAssignment | FlowCondition | FlowSwitchClause | FlowArrayMutation | FlowCall | FlowReduceLabel;
                export interface FlowNodeBase {
                    flags: FlowFlags;
                    id?: number;
                }
                export interface FlowStart extends FlowNodeBase {
                    node?: FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;
                }
                export interface FlowLabel extends FlowNodeBase {
                    antecedents: FlowNode[] | undefined;
                }
                export interface FlowAssignment extends FlowNodeBase {
                    node: Expression | VariableDeclaration | BindingElement;
                    antecedent: FlowNode;
                }
                export interface FlowCall extends FlowNodeBase {
                    node: CallExpression;
                    antecedent: FlowNode;
                }
                export interface FlowCondition extends FlowNodeBase {
                    node: Expression;
                    antecedent: FlowNode;
                }
                export interface FlowSwitchClause extends FlowNodeBase {
                    switchStatement: SwitchStatement;
                    clauseStart: number;
                    clauseEnd: number;
                    antecedent: FlowNode;
                }
                export interface FlowArrayMutation extends FlowNodeBase {
                    node: CallExpression | BinaryExpression;
                    antecedent: FlowNode;
                }
                export interface FlowReduceLabel extends FlowNodeBase {
                    target: FlowLabel;
                    antecedents: FlowNode[];
                    antecedent: FlowNode;
                }
                export type FlowType = Type | IncompleteType;
                export interface IncompleteType {
                    flags: TypeFlags;
                    type: Type;
                }
                export interface AmdDependency {
                    path: string;
                    name?: string;
                }
                /**
                 * Subset of properties from SourceFile that are used in multiple utility functions
                 */
                export interface SourceFileLike {
                    readonly text: string;
                }
                export interface SourceFileLike {
                    getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
                }
                export interface SourceFile extends Declaration {
                    readonly kind: SyntaxKind.SourceFile;
                    readonly statements: NodeArray<Statement>;
                    readonly endOfFileToken: Token<SyntaxKind.EndOfFileToken>;
                    fileName: string;
                    text: string;
                    amdDependencies: readonly AmdDependency[];
                    moduleName?: string;
                    referencedFiles: readonly FileReference[];
                    typeReferenceDirectives: readonly FileReference[];
                    libReferenceDirectives: readonly FileReference[];
                    languageVariant: LanguageVariant;
                    isDeclarationFile: boolean;
                    /**
                     * lib.d.ts should have a reference comment like
                     *
                     *  /// <reference no-default-lib="true"/>
                     *
                     * If any other file has this comment, it signals not to include lib.d.ts
                     * because this containing file is intended to act as a default library.
                     */
                    hasNoDefaultLib: boolean;
                    languageVersion: ScriptTarget;
                    /**
                     * When `module` is `Node16` or `NodeNext`, this field controls whether the
                     * source file in question is an ESNext-output-format file, or a CommonJS-output-format
                     * module. This is derived by the module resolver as it looks up the file, since
                     * it is derived from either the file extension of the module, or the containing
                     * `package.json` context, and affects both checking and emit.
                     *
                     * It is _public_ so that (pre)transformers can set this field,
                     * since it switches the builtin `node` module transform. Generally speaking, if unset,
                     * the field is treated as though it is `ModuleKind.CommonJS`.
                     *
                     * Note that this field is only set by the module resolution process when
                     * `moduleResolution` is `Node16` or `NodeNext`, which is implied by the `module` setting
                     * of `Node16` or `NodeNext`, respectively, but may be overriden (eg, by a `moduleResolution`
                     * of `node`). If so, this field will be unset and source files will be considered to be
                     * CommonJS-output-format by the node module transformer and type checker, regardless of extension or context.
                     */
                    impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;
                }
                export interface SourceFile {
                    getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
                    getLineEndOfPosition(pos: number): number;
                    getLineStarts(): readonly number[];
                    getPositionOfLineAndCharacter(line: number, character: number): number;
                    update(newText: string, textChangeRange: TextChangeRange): SourceFile;
                }
                export interface Bundle extends Node {
                    readonly kind: SyntaxKind.Bundle;
                    readonly prepends: readonly (InputFiles | UnparsedSource)[];
                    readonly sourceFiles: readonly SourceFile[];
                }
                export interface InputFiles extends Node {
                    readonly kind: SyntaxKind.InputFiles;
                    javascriptPath?: string;
                    javascriptText: string;
                    javascriptMapPath?: string;
                    javascriptMapText?: string;
                    declarationPath?: string;
                    declarationText: string;
                    declarationMapPath?: string;
                    declarationMapText?: string;
                }
                export interface UnparsedSource extends Node {
                    readonly kind: SyntaxKind.UnparsedSource;
                    fileName: string;
                    text: string;
                    readonly prologues: readonly UnparsedPrologue[];
                    helpers: readonly UnscopedEmitHelper[] | undefined;
                    referencedFiles: readonly FileReference[];
                    typeReferenceDirectives: readonly FileReference[] | undefined;
                    libReferenceDirectives: readonly FileReference[];
                    hasNoDefaultLib?: boolean;
                    sourceMapPath?: string;
                    sourceMapText?: string;
                    readonly syntheticReferences?: readonly UnparsedSyntheticReference[];
                    readonly texts: readonly UnparsedSourceText[];
                }
                export type UnparsedSourceText = UnparsedPrepend | UnparsedTextLike;
                export type UnparsedNode = UnparsedPrologue | UnparsedSourceText | UnparsedSyntheticReference;
                export interface UnparsedSection extends Node {
                    readonly kind: SyntaxKind;
                    readonly parent: UnparsedSource;
                    readonly data?: string;
                }
                export interface UnparsedPrologue extends UnparsedSection {
                    readonly kind: SyntaxKind.UnparsedPrologue;
                    readonly parent: UnparsedSource;
                    readonly data: string;
                }
                export interface UnparsedPrepend extends UnparsedSection {
                    readonly kind: SyntaxKind.UnparsedPrepend;
                    readonly parent: UnparsedSource;
                    readonly data: string;
                    readonly texts: readonly UnparsedTextLike[];
                }
                export interface UnparsedTextLike extends UnparsedSection {
                    readonly kind: SyntaxKind.UnparsedText | SyntaxKind.UnparsedInternalText;
                    readonly parent: UnparsedSource;
                }
                export interface UnparsedSyntheticReference extends UnparsedSection {
                    readonly kind: SyntaxKind.UnparsedSyntheticReference;
                    readonly parent: UnparsedSource;
                }
                export interface JsonSourceFile extends SourceFile {
                    readonly statements: NodeArray<JsonObjectExpressionStatement>;
                }
                export interface TsConfigSourceFile extends JsonSourceFile {
                    extendedSourceFiles?: string[];
                }
                export interface JsonMinusNumericLiteral extends PrefixUnaryExpression {
                    readonly kind: SyntaxKind.PrefixUnaryExpression;
                    readonly operator: SyntaxKind.MinusToken;
                    readonly operand: NumericLiteral;
                }
                export type JsonObjectExpression = ObjectLiteralExpression | ArrayLiteralExpression | JsonMinusNumericLiteral | NumericLiteral | StringLiteral | BooleanLiteral | NullLiteral;
                export interface JsonObjectExpressionStatement extends ExpressionStatement {
                    readonly expression: JsonObjectExpression;
                }
                export interface ScriptReferenceHost {
                    getCompilerOptions(): CompilerOptions;
                    getSourceFile(fileName: string): SourceFile | undefined;
                    getSourceFileByPath(path: Path): SourceFile | undefined;
                    getCurrentDirectory(): string;
                }
                export interface ParseConfigHost {
                    useCaseSensitiveFileNames: boolean;
                    readDirectory(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): readonly string[];
                    /**
                     * Gets a value indicating whether the specified path exists and is a file.
                     * @param path The path to test.
                     */
                    fileExists(path: string): boolean;
                    readFile(path: string): string | undefined;
                    trace?(s: string): void;
                }
                /**
                 * Branded string for keeping track of when we've turned an ambiguous path
                 * specified like "./blah" to an absolute path to an actual
                 * tsconfig file, e.g. "/root/blah/tsconfig.json"
                 */
                export type ResolvedConfigFileName = string & {
                    _isResolvedConfigFileName: never;
                };
                export interface WriteFileCallbackData {
                }
                export type WriteFileCallback = (fileName: string, text: string, writeByteOrderMark: boolean, onError?: (message: string) => void, sourceFiles?: readonly SourceFile[], data?: WriteFileCallbackData) => void;
                export class OperationCanceledException {
                }
                export interface CancellationToken {
                    isCancellationRequested(): boolean;
                    /** @throws OperationCanceledException if isCancellationRequested is true */
                    throwIfCancellationRequested(): void;
                }
                export interface Program extends ScriptReferenceHost {
                    getCurrentDirectory(): string;
                    /**
                     * Get a list of root file names that were passed to a 'createProgram'
                     */
                    getRootFileNames(): readonly string[];
                    /**
                     * Get a list of files in the program
                     */
                    getSourceFiles(): readonly SourceFile[];
                    /**
                     * Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then
                     * the JavaScript and declaration files will be produced for all the files in this program.
                     * If targetSourceFile is specified, then only the JavaScript and declaration for that
                     * specific file will be generated.
                     *
                     * If writeFile is not specified then the writeFile callback from the compiler host will be
                     * used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter
                     * will be invoked when writing the JavaScript and declaration files.
                     */
                    emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
                    getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
                    getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
                    getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
                    /** The first time this is called, it will return global diagnostics (no location). */
                    getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
                    getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
                    getConfigFileParsingDiagnostics(): readonly Diagnostic[];
                    /**
                     * Gets a type checker that can be used to semantically analyze source files in the program.
                     */
                    getTypeChecker(): TypeChecker;
                    getNodeCount(): number;
                    getIdentifierCount(): number;
                    getSymbolCount(): number;
                    getTypeCount(): number;
                    getInstantiationCount(): number;
                    getRelationCacheSizes(): {
                        assignable: number;
                        identity: number;
                        subtype: number;
                        strictSubtype: number;
                    };
                    isSourceFileFromExternalLibrary(file: SourceFile): boolean;
                    isSourceFileDefaultLibrary(file: SourceFile): boolean;
                    getProjectReferences(): readonly ProjectReference[] | undefined;
                    getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;
                }
                export interface ResolvedProjectReference {
                    commandLine: ParsedCommandLine;
                    sourceFile: SourceFile;
                    references?: readonly (ResolvedProjectReference | undefined)[];
                }
                export type CustomTransformerFactory = (context: TransformationContext) => CustomTransformer;
                export interface CustomTransformer {
                    transformSourceFile(node: SourceFile): SourceFile;
                    transformBundle(node: Bundle): Bundle;
                }
                export interface CustomTransformers {
                    /** Custom transformers to evaluate before built-in .js transformations. */
                    before?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
                    /** Custom transformers to evaluate after built-in .js transformations. */
                    after?: (TransformerFactory<SourceFile> | CustomTransformerFactory)[];
                    /** Custom transformers to evaluate after built-in .d.ts transformations. */
                    afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];
                }
                export interface SourceMapSpan {
                    /** Line number in the .js file. */
                    emittedLine: number;
                    /** Column number in the .js file. */
                    emittedColumn: number;
                    /** Line number in the .ts file. */
                    sourceLine: number;
                    /** Column number in the .ts file. */
                    sourceColumn: number;
                    /** Optional name (index into names array) associated with this span. */
                    nameIndex?: number;
                    /** .ts file (index into sources array) associated with this span */
                    sourceIndex: number;
                }
                /** Return code used by getEmitOutput function to indicate status of the function */
                export enum ExitStatus {
                    Success = 0,
                    DiagnosticsPresent_OutputsSkipped = 1,
                    DiagnosticsPresent_OutputsGenerated = 2,
                    InvalidProject_OutputsSkipped = 3,
                    ProjectReferenceCycle_OutputsSkipped = 4,
                    /** @deprecated Use ProjectReferenceCycle_OutputsSkipped instead. */
                    ProjectReferenceCycle_OutputsSkupped = 4
                }
                export interface EmitResult {
                    emitSkipped: boolean;
                    /** Contains declaration emit diagnostics */
                    diagnostics: readonly Diagnostic[];
                    emittedFiles?: string[];
                }
                export interface TypeChecker {
                    getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;
                    getDeclaredTypeOfSymbol(symbol: Symbol): Type;
                    getPropertiesOfType(type: Type): Symbol[];
                    getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;
                    getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;
                    getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;
                    getIndexInfosOfType(type: Type): readonly IndexInfo[];
                    getIndexInfosOfIndexSymbol: (indexSymbol: Symbol) => IndexInfo[];
                    getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];
                    getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;
                    getBaseTypes(type: InterfaceType): BaseType[];
                    getBaseTypeOfLiteralType(type: Type): Type;
                    getWidenedType(type: Type): Type;
                    getReturnTypeOfSignature(signature: Signature): Type;
                    getNullableType(type: Type, flags: TypeFlags): Type;
                    getNonNullableType(type: Type): Type;
                    getTypeArguments(type: TypeReference): readonly Type[];
                    /** Note that the resulting nodes cannot be checked. */
                    typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;
                    /** Note that the resulting nodes cannot be checked. */
                    signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): (SignatureDeclaration & {
                        typeArguments?: NodeArray<TypeNode>;
                    }) | undefined;
                    /** Note that the resulting nodes cannot be checked. */
                    indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;
                    /** Note that the resulting nodes cannot be checked. */
                    symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;
                    /** Note that the resulting nodes cannot be checked. */
                    symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;
                    /** Note that the resulting nodes cannot be checked. */
                    symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray<TypeParameterDeclaration> | undefined;
                    /** Note that the resulting nodes cannot be checked. */
                    symbolToParameterDeclaration(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): ParameterDeclaration | undefined;
                    /** Note that the resulting nodes cannot be checked. */
                    typeParameterToDeclaration(parameter: TypeParameter, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeParameterDeclaration | undefined;
                    getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];
                    getSymbolAtLocation(node: Node): Symbol | undefined;
                    getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];
                    /**
                     * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.
                     * This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.
                     */
                    getShorthandAssignmentValueSymbol(location: Node | undefined): Symbol | undefined;
                    getExportSpecifierLocalTargetSymbol(location: ExportSpecifier | Identifier): Symbol | undefined;
                    /**
                     * If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.
                     * Otherwise returns its input.
                     * For example, at `export type T = number;`:
                     *     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.
                     *     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.
                     *     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.
                     */
                    getExportSymbolOfSymbol(symbol: Symbol): Symbol;
                    getPropertySymbolOfDestructuringAssignment(location: Identifier): Symbol | undefined;
                    getTypeOfAssignmentPattern(pattern: AssignmentPattern): Type;
                    getTypeAtLocation(node: Node): Type;
                    getTypeFromTypeNode(node: TypeNode): Type;
                    signatureToString(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind): string;
                    typeToString(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
                    symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;
                    typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
                    getFullyQualifiedName(symbol: Symbol): string;
                    getAugmentedPropertiesOfType(type: Type): Symbol[];
                    getRootSymbols(symbol: Symbol): readonly Symbol[];
                    getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;
                    getContextualType(node: Expression): Type | undefined;
                    /**
                     * returns unknownSignature in the case of an error.
                     * returns undefined if the node is not valid.
                     * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.
                     */
                    getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
                    getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;
                    isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;
                    isUndefinedSymbol(symbol: Symbol): boolean;
                    isArgumentsSymbol(symbol: Symbol): boolean;
                    isUnknownSymbol(symbol: Symbol): boolean;
                    getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;
                    isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;
                    /** Follow all aliases to get the original symbol. */
                    getAliasedSymbol(symbol: Symbol): Symbol;
                    /** Follow a *single* alias to get the immediately aliased symbol. */
                    getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;
                    getExportsOfModule(moduleSymbol: Symbol): Symbol[];
                    getJsxIntrinsicTagNamesAt(location: Node): Symbol[];
                    isOptionalParameter(node: ParameterDeclaration): boolean;
                    getAmbientModules(): Symbol[];
                    tryGetMemberInModuleExports(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
                    getApparentType(type: Type): Type;
                    getBaseConstraintOfType(type: Type): Type | undefined;
                    getDefaultFromTypeParameter(type: Type): Type | undefined;
                    getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;
                    /**
                     * Depending on the operation performed, it may be appropriate to throw away the checker
                     * if the cancellation token is triggered. Typically, if it is used for error checking
                     * and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.
                     */
                    runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;
                }
                export enum NodeBuilderFlags {
                    None = 0,
                    NoTruncation = 1,
                    WriteArrayAsGenericType = 2,
                    GenerateNamesForShadowedTypeParams = 4,
                    UseStructuralFallback = 8,
                    ForbidIndexedAccessSymbolReferences = 16,
                    WriteTypeArgumentsOfSignature = 32,
                    UseFullyQualifiedType = 64,
                    UseOnlyExternalAliasing = 128,
                    SuppressAnyReturnType = 256,
                    WriteTypeParametersInQualifiedName = 512,
                    MultilineObjectLiterals = 1024,
                    WriteClassExpressionAsTypeLiteral = 2048,
                    UseTypeOfFunction = 4096,
                    OmitParameterModifiers = 8192,
                    UseAliasDefinedOutsideCurrentScope = 16384,
                    UseSingleQuotesForStringLiteralType = 268435456,
                    NoTypeReduction = 536870912,
                    OmitThisParameter = 33554432,
                    AllowThisInObjectLiteral = 32768,
                    AllowQualifiedNameInPlaceOfIdentifier = 65536,
                    /** @deprecated AllowQualifedNameInPlaceOfIdentifier. Use AllowQualifiedNameInPlaceOfIdentifier instead. */
                    AllowQualifedNameInPlaceOfIdentifier = 65536,
                    AllowAnonymousIdentifier = 131072,
                    AllowEmptyUnionOrIntersection = 262144,
                    AllowEmptyTuple = 524288,
                    AllowUniqueESSymbolType = 1048576,
                    AllowEmptyIndexInfoType = 2097152,
                    AllowNodeModulesRelativePaths = 67108864,
                    IgnoreErrors = 70221824,
                    InObjectTypeLiteral = 4194304,
                    InTypeAlias = 8388608,
                    InInitialEntityName = 16777216
                }
                export enum TypeFormatFlags {
                    None = 0,
                    NoTruncation = 1,
                    WriteArrayAsGenericType = 2,
                    UseStructuralFallback = 8,
                    WriteTypeArgumentsOfSignature = 32,
                    UseFullyQualifiedType = 64,
                    SuppressAnyReturnType = 256,
                    MultilineObjectLiterals = 1024,
                    WriteClassExpressionAsTypeLiteral = 2048,
                    UseTypeOfFunction = 4096,
                    OmitParameterModifiers = 8192,
                    UseAliasDefinedOutsideCurrentScope = 16384,
                    UseSingleQuotesForStringLiteralType = 268435456,
                    NoTypeReduction = 536870912,
                    OmitThisParameter = 33554432,
                    AllowUniqueESSymbolType = 1048576,
                    AddUndefined = 131072,
                    WriteArrowStyleSignature = 262144,
                    InArrayType = 524288,
                    InElementType = 2097152,
                    InFirstTypeArgument = 4194304,
                    InTypeAlias = 8388608,
                    /** @deprecated */
                    WriteOwnNameForAnyLike = 0,
                    NodeBuilderFlagsMask = 848330091
                }
                export enum SymbolFormatFlags {
                    None = 0,
                    WriteTypeParametersOrArguments = 1,
                    UseOnlyExternalAliasing = 2,
                    AllowAnyNodeKind = 4,
                    UseAliasDefinedOutsideCurrentScope = 8
                }
                export enum TypePredicateKind {
                    This = 0,
                    Identifier = 1,
                    AssertsThis = 2,
                    AssertsIdentifier = 3
                }
                export interface TypePredicateBase {
                    kind: TypePredicateKind;
                    type: Type | undefined;
                }
                export interface ThisTypePredicate extends TypePredicateBase {
                    kind: TypePredicateKind.This;
                    parameterName: undefined;
                    parameterIndex: undefined;
                    type: Type;
                }
                export interface IdentifierTypePredicate extends TypePredicateBase {
                    kind: TypePredicateKind.Identifier;
                    parameterName: string;
                    parameterIndex: number;
                    type: Type;
                }
                export interface AssertsThisTypePredicate extends TypePredicateBase {
                    kind: TypePredicateKind.AssertsThis;
                    parameterName: undefined;
                    parameterIndex: undefined;
                    type: Type | undefined;
                }
                export interface AssertsIdentifierTypePredicate extends TypePredicateBase {
                    kind: TypePredicateKind.AssertsIdentifier;
                    parameterName: string;
                    parameterIndex: number;
                    type: Type | undefined;
                }
                export type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;
                export enum SymbolFlags {
                    None = 0,
                    FunctionScopedVariable = 1,
                    BlockScopedVariable = 2,
                    Property = 4,
                    EnumMember = 8,
                    Function = 16,
                    Class = 32,
                    Interface = 64,
                    ConstEnum = 128,
                    RegularEnum = 256,
                    ValueModule = 512,
                    NamespaceModule = 1024,
                    TypeLiteral = 2048,
                    ObjectLiteral = 4096,
                    Method = 8192,
                    Constructor = 16384,
                    GetAccessor = 32768,
                    SetAccessor = 65536,
                    Signature = 131072,
                    TypeParameter = 262144,
                    TypeAlias = 524288,
                    ExportValue = 1048576,
                    Alias = 2097152,
                    Prototype = 4194304,
                    ExportStar = 8388608,
                    Optional = 16777216,
                    Transient = 33554432,
                    Assignment = 67108864,
                    ModuleExports = 134217728,
                    Enum = 384,
                    Variable = 3,
                    Value = 111551,
                    Type = 788968,
                    Namespace = 1920,
                    Module = 1536,
                    Accessor = 98304,
                    FunctionScopedVariableExcludes = 111550,
                    BlockScopedVariableExcludes = 111551,
                    ParameterExcludes = 111551,
                    PropertyExcludes = 0,
                    EnumMemberExcludes = 900095,
                    FunctionExcludes = 110991,
                    ClassExcludes = 899503,
                    InterfaceExcludes = 788872,
                    RegularEnumExcludes = 899327,
                    ConstEnumExcludes = 899967,
                    ValueModuleExcludes = 110735,
                    NamespaceModuleExcludes = 0,
                    MethodExcludes = 103359,
                    GetAccessorExcludes = 46015,
                    SetAccessorExcludes = 78783,
                    AccessorExcludes = 13247,
                    TypeParameterExcludes = 526824,
                    TypeAliasExcludes = 788968,
                    AliasExcludes = 2097152,
                    ModuleMember = 2623475,
                    ExportHasLocal = 944,
                    BlockScoped = 418,
                    PropertyOrAccessor = 98308,
                    ClassMember = 106500
                }
                export interface Symbol {
                    flags: SymbolFlags;
                    escapedName: __String;
                    declarations?: Declaration[];
                    valueDeclaration?: Declaration;
                    members?: SymbolTable;
                    exports?: SymbolTable;
                    globalExports?: SymbolTable;
                }
                export interface Symbol {
                    readonly name: string;
                    getFlags(): SymbolFlags;
                    getEscapedName(): __String;
                    getName(): string;
                    getDeclarations(): Declaration[] | undefined;
                    getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
                    getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
                }
                export enum InternalSymbolName {
                    Call = "__call",
                    Constructor = "__constructor",
                    New = "__new",
                    Index = "__index",
                    ExportStar = "__export",
                    Global = "__global",
                    Missing = "__missing",
                    Type = "__type",
                    Object = "__object",
                    JSXAttributes = "__jsxAttributes",
                    Class = "__class",
                    Function = "__function",
                    Computed = "__computed",
                    Resolving = "__resolving__",
                    ExportEquals = "export=",
                    Default = "default",
                    This = "this"
                }
                /**
                 * This represents a string whose leading underscore have been escaped by adding extra leading underscores.
                 * The shape of this brand is rather unique compared to others we've used.
                 * Instead of just an intersection of a string and an object, it is that union-ed
                 * with an intersection of void and an object. This makes it wholly incompatible
                 * with a normal string (which is good, it cannot be misused on assignment or on usage),
                 * while still being comparable with a normal string via === (also good) and castable from a string.
                 */
                export type __String = (string & {
                    __escapedIdentifier: void;
                }) | (void & {
                    __escapedIdentifier: void;
                }) | InternalSymbolName;
                /** ReadonlyMap where keys are `__String`s. */
                export interface ReadonlyUnderscoreEscapedMap<T> extends ReadonlyESMap<__String, T> {
                }
                /** Map where keys are `__String`s. */
                export interface UnderscoreEscapedMap<T> extends ESMap<__String, T>, ReadonlyUnderscoreEscapedMap<T> {
                }
                /** SymbolTable based on ES6 Map interface. */
                export type SymbolTable = UnderscoreEscapedMap<Symbol>;
                export enum TypeFlags {
                    Any = 1,
                    Unknown = 2,
                    String = 4,
                    Number = 8,
                    Boolean = 16,
                    Enum = 32,
                    BigInt = 64,
                    StringLiteral = 128,
                    NumberLiteral = 256,
                    BooleanLiteral = 512,
                    EnumLiteral = 1024,
                    BigIntLiteral = 2048,
                    ESSymbol = 4096,
                    UniqueESSymbol = 8192,
                    Void = 16384,
                    Undefined = 32768,
                    Null = 65536,
                    Never = 131072,
                    TypeParameter = 262144,
                    Object = 524288,
                    Union = 1048576,
                    Intersection = 2097152,
                    Index = 4194304,
                    IndexedAccess = 8388608,
                    Conditional = 16777216,
                    Substitution = 33554432,
                    NonPrimitive = 67108864,
                    TemplateLiteral = 134217728,
                    StringMapping = 268435456,
                    Literal = 2944,
                    Unit = 109440,
                    StringOrNumberLiteral = 384,
                    PossiblyFalsy = 117724,
                    StringLike = 402653316,
                    NumberLike = 296,
                    BigIntLike = 2112,
                    BooleanLike = 528,
                    EnumLike = 1056,
                    ESSymbolLike = 12288,
                    VoidLike = 49152,
                    UnionOrIntersection = 3145728,
                    StructuredType = 3670016,
                    TypeVariable = 8650752,
                    InstantiableNonPrimitive = 58982400,
                    InstantiablePrimitive = 406847488,
                    Instantiable = 465829888,
                    StructuredOrInstantiable = 469499904,
                    Narrowable = 536624127
                }
                export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;
                export interface Type {
                    flags: TypeFlags;
                    symbol: Symbol;
                    pattern?: DestructuringPattern;
                    aliasSymbol?: Symbol;
                    aliasTypeArguments?: readonly Type[];
                }
                export interface Type {
                    getFlags(): TypeFlags;
                    getSymbol(): Symbol | undefined;
                    getProperties(): Symbol[];
                    getProperty(propertyName: string): Symbol | undefined;
                    getApparentProperties(): Symbol[];
                    getCallSignatures(): readonly Signature[];
                    getConstructSignatures(): readonly Signature[];
                    getStringIndexType(): Type | undefined;
                    getNumberIndexType(): Type | undefined;
                    getBaseTypes(): BaseType[] | undefined;
                    getNonNullableType(): Type;
                    getConstraint(): Type | undefined;
                    getDefault(): Type | undefined;
                    isUnion(): this is UnionType;
                    isIntersection(): this is IntersectionType;
                    isUnionOrIntersection(): this is UnionOrIntersectionType;
                    isLiteral(): this is LiteralType;
                    isStringLiteral(): this is StringLiteralType;
                    isNumberLiteral(): this is NumberLiteralType;
                    isTypeParameter(): this is TypeParameter;
                    isClassOrInterface(): this is InterfaceType;
                    isClass(): this is InterfaceType;
                    isIndexType(): this is IndexType;
                }
                export interface LiteralType extends Type {
                    value: string | number | PseudoBigInt;
                    freshType: LiteralType;
                    regularType: LiteralType;
                }
                export interface UniqueESSymbolType extends Type {
                    symbol: Symbol;
                    escapedName: __String;
                }
                export interface StringLiteralType extends LiteralType {
                    value: string;
                }
                export interface NumberLiteralType extends LiteralType {
                    value: number;
                }
                export interface BigIntLiteralType extends LiteralType {
                    value: PseudoBigInt;
                }
                export interface EnumType extends Type {
                }
                export enum ObjectFlags {
                    Class = 1,
                    Interface = 2,
                    Reference = 4,
                    Tuple = 8,
                    Anonymous = 16,
                    Mapped = 32,
                    Instantiated = 64,
                    ObjectLiteral = 128,
                    EvolvingArray = 256,
                    ObjectLiteralPatternWithComputedProperties = 512,
                    ReverseMapped = 1024,
                    JsxAttributes = 2048,
                    JSLiteral = 4096,
                    FreshLiteral = 8192,
                    ArrayLiteral = 16384,
                    ClassOrInterface = 3,
                    ContainsSpread = 2097152,
                    ObjectRestType = 4194304,
                    InstantiationExpressionType = 8388608
                }
                export interface ObjectType extends Type {
                    objectFlags: ObjectFlags;
                }
                /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */
                export interface InterfaceType extends ObjectType {
                    typeParameters: TypeParameter[] | undefined;
                    outerTypeParameters: TypeParameter[] | undefined;
                    localTypeParameters: TypeParameter[] | undefined;
                    thisType: TypeParameter | undefined;
                }
                export type BaseType = ObjectType | IntersectionType | TypeVariable;
                export interface InterfaceTypeWithDeclaredMembers extends InterfaceType {
                    declaredProperties: Symbol[];
                    declaredCallSignatures: Signature[];
                    declaredConstructSignatures: Signature[];
                    declaredIndexInfos: IndexInfo[];
                }
                /**
                 * Type references (ObjectFlags.Reference). When a class or interface has type parameters or
                 * a "this" type, references to the class or interface are made using type references. The
                 * typeArguments property specifies the types to substitute for the type parameters of the
                 * class or interface and optionally includes an extra element that specifies the type to
                 * substitute for "this" in the resulting instantiation. When no extra argument is present,
                 * the type reference itself is substituted for "this". The typeArguments property is undefined
                 * if the class or interface has no type parameters and the reference isn't specifying an
                 * explicit "this" argument.
                 */
                export interface TypeReference extends ObjectType {
                    target: GenericType;
                    node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
                }
                export interface TypeReference {
                    typeArguments?: readonly Type[];
                }
                export interface DeferredTypeReference extends TypeReference {
                }
                export interface GenericType extends InterfaceType, TypeReference {
                }
                export enum ElementFlags {
                    Required = 1,
                    Optional = 2,
                    Rest = 4,
                    Variadic = 8,
                    Fixed = 3,
                    Variable = 12,
                    NonRequired = 14,
                    NonRest = 11
                }
                export interface TupleType extends GenericType {
                    elementFlags: readonly ElementFlags[];
                    minLength: number;
                    fixedLength: number;
                    hasRestElement: boolean;
                    combinedFlags: ElementFlags;
                    readonly: boolean;
                    labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];
                }
                export interface TupleTypeReference extends TypeReference {
                    target: TupleType;
                }
                export interface UnionOrIntersectionType extends Type {
                    types: Type[];
                }
                export interface UnionType extends UnionOrIntersectionType {
                }
                export interface IntersectionType extends UnionOrIntersectionType {
                }
                export type StructuredType = ObjectType | UnionType | IntersectionType;
                export interface EvolvingArrayType extends ObjectType {
                    elementType: Type;
                    finalArrayType?: Type;
                }
                export interface InstantiableType extends Type {
                }
                export interface TypeParameter extends InstantiableType {
                }
                export interface IndexedAccessType extends InstantiableType {
                    objectType: Type;
                    indexType: Type;
                    constraint?: Type;
                    simplifiedForReading?: Type;
                    simplifiedForWriting?: Type;
                }
                export type TypeVariable = TypeParameter | IndexedAccessType;
                export interface IndexType extends InstantiableType {
                    type: InstantiableType | UnionOrIntersectionType;
                }
                export interface ConditionalRoot {
                    node: ConditionalTypeNode;
                    checkType: Type;
                    extendsType: Type;
                    isDistributive: boolean;
                    inferTypeParameters?: TypeParameter[];
                    outerTypeParameters?: TypeParameter[];
                    instantiations?: Map<Type>;
                    aliasSymbol?: Symbol;
                    aliasTypeArguments?: Type[];
                }
                export interface ConditionalType extends InstantiableType {
                    root: ConditionalRoot;
                    checkType: Type;
                    extendsType: Type;
                    resolvedTrueType?: Type;
                    resolvedFalseType?: Type;
                }
                export interface TemplateLiteralType extends InstantiableType {
                    texts: readonly string[];
                    types: readonly Type[];
                }
                export interface StringMappingType extends InstantiableType {
                    symbol: Symbol;
                    type: Type;
                }
                export interface SubstitutionType extends InstantiableType {
                    objectFlags: ObjectFlags;
                    baseType: Type;
                    constraint: Type;
                }
                export enum SignatureKind {
                    Call = 0,
                    Construct = 1
                }
                export interface Signature {
                    declaration?: SignatureDeclaration | JSDocSignature;
                    typeParameters?: readonly TypeParameter[];
                    parameters: readonly Symbol[];
                }
                export interface Signature {
                    getDeclaration(): SignatureDeclaration;
                    getTypeParameters(): TypeParameter[] | undefined;
                    getParameters(): Symbol[];
                    getTypeParameterAtPosition(pos: number): Type;
                    getReturnType(): Type;
                    getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
                    getJsDocTags(): JSDocTagInfo[];
                }
                export enum IndexKind {
                    String = 0,
                    Number = 1
                }
                export interface IndexInfo {
                    keyType: Type;
                    type: Type;
                    isReadonly: boolean;
                    declaration?: IndexSignatureDeclaration;
                }
                export enum InferencePriority {
                    NakedTypeVariable = 1,
                    SpeculativeTuple = 2,
                    SubstituteSource = 4,
                    HomomorphicMappedType = 8,
                    PartialHomomorphicMappedType = 16,
                    MappedTypeConstraint = 32,
                    ContravariantConditional = 64,
                    ReturnType = 128,
                    LiteralKeyof = 256,
                    NoConstraints = 512,
                    AlwaysStrict = 1024,
                    MaxValue = 2048,
                    PriorityImpliesCombination = 416,
                    Circularity = "Bad expression <-1>"
                }
                /** @deprecated Use FileExtensionInfo instead. */
                export type JsFileExtensionInfo = FileExtensionInfo;
                export interface FileExtensionInfo {
                    extension: string;
                    isMixedContent: boolean;
                    scriptKind?: ScriptKind;
                }
                export interface DiagnosticMessage {
                    key: string;
                    category: DiagnosticCategory;
                    code: number;
                    message: string;
                    reportsUnnecessary?: {};
                    reportsDeprecated?: {};
                }
                /**
                 * A linked list of formatted diagnostic messages to be used as part of a multiline message.
                 * It is built from the bottom up, leaving the head to be the "main" diagnostic.
                 * While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,
                 * the difference is that messages are all preformatted in DMC.
                 */
                export interface DiagnosticMessageChain {
                    messageText: string;
                    category: DiagnosticCategory;
                    code: number;
                    next?: DiagnosticMessageChain[];
                }
                export interface Diagnostic extends DiagnosticRelatedInformation {
                    /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */
                    reportsUnnecessary?: {};
                    reportsDeprecated?: {};
                    source?: string;
                    relatedInformation?: DiagnosticRelatedInformation[];
                }
                export interface DiagnosticRelatedInformation {
                    category: DiagnosticCategory;
                    code: number;
                    file: SourceFile | undefined;
                    start: number | undefined;
                    length: number | undefined;
                    messageText: string | DiagnosticMessageChain;
                }
                export interface DiagnosticWithLocation extends Diagnostic {
                    file: SourceFile;
                    start: number;
                    length: number;
                }
                export enum DiagnosticCategory {
                    Warning = 0,
                    Error = 1,
                    Suggestion = 2,
                    Message = 3
                }
                export enum ModuleResolutionKind {
                    Classic = 1,
                    NodeJs = 2,
                    Node16 = 3,
                    NodeNext = 99
                }
                export enum ModuleDetectionKind {
                    /**
                     * Files with imports, exports and/or import.meta are considered modules
                     */
                    Legacy = 1,
                    /**
                     * Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+
                     */
                    Auto = 2,
                    /**
                     * Consider all non-declaration files modules, regardless of present syntax
                     */
                    Force = 3
                }
                export interface PluginImport {
                    name: string;
                }
                export interface ProjectReference {
                    /** A normalized path on disk */
                    path: string;
                    /** The path as the user originally wrote it */
                    originalPath?: string;
                    /** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */
                    prepend?: boolean;
                    /** True if it is intended that this reference form a circularity */
                    circular?: boolean;
                }
                export enum WatchFileKind {
                    FixedPollingInterval = 0,
                    PriorityPollingInterval = 1,
                    DynamicPriorityPolling = 2,
                    FixedChunkSizePolling = 3,
                    UseFsEvents = 4,
                    UseFsEventsOnParentDirectory = 5
                }
                export enum WatchDirectoryKind {
                    UseFsEvents = 0,
                    FixedPollingInterval = 1,
                    DynamicPriorityPolling = 2,
                    FixedChunkSizePolling = 3
                }
                export enum PollingWatchKind {
                    FixedInterval = 0,
                    PriorityInterval = 1,
                    DynamicPriority = 2,
                    FixedChunkSize = 3
                }
                export type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;
                export interface CompilerOptions {
                    allowJs?: boolean;
                    allowSyntheticDefaultImports?: boolean;
                    allowUmdGlobalAccess?: boolean;
                    allowUnreachableCode?: boolean;
                    allowUnusedLabels?: boolean;
                    alwaysStrict?: boolean;
                    baseUrl?: string;
                    charset?: string;
                    checkJs?: boolean;
                    declaration?: boolean;
                    declarationMap?: boolean;
                    emitDeclarationOnly?: boolean;
                    declarationDir?: string;
                    disableSizeLimit?: boolean;
                    disableSourceOfProjectReferenceRedirect?: boolean;
                    disableSolutionSearching?: boolean;
                    disableReferencedProjectLoad?: boolean;
                    downlevelIteration?: boolean;
                    emitBOM?: boolean;
                    emitDecoratorMetadata?: boolean;
                    exactOptionalPropertyTypes?: boolean;
                    experimentalDecorators?: boolean;
                    forceConsistentCasingInFileNames?: boolean;
                    importHelpers?: boolean;
                    importsNotUsedAsValues?: ImportsNotUsedAsValues;
                    inlineSourceMap?: boolean;
                    inlineSources?: boolean;
                    isolatedModules?: boolean;
                    jsx?: JsxEmit;
                    keyofStringsOnly?: boolean;
                    lib?: string[];
                    locale?: string;
                    mapRoot?: string;
                    maxNodeModuleJsDepth?: number;
                    module?: ModuleKind;
                    moduleResolution?: ModuleResolutionKind;
                    moduleSuffixes?: string[];
                    moduleDetection?: ModuleDetectionKind;
                    newLine?: NewLineKind;
                    noEmit?: boolean;
                    noEmitHelpers?: boolean;
                    noEmitOnError?: boolean;
                    noErrorTruncation?: boolean;
                    noFallthroughCasesInSwitch?: boolean;
                    noImplicitAny?: boolean;
                    noImplicitReturns?: boolean;
                    noImplicitThis?: boolean;
                    noStrictGenericChecks?: boolean;
                    noUnusedLocals?: boolean;
                    noUnusedParameters?: boolean;
                    noImplicitUseStrict?: boolean;
                    noPropertyAccessFromIndexSignature?: boolean;
                    assumeChangesOnlyAffectDirectDependencies?: boolean;
                    noLib?: boolean;
                    noResolve?: boolean;
                    noUncheckedIndexedAccess?: boolean;
                    out?: string;
                    outDir?: string;
                    outFile?: string;
                    paths?: MapLike<string[]>;
                    preserveConstEnums?: boolean;
                    noImplicitOverride?: boolean;
                    preserveSymlinks?: boolean;
                    preserveValueImports?: boolean;
                    project?: string;
                    reactNamespace?: string;
                    jsxFactory?: string;
                    jsxFragmentFactory?: string;
                    jsxImportSource?: string;
                    composite?: boolean;
                    incremental?: boolean;
                    tsBuildInfoFile?: string;
                    removeComments?: boolean;
                    rootDir?: string;
                    rootDirs?: string[];
                    skipLibCheck?: boolean;
                    skipDefaultLibCheck?: boolean;
                    sourceMap?: boolean;
                    sourceRoot?: string;
                    strict?: boolean;
                    strictFunctionTypes?: boolean;
                    strictBindCallApply?: boolean;
                    strictNullChecks?: boolean;
                    strictPropertyInitialization?: boolean;
                    stripInternal?: boolean;
                    suppressExcessPropertyErrors?: boolean;
                    suppressImplicitAnyIndexErrors?: boolean;
                    target?: ScriptTarget;
                    traceResolution?: boolean;
                    useUnknownInCatchVariables?: boolean;
                    resolveJsonModule?: boolean;
                    types?: string[];
                    /** Paths used to compute primary types search locations */
                    typeRoots?: string[];
                    esModuleInterop?: boolean;
                    useDefineForClassFields?: boolean;
                    [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
                }
                export interface WatchOptions {
                    watchFile?: WatchFileKind;
                    watchDirectory?: WatchDirectoryKind;
                    fallbackPolling?: PollingWatchKind;
                    synchronousWatchDirectory?: boolean;
                    excludeDirectories?: string[];
                    excludeFiles?: string[];
                    [option: string]: CompilerOptionsValue | undefined;
                }
                export interface TypeAcquisition {
                    /**
                     * @deprecated typingOptions.enableAutoDiscovery
                     * Use typeAcquisition.enable instead.
                     */
                    enableAutoDiscovery?: boolean;
                    enable?: boolean;
                    include?: string[];
                    exclude?: string[];
                    disableFilenameBasedTypeAcquisition?: boolean;
                    [option: string]: CompilerOptionsValue | undefined;
                }
                export enum ModuleKind {
                    None = 0,
                    CommonJS = 1,
                    AMD = 2,
                    UMD = 3,
                    System = 4,
                    ES2015 = 5,
                    ES2020 = 6,
                    ES2022 = 7,
                    ESNext = 99,
                    Node16 = 100,
                    NodeNext = 199
                }
                export enum JsxEmit {
                    None = 0,
                    Preserve = 1,
                    React = 2,
                    ReactNative = 3,
                    ReactJSX = 4,
                    ReactJSXDev = 5
                }
                export enum ImportsNotUsedAsValues {
                    Remove = 0,
                    Preserve = 1,
                    Error = 2
                }
                export enum NewLineKind {
                    CarriageReturnLineFeed = 0,
                    LineFeed = 1
                }
                export interface LineAndCharacter {
                    /** 0-based. */
                    line: number;
                    character: number;
                }
                export enum ScriptKind {
                    Unknown = 0,
                    JS = 1,
                    JSX = 2,
                    TS = 3,
                    TSX = 4,
                    External = 5,
                    JSON = 6,
                    /**
                     * Used on extensions that doesn't define the ScriptKind but the content defines it.
                     * Deferred extensions are going to be included in all project contexts.
                     */
                    Deferred = 7
                }
                export enum ScriptTarget {
                    ES3 = 0,
                    ES5 = 1,
                    ES2015 = 2,
                    ES2016 = 3,
                    ES2017 = 4,
                    ES2018 = 5,
                    ES2019 = 6,
                    ES2020 = 7,
                    ES2021 = 8,
                    ES2022 = 9,
                    ESNext = 99,
                    JSON = 100,
                    Latest = 99
                }
                export enum LanguageVariant {
                    Standard = 0,
                    JSX = 1
                }
                /** Either a parsed command line or a parsed tsconfig.json */
                export interface ParsedCommandLine {
                    options: CompilerOptions;
                    typeAcquisition?: TypeAcquisition;
                    fileNames: string[];
                    projectReferences?: readonly ProjectReference[];
                    watchOptions?: WatchOptions;
                    raw?: any;
                    errors: Diagnostic[];
                    wildcardDirectories?: MapLike<WatchDirectoryFlags>;
                    compileOnSave?: boolean;
                }
                export enum WatchDirectoryFlags {
                    None = 0,
                    Recursive = 1
                }
                export interface CreateProgramOptions {
                    rootNames: readonly string[];
                    options: CompilerOptions;
                    projectReferences?: readonly ProjectReference[];
                    host?: CompilerHost;
                    oldProgram?: Program;
                    configFileParsingDiagnostics?: readonly Diagnostic[];
                }
                export interface ModuleResolutionHost {
                    fileExists(fileName: string): boolean;
                    readFile(fileName: string): string | undefined;
                    trace?(s: string): void;
                    directoryExists?(directoryName: string): boolean;
                    /**
                     * Resolve a symbolic link.
                     * @see https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options
                     */
                    realpath?(path: string): string;
                    getCurrentDirectory?(): string;
                    getDirectories?(path: string): string[];
                    useCaseSensitiveFileNames?: boolean | (() => boolean) | undefined;
                }
                /**
                 * Used by services to specify the minimum host area required to set up source files under any compilation settings
                 */
                export interface MinimalResolutionCacheHost extends ModuleResolutionHost {
                    getCompilationSettings(): CompilerOptions;
                    getCompilerHost?(): CompilerHost | undefined;
                }
                /**
                 * Represents the result of module resolution.
                 * Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.
                 * The Program will then filter results based on these flags.
                 *
                 * Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.
                 */
                export interface ResolvedModule {
                    /** Path of the file the module was resolved to. */
                    resolvedFileName: string;
                    /** True if `resolvedFileName` comes from `node_modules`. */
                    isExternalLibraryImport?: boolean;
                }
                /**
                 * ResolvedModule with an explicitly provided `extension` property.
                 * Prefer this over `ResolvedModule`.
                 * If changing this, remember to change `moduleResolutionIsEqualTo`.
                 */
                export interface ResolvedModuleFull extends ResolvedModule {
                    /**
                     * Extension of resolvedFileName. This must match what's at the end of resolvedFileName.
                     * This is optional for backwards-compatibility, but will be added if not provided.
                     */
                    extension: Extension;
                    packageId?: PackageId;
                }
                /**
                 * Unique identifier with a package name and version.
                 * If changing this, remember to change `packageIdIsEqual`.
                 */
                export interface PackageId {
                    /**
                     * Name of the package.
                     * Should not include `@types`.
                     * If accessing a non-index file, this should include its name e.g. "foo/bar".
                     */
                    name: string;
                    /**
                     * Name of a submodule within this package.
                     * May be "".
                     */
                    subModuleName: string;
                    /** Version of the package, e.g. "1.2.3" */
                    version: string;
                }
                export enum Extension {
                    Ts = ".ts",
                    Tsx = ".tsx",
                    Dts = ".d.ts",
                    Js = ".js",
                    Jsx = ".jsx",
                    Json = ".json",
                    TsBuildInfo = ".tsbuildinfo",
                    Mjs = ".mjs",
                    Mts = ".mts",
                    Dmts = ".d.mts",
                    Cjs = ".cjs",
                    Cts = ".cts",
                    Dcts = ".d.cts"
                }
                export interface ResolvedModuleWithFailedLookupLocations {
                    readonly resolvedModule: ResolvedModuleFull | undefined;
                }
                export interface ResolvedTypeReferenceDirective {
                    primary: boolean;
                    resolvedFileName: string | undefined;
                    packageId?: PackageId;
                    /** True if `resolvedFileName` comes from `node_modules`. */
                    isExternalLibraryImport?: boolean;
                }
                export interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
                    readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;
                    readonly failedLookupLocations: string[];
                }
                export interface CompilerHost extends ModuleResolutionHost {
                    getSourceFile(fileName: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
                    getSourceFileByPath?(fileName: string, path: Path, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): SourceFile | undefined;
                    getCancellationToken?(): CancellationToken;
                    getDefaultLibFileName(options: CompilerOptions): string;
                    getDefaultLibLocation?(): string;
                    writeFile: WriteFileCallback;
                    getCurrentDirectory(): string;
                    getCanonicalFileName(fileName: string): string;
                    useCaseSensitiveFileNames(): boolean;
                    getNewLine(): string;
                    readDirectory?(rootDir: string, extensions: readonly string[], excludes: readonly string[] | undefined, includes: readonly string[], depth?: number): string[];
                    resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
                    /**
                     * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it
                     */
                    getModuleResolutionCache?(): ModuleResolutionCache | undefined;
                    /**
                     * This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files
                     */
                    resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: SourceFile["impliedNodeFormat"] | undefined): (ResolvedTypeReferenceDirective | undefined)[];
                    getEnvironmentVariable?(name: string): string | undefined;
                    /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */
                    hasInvalidatedResolutions?(filePath: Path): boolean;
                    createHash?(data: string): string;
                    getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
                }
                export interface SourceMapRange extends TextRange {
                    source?: SourceMapSource;
                }
                export interface SourceMapSource {
                    fileName: string;
                    text: string;
                    skipTrivia?: (pos: number) => number;
                }
                export interface SourceMapSource {
                    getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
                }
                export enum EmitFlags {
                    None = 0,
                    SingleLine = 1,
                    AdviseOnEmitNode = 2,
                    NoSubstitution = 4,
                    CapturesThis = 8,
                    NoLeadingSourceMap = 16,
                    NoTrailingSourceMap = 32,
                    NoSourceMap = 48,
                    NoNestedSourceMaps = 64,
                    NoTokenLeadingSourceMaps = 128,
                    NoTokenTrailingSourceMaps = 256,
                    NoTokenSourceMaps = 384,
                    NoLeadingComments = 512,
                    NoTrailingComments = 1024,
                    NoComments = 1536,
                    NoNestedComments = 2048,
                    HelperName = 4096,
                    ExportName = 8192,
                    LocalName = 16384,
                    InternalName = 32768,
                    Indented = 65536,
                    NoIndentation = 131072,
                    AsyncFunctionBody = 262144,
                    ReuseTempVariableScope = 524288,
                    CustomPrologue = 1048576,
                    NoHoisting = 2097152,
                    HasEndOfDeclarationMarker = 4194304,
                    Iterator = 8388608,
                    NoAsciiEscaping = 16777216
                }
                export interface EmitHelperBase {
                    readonly name: string;
                    readonly scoped: boolean;
                    readonly text: string | ((node: EmitHelperUniqueNameCallback) => string);
                    readonly priority?: number;
                    readonly dependencies?: EmitHelper[];
                }
                export interface ScopedEmitHelper extends EmitHelperBase {
                    readonly scoped: true;
                }
                export interface UnscopedEmitHelper extends EmitHelperBase {
                    readonly scoped: false;
                    readonly text: string;
                }
                export type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;
                export type EmitHelperUniqueNameCallback = (name: string) => string;
                export enum EmitHint {
                    SourceFile = 0,
                    Expression = 1,
                    IdentifierName = 2,
                    MappedTypeParameter = 3,
                    Unspecified = 4,
                    EmbeddedStatement = 5,
                    JsxAttributeValue = 6
                }
                export enum OuterExpressionKinds {
                    Parentheses = 1,
                    TypeAssertions = 2,
                    NonNullAssertions = 4,
                    PartiallyEmittedExpressions = 8,
                    Assertions = 6,
                    All = 15,
                    ExcludeJSDocTypeAssertion = 16
                }
                export type TypeOfTag = "undefined" | "number" | "bigint" | "boolean" | "string" | "symbol" | "object" | "function";
                export interface NodeFactory {
                    createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;
                    createNumericLiteral(value: string | number, numericLiteralFlags?: TokenFlags): NumericLiteral;
                    createBigIntLiteral(value: string | PseudoBigInt): BigIntLiteral;
                    createStringLiteral(text: string, isSingleQuote?: boolean): StringLiteral;
                    createStringLiteralFromNode(sourceNode: PropertyNameLiteral | PrivateIdentifier, isSingleQuote?: boolean): StringLiteral;
                    createRegularExpressionLiteral(text: string): RegularExpressionLiteral;
                    createIdentifier(text: string): Identifier;
                    /**
                     * Create a unique temporary variable.
                     * @param recordTempVariable An optional callback used to record the temporary variable name. This
                     * should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but
                     * can be `undefined` if you plan to record the temporary variable manually.
                     * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes
                     * during emit so that the variable can be referenced in a nested function body. This is an alternative to
                     * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.
                     */
                    createTempVariable(recordTempVariable: ((node: Identifier) => void) | undefined, reservedInNestedScopes?: boolean): Identifier;
                    /**
                     * Create a unique temporary variable for use in a loop.
                     * @param reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes
                     * during emit so that the variable can be referenced in a nested function body. This is an alternative to
                     * setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.
                     */
                    createLoopVariable(reservedInNestedScopes?: boolean): Identifier;
                    /** Create a unique name based on the supplied text. */
                    createUniqueName(text: string, flags?: GeneratedIdentifierFlags): Identifier;
                    /** Create a unique name generated for a node. */
                    getGeneratedNameForNode(node: Node | undefined, flags?: GeneratedIdentifierFlags): Identifier;
                    createPrivateIdentifier(text: string): PrivateIdentifier;
                    createUniquePrivateName(text?: string): PrivateIdentifier;
                    getGeneratedPrivateNameForNode(node: Node): PrivateIdentifier;
                    createToken(token: SyntaxKind.SuperKeyword): SuperExpression;
                    createToken(token: SyntaxKind.ThisKeyword): ThisExpression;
                    createToken(token: SyntaxKind.NullKeyword): NullLiteral;
                    createToken(token: SyntaxKind.TrueKeyword): TrueLiteral;
                    createToken(token: SyntaxKind.FalseKeyword): FalseLiteral;
                    createToken<TKind extends PunctuationSyntaxKind>(token: TKind): PunctuationToken<TKind>;
                    createToken<TKind extends KeywordTypeSyntaxKind>(token: TKind): KeywordTypeNode<TKind>;
                    createToken<TKind extends ModifierSyntaxKind>(token: TKind): ModifierToken<TKind>;
                    createToken<TKind extends KeywordSyntaxKind>(token: TKind): KeywordToken<TKind>;
                    createToken<TKind extends SyntaxKind.Unknown | SyntaxKind.EndOfFileToken>(token: TKind): Token<TKind>;
                    createSuper(): SuperExpression;
                    createThis(): ThisExpression;
                    createNull(): NullLiteral;
                    createTrue(): TrueLiteral;
                    createFalse(): FalseLiteral;
                    createModifier<T extends ModifierSyntaxKind>(kind: T): ModifierToken<T>;
                    createModifiersFromModifierFlags(flags: ModifierFlags): Modifier[] | undefined;
                    createQualifiedName(left: EntityName, right: string | Identifier): QualifiedName;
                    updateQualifiedName(node: QualifiedName, left: EntityName, right: Identifier): QualifiedName;
                    createComputedPropertyName(expression: Expression): ComputedPropertyName;
                    updateComputedPropertyName(node: ComputedPropertyName, expression: Expression): ComputedPropertyName;
                    createTypeParameterDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
                    updateTypeParameterDeclaration(node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
                    createParameterDeclaration(modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
                    updateParameterDeclaration(node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
                    createDecorator(expression: Expression): Decorator;
                    updateDecorator(node: Decorator, expression: Expression): Decorator;
                    createPropertySignature(modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
                    updatePropertySignature(node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined): PropertySignature;
                    createPropertyDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                    updatePropertyDeclaration(node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                    createMethodSignature(modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): MethodSignature;
                    updateMethodSignature(node: MethodSignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): MethodSignature;
                    createMethodDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                    updateMethodDeclaration(node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                    createConstructorDeclaration(modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                    updateConstructorDeclaration(node: ConstructorDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                    createGetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                    updateGetAccessorDeclaration(node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                    createSetAccessorDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                    updateSetAccessorDeclaration(node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                    createCallSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): CallSignatureDeclaration;
                    updateCallSignature(node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): CallSignatureDeclaration;
                    createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;
                    updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;
                    createIndexSignature(modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
                    updateIndexSignature(node: IndexSignatureDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
                    createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
                    updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
                    createClassStaticBlockDeclaration(body: Block): ClassStaticBlockDeclaration;
                    updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, body: Block): ClassStaticBlockDeclaration;
                    createKeywordTypeNode<TKind extends KeywordTypeSyntaxKind>(kind: TKind): KeywordTypeNode<TKind>;
                    createTypePredicateNode(assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode | string, type: TypeNode | undefined): TypePredicateNode;
                    updateTypePredicateNode(node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined): TypePredicateNode;
                    createTypeReferenceNode(typeName: string | EntityName, typeArguments?: readonly TypeNode[]): TypeReferenceNode;
                    updateTypeReferenceNode(node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined): TypeReferenceNode;
                    createFunctionTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): FunctionTypeNode;
                    updateFunctionTypeNode(node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): FunctionTypeNode;
                    createConstructorTypeNode(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
                    updateConstructorTypeNode(node: ConstructorTypeNode, modifiers: readonly Modifier[] | undefined, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
                    createTypeQueryNode(exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
                    updateTypeQueryNode(node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[]): TypeQueryNode;
                    createTypeLiteralNode(members: readonly TypeElement[] | undefined): TypeLiteralNode;
                    updateTypeLiteralNode(node: TypeLiteralNode, members: NodeArray<TypeElement>): TypeLiteralNode;
                    createArrayTypeNode(elementType: TypeNode): ArrayTypeNode;
                    updateArrayTypeNode(node: ArrayTypeNode, elementType: TypeNode): ArrayTypeNode;
                    createTupleTypeNode(elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
                    updateTupleTypeNode(node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]): TupleTypeNode;
                    createNamedTupleMember(dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
                    updateNamedTupleMember(node: NamedTupleMember, dotDotDotToken: DotDotDotToken | undefined, name: Identifier, questionToken: QuestionToken | undefined, type: TypeNode): NamedTupleMember;
                    createOptionalTypeNode(type: TypeNode): OptionalTypeNode;
                    updateOptionalTypeNode(node: OptionalTypeNode, type: TypeNode): OptionalTypeNode;
                    createRestTypeNode(type: TypeNode): RestTypeNode;
                    updateRestTypeNode(node: RestTypeNode, type: TypeNode): RestTypeNode;
                    createUnionTypeNode(types: readonly TypeNode[]): UnionTypeNode;
                    updateUnionTypeNode(node: UnionTypeNode, types: NodeArray<TypeNode>): UnionTypeNode;
                    createIntersectionTypeNode(types: readonly TypeNode[]): IntersectionTypeNode;
                    updateIntersectionTypeNode(node: IntersectionTypeNode, types: NodeArray<TypeNode>): IntersectionTypeNode;
                    createConditionalTypeNode(checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
                    updateConditionalTypeNode(node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode): ConditionalTypeNode;
                    createInferTypeNode(typeParameter: TypeParameterDeclaration): InferTypeNode;
                    updateInferTypeNode(node: InferTypeNode, typeParameter: TypeParameterDeclaration): InferTypeNode;
                    createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
                    updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, assertions: ImportTypeAssertionContainer | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
                    createParenthesizedType(type: TypeNode): ParenthesizedTypeNode;
                    updateParenthesizedType(node: ParenthesizedTypeNode, type: TypeNode): ParenthesizedTypeNode;
                    createThisTypeNode(): ThisTypeNode;
                    createTypeOperatorNode(operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;
                    updateTypeOperatorNode(node: TypeOperatorNode, type: TypeNode): TypeOperatorNode;
                    createIndexedAccessTypeNode(objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
                    updateIndexedAccessTypeNode(node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode): IndexedAccessTypeNode;
                    createMappedTypeNode(readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
                    updateMappedTypeNode(node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined): MappedTypeNode;
                    createLiteralTypeNode(literal: LiteralTypeNode["literal"]): LiteralTypeNode;
                    updateLiteralTypeNode(node: LiteralTypeNode, literal: LiteralTypeNode["literal"]): LiteralTypeNode;
                    createTemplateLiteralType(head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
                    updateTemplateLiteralType(node: TemplateLiteralTypeNode, head: TemplateHead, templateSpans: readonly TemplateLiteralTypeSpan[]): TemplateLiteralTypeNode;
                    createObjectBindingPattern(elements: readonly BindingElement[]): ObjectBindingPattern;
                    updateObjectBindingPattern(node: ObjectBindingPattern, elements: readonly BindingElement[]): ObjectBindingPattern;
                    createArrayBindingPattern(elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
                    updateArrayBindingPattern(node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]): ArrayBindingPattern;
                    createBindingElement(dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression): BindingElement;
                    updateBindingElement(node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined): BindingElement;
                    createArrayLiteralExpression(elements?: readonly Expression[], multiLine?: boolean): ArrayLiteralExpression;
                    updateArrayLiteralExpression(node: ArrayLiteralExpression, elements: readonly Expression[]): ArrayLiteralExpression;
                    createObjectLiteralExpression(properties?: readonly ObjectLiteralElementLike[], multiLine?: boolean): ObjectLiteralExpression;
                    updateObjectLiteralExpression(node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]): ObjectLiteralExpression;
                    createPropertyAccessExpression(expression: Expression, name: string | MemberName): PropertyAccessExpression;
                    updatePropertyAccessExpression(node: PropertyAccessExpression, expression: Expression, name: MemberName): PropertyAccessExpression;
                    createPropertyAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName): PropertyAccessChain;
                    updatePropertyAccessChain(node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName): PropertyAccessChain;
                    createElementAccessExpression(expression: Expression, index: number | Expression): ElementAccessExpression;
                    updateElementAccessExpression(node: ElementAccessExpression, expression: Expression, argumentExpression: Expression): ElementAccessExpression;
                    createElementAccessChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression): ElementAccessChain;
                    updateElementAccessChain(node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression): ElementAccessChain;
                    createCallExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallExpression;
                    updateCallExpression(node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallExpression;
                    createCallChain(expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): CallChain;
                    updateCallChain(node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]): CallChain;
                    createNewExpression(expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
                    updateNewExpression(node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined): NewExpression;
                    createTaggedTemplateExpression(tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
                    updateTaggedTemplateExpression(node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
                    createTypeAssertion(type: TypeNode, expression: Expression): TypeAssertion;
                    updateTypeAssertion(node: TypeAssertion, type: TypeNode, expression: Expression): TypeAssertion;
                    createParenthesizedExpression(expression: Expression): ParenthesizedExpression;
                    updateParenthesizedExpression(node: ParenthesizedExpression, expression: Expression): ParenthesizedExpression;
                    createFunctionExpression(modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block): FunctionExpression;
                    updateFunctionExpression(node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block): FunctionExpression;
                    createArrowFunction(modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;
                    updateArrowFunction(node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;
                    createDeleteExpression(expression: Expression): DeleteExpression;
                    updateDeleteExpression(node: DeleteExpression, expression: Expression): DeleteExpression;
                    createTypeOfExpression(expression: Expression): TypeOfExpression;
                    updateTypeOfExpression(node: TypeOfExpression, expression: Expression): TypeOfExpression;
                    createVoidExpression(expression: Expression): VoidExpression;
                    updateVoidExpression(node: VoidExpression, expression: Expression): VoidExpression;
                    createAwaitExpression(expression: Expression): AwaitExpression;
                    updateAwaitExpression(node: AwaitExpression, expression: Expression): AwaitExpression;
                    createPrefixUnaryExpression(operator: PrefixUnaryOperator, operand: Expression): PrefixUnaryExpression;
                    updatePrefixUnaryExpression(node: PrefixUnaryExpression, operand: Expression): PrefixUnaryExpression;
                    createPostfixUnaryExpression(operand: Expression, operator: PostfixUnaryOperator): PostfixUnaryExpression;
                    updatePostfixUnaryExpression(node: PostfixUnaryExpression, operand: Expression): PostfixUnaryExpression;
                    createBinaryExpression(left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
                    updateBinaryExpression(node: BinaryExpression, left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression): BinaryExpression;
                    createConditionalExpression(condition: Expression, questionToken: QuestionToken | undefined, whenTrue: Expression, colonToken: ColonToken | undefined, whenFalse: Expression): ConditionalExpression;
                    updateConditionalExpression(node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;
                    createTemplateExpression(head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
                    updateTemplateExpression(node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]): TemplateExpression;
                    createTemplateHead(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateHead;
                    createTemplateHead(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateHead;
                    createTemplateMiddle(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateMiddle;
                    createTemplateMiddle(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateMiddle;
                    createTemplateTail(text: string, rawText?: string, templateFlags?: TokenFlags): TemplateTail;
                    createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;
                    createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;
                    createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
                    createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;
                    createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;
                    updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;
                    createSpreadElement(expression: Expression): SpreadElement;
                    updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;
                    createClassExpression(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
                    updateClassExpression(node: ClassExpression, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
                    createOmittedExpression(): OmittedExpression;
                    createExpressionWithTypeArguments(expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
                    updateExpressionWithTypeArguments(node: ExpressionWithTypeArguments, expression: Expression, typeArguments: readonly TypeNode[] | undefined): ExpressionWithTypeArguments;
                    createAsExpression(expression: Expression, type: TypeNode): AsExpression;
                    updateAsExpression(node: AsExpression, expression: Expression, type: TypeNode): AsExpression;
                    createNonNullExpression(expression: Expression): NonNullExpression;
                    updateNonNullExpression(node: NonNullExpression, expression: Expression): NonNullExpression;
                    createNonNullChain(expression: Expression): NonNullChain;
                    updateNonNullChain(node: NonNullChain, expression: Expression): NonNullChain;
                    createMetaProperty(keywordToken: MetaProperty["keywordToken"], name: Identifier): MetaProperty;
                    updateMetaProperty(node: MetaProperty, name: Identifier): MetaProperty;
                    createSatisfiesExpression(expression: Expression, type: TypeNode): SatisfiesExpression;
                    updateSatisfiesExpression(node: SatisfiesExpression, expression: Expression, type: TypeNode): SatisfiesExpression;
                    createTemplateSpan(expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
                    updateTemplateSpan(node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail): TemplateSpan;
                    createSemicolonClassElement(): SemicolonClassElement;
                    createBlock(statements: readonly Statement[], multiLine?: boolean): Block;
                    updateBlock(node: Block, statements: readonly Statement[]): Block;
                    createVariableStatement(modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]): VariableStatement;
                    updateVariableStatement(node: VariableStatement, modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList): VariableStatement;
                    createEmptyStatement(): EmptyStatement;
                    createExpressionStatement(expression: Expression): ExpressionStatement;
                    updateExpressionStatement(node: ExpressionStatement, expression: Expression): ExpressionStatement;
                    createIfStatement(expression: Expression, thenStatement: Statement, elseStatement?: Statement): IfStatement;
                    updateIfStatement(node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined): IfStatement;
                    createDoStatement(statement: Statement, expression: Expression): DoStatement;
                    updateDoStatement(node: DoStatement, statement: Statement, expression: Expression): DoStatement;
                    createWhileStatement(expression: Expression, statement: Statement): WhileStatement;
                    updateWhileStatement(node: WhileStatement, expression: Expression, statement: Statement): WhileStatement;
                    createForStatement(initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
                    updateForStatement(node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement): ForStatement;
                    createForInStatement(initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
                    updateForInStatement(node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement): ForInStatement;
                    createForOfStatement(awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
                    updateForOfStatement(node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement): ForOfStatement;
                    createContinueStatement(label?: string | Identifier): ContinueStatement;
                    updateContinueStatement(node: ContinueStatement, label: Identifier | undefined): ContinueStatement;
                    createBreakStatement(label?: string | Identifier): BreakStatement;
                    updateBreakStatement(node: BreakStatement, label: Identifier | undefined): BreakStatement;
                    createReturnStatement(expression?: Expression): ReturnStatement;
                    updateReturnStatement(node: ReturnStatement, expression: Expression | undefined): ReturnStatement;
                    createWithStatement(expression: Expression, statement: Statement): WithStatement;
                    updateWithStatement(node: WithStatement, expression: Expression, statement: Statement): WithStatement;
                    createSwitchStatement(expression: Expression, caseBlock: CaseBlock): SwitchStatement;
                    updateSwitchStatement(node: SwitchStatement, expression: Expression, caseBlock: CaseBlock): SwitchStatement;
                    createLabeledStatement(label: string | Identifier, statement: Statement): LabeledStatement;
                    updateLabeledStatement(node: LabeledStatement, label: Identifier, statement: Statement): LabeledStatement;
                    createThrowStatement(expression: Expression): ThrowStatement;
                    updateThrowStatement(node: ThrowStatement, expression: Expression): ThrowStatement;
                    createTryStatement(tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
                    updateTryStatement(node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined): TryStatement;
                    createDebuggerStatement(): DebuggerStatement;
                    createVariableDeclaration(name: string | BindingName, exclamationToken?: ExclamationToken, type?: TypeNode, initializer?: Expression): VariableDeclaration;
                    updateVariableDeclaration(node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
                    createVariableDeclarationList(declarations: readonly VariableDeclaration[], flags?: NodeFlags): VariableDeclarationList;
                    updateVariableDeclarationList(node: VariableDeclarationList, declarations: readonly VariableDeclaration[]): VariableDeclarationList;
                    createFunctionDeclaration(modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                    updateFunctionDeclaration(node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                    createClassDeclaration(modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                    updateClassDeclaration(node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                    createInterfaceDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                    updateInterfaceDeclaration(node: InterfaceDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                    createTypeAliasDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                    updateTypeAliasDeclaration(node: TypeAliasDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                    createEnumDeclaration(modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
                    updateEnumDeclaration(node: EnumDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
                    createModuleDeclaration(modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
                    updateModuleDeclaration(node: ModuleDeclaration, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
                    createModuleBlock(statements: readonly Statement[]): ModuleBlock;
                    updateModuleBlock(node: ModuleBlock, statements: readonly Statement[]): ModuleBlock;
                    createCaseBlock(clauses: readonly CaseOrDefaultClause[]): CaseBlock;
                    updateCaseBlock(node: CaseBlock, clauses: readonly CaseOrDefaultClause[]): CaseBlock;
                    createNamespaceExportDeclaration(name: string | Identifier): NamespaceExportDeclaration;
                    updateNamespaceExportDeclaration(node: NamespaceExportDeclaration, name: Identifier): NamespaceExportDeclaration;
                    createImportEqualsDeclaration(modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                    updateImportEqualsDeclaration(node: ImportEqualsDeclaration, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                    createImportDeclaration(modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
                    updateImportDeclaration(node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
                    createImportClause(isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
                    updateImportClause(node: ImportClause, isTypeOnly: boolean, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined): ImportClause;
                    createAssertClause(elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
                    updateAssertClause(node: AssertClause, elements: NodeArray<AssertEntry>, multiLine?: boolean): AssertClause;
                    createAssertEntry(name: AssertionKey, value: Expression): AssertEntry;
                    updateAssertEntry(node: AssertEntry, name: AssertionKey, value: Expression): AssertEntry;
                    createImportTypeAssertionContainer(clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
                    updateImportTypeAssertionContainer(node: ImportTypeAssertionContainer, clause: AssertClause, multiLine?: boolean): ImportTypeAssertionContainer;
                    createNamespaceImport(name: Identifier): NamespaceImport;
                    updateNamespaceImport(node: NamespaceImport, name: Identifier): NamespaceImport;
                    createNamespaceExport(name: Identifier): NamespaceExport;
                    updateNamespaceExport(node: NamespaceExport, name: Identifier): NamespaceExport;
                    createNamedImports(elements: readonly ImportSpecifier[]): NamedImports;
                    updateNamedImports(node: NamedImports, elements: readonly ImportSpecifier[]): NamedImports;
                    createImportSpecifier(isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;
                    updateImportSpecifier(node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ImportSpecifier;
                    createExportAssignment(modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
                    updateExportAssignment(node: ExportAssignment, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
                    createExportDeclaration(modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
                    updateExportDeclaration(node: ExportDeclaration, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
                    createNamedExports(elements: readonly ExportSpecifier[]): NamedExports;
                    updateNamedExports(node: NamedExports, elements: readonly ExportSpecifier[]): NamedExports;
                    createExportSpecifier(isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier): ExportSpecifier;
                    updateExportSpecifier(node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier): ExportSpecifier;
                    createExternalModuleReference(expression: Expression): ExternalModuleReference;
                    updateExternalModuleReference(node: ExternalModuleReference, expression: Expression): ExternalModuleReference;
                    createJSDocAllType(): JSDocAllType;
                    createJSDocUnknownType(): JSDocUnknownType;
                    createJSDocNonNullableType(type: TypeNode, postfix?: boolean): JSDocNonNullableType;
                    updateJSDocNonNullableType(node: JSDocNonNullableType, type: TypeNode): JSDocNonNullableType;
                    createJSDocNullableType(type: TypeNode, postfix?: boolean): JSDocNullableType;
                    updateJSDocNullableType(node: JSDocNullableType, type: TypeNode): JSDocNullableType;
                    createJSDocOptionalType(type: TypeNode): JSDocOptionalType;
                    updateJSDocOptionalType(node: JSDocOptionalType, type: TypeNode): JSDocOptionalType;
                    createJSDocFunctionType(parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
                    updateJSDocFunctionType(node: JSDocFunctionType, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): JSDocFunctionType;
                    createJSDocVariadicType(type: TypeNode): JSDocVariadicType;
                    updateJSDocVariadicType(node: JSDocVariadicType, type: TypeNode): JSDocVariadicType;
                    createJSDocNamepathType(type: TypeNode): JSDocNamepathType;
                    updateJSDocNamepathType(node: JSDocNamepathType, type: TypeNode): JSDocNamepathType;
                    createJSDocTypeExpression(type: TypeNode): JSDocTypeExpression;
                    updateJSDocTypeExpression(node: JSDocTypeExpression, type: TypeNode): JSDocTypeExpression;
                    createJSDocNameReference(name: EntityName | JSDocMemberName): JSDocNameReference;
                    updateJSDocNameReference(node: JSDocNameReference, name: EntityName | JSDocMemberName): JSDocNameReference;
                    createJSDocMemberName(left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
                    updateJSDocMemberName(node: JSDocMemberName, left: EntityName | JSDocMemberName, right: Identifier): JSDocMemberName;
                    createJSDocLink(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
                    updateJSDocLink(node: JSDocLink, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLink;
                    createJSDocLinkCode(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
                    updateJSDocLinkCode(node: JSDocLinkCode, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkCode;
                    createJSDocLinkPlain(name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
                    updateJSDocLinkPlain(node: JSDocLinkPlain, name: EntityName | JSDocMemberName | undefined, text: string): JSDocLinkPlain;
                    createJSDocTypeLiteral(jsDocPropertyTags?: readonly JSDocPropertyLikeTag[], isArrayType?: boolean): JSDocTypeLiteral;
                    updateJSDocTypeLiteral(node: JSDocTypeLiteral, jsDocPropertyTags: readonly JSDocPropertyLikeTag[] | undefined, isArrayType: boolean | undefined): JSDocTypeLiteral;
                    createJSDocSignature(typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag): JSDocSignature;
                    updateJSDocSignature(node: JSDocSignature, typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type: JSDocReturnTag | undefined): JSDocSignature;
                    createJSDocTemplateTag(tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment>): JSDocTemplateTag;
                    updateJSDocTemplateTag(node: JSDocTemplateTag, tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment: string | NodeArray<JSDocComment> | undefined): JSDocTemplateTag;
                    createJSDocTypedefTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | JSDocTypeLiteral, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocTypedefTag;
                    updateJSDocTypedefTag(node: JSDocTypedefTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | JSDocTypeLiteral | undefined, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypedefTag;
                    createJSDocParameterTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocParameterTag;
                    updateJSDocParameterTag(node: JSDocParameterTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocParameterTag;
                    createJSDocPropertyTag(tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression, isNameFirst?: boolean, comment?: string | NodeArray<JSDocComment>): JSDocPropertyTag;
                    updateJSDocPropertyTag(node: JSDocPropertyTag, tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression: JSDocTypeExpression | undefined, isNameFirst: boolean, comment: string | NodeArray<JSDocComment> | undefined): JSDocPropertyTag;
                    createJSDocTypeTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocTypeTag;
                    updateJSDocTypeTag(node: JSDocTypeTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocTypeTag;
                    createJSDocSeeTag(tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
                    updateJSDocSeeTag(node: JSDocSeeTag, tagName: Identifier | undefined, nameExpression: JSDocNameReference | undefined, comment?: string | NodeArray<JSDocComment>): JSDocSeeTag;
                    createJSDocReturnTag(tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocReturnTag;
                    updateJSDocReturnTag(node: JSDocReturnTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReturnTag;
                    createJSDocThisTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocThisTag;
                    updateJSDocThisTag(node: JSDocThisTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocThisTag;
                    createJSDocEnumTag(tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment>): JSDocEnumTag;
                    updateJSDocEnumTag(node: JSDocEnumTag, tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment: string | NodeArray<JSDocComment> | undefined): JSDocEnumTag;
                    createJSDocCallbackTag(tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration, comment?: string | NodeArray<JSDocComment>): JSDocCallbackTag;
                    updateJSDocCallbackTag(node: JSDocCallbackTag, tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName: Identifier | JSDocNamespaceDeclaration | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocCallbackTag;
                    createJSDocAugmentsTag(tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocAugmentsTag;
                    updateJSDocAugmentsTag(node: JSDocAugmentsTag, tagName: Identifier | undefined, className: JSDocAugmentsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocAugmentsTag;
                    createJSDocImplementsTag(tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment?: string | NodeArray<JSDocComment>): JSDocImplementsTag;
                    updateJSDocImplementsTag(node: JSDocImplementsTag, tagName: Identifier | undefined, className: JSDocImplementsTag["class"], comment: string | NodeArray<JSDocComment> | undefined): JSDocImplementsTag;
                    createJSDocAuthorTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocAuthorTag;
                    updateJSDocAuthorTag(node: JSDocAuthorTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocAuthorTag;
                    createJSDocClassTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocClassTag;
                    updateJSDocClassTag(node: JSDocClassTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocClassTag;
                    createJSDocPublicTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPublicTag;
                    updateJSDocPublicTag(node: JSDocPublicTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPublicTag;
                    createJSDocPrivateTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocPrivateTag;
                    updateJSDocPrivateTag(node: JSDocPrivateTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocPrivateTag;
                    createJSDocProtectedTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocProtectedTag;
                    updateJSDocProtectedTag(node: JSDocProtectedTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocProtectedTag;
                    createJSDocReadonlyTag(tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment>): JSDocReadonlyTag;
                    updateJSDocReadonlyTag(node: JSDocReadonlyTag, tagName: Identifier | undefined, comment: string | NodeArray<JSDocComment> | undefined): JSDocReadonlyTag;
                    createJSDocUnknownTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocUnknownTag;
                    updateJSDocUnknownTag(node: JSDocUnknownTag, tagName: Identifier, comment: string | NodeArray<JSDocComment> | undefined): JSDocUnknownTag;
                    createJSDocDeprecatedTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
                    updateJSDocDeprecatedTag(node: JSDocDeprecatedTag, tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocDeprecatedTag;
                    createJSDocOverrideTag(tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
                    updateJSDocOverrideTag(node: JSDocOverrideTag, tagName: Identifier, comment?: string | NodeArray<JSDocComment>): JSDocOverrideTag;
                    createJSDocText(text: string): JSDocText;
                    updateJSDocText(node: JSDocText, text: string): JSDocText;
                    createJSDocComment(comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined): JSDoc;
                    updateJSDocComment(node: JSDoc, comment: string | NodeArray<JSDocComment> | undefined, tags: readonly JSDocTag[] | undefined): JSDoc;
                    createJsxElement(openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
                    updateJsxElement(node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement): JsxElement;
                    createJsxSelfClosingElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
                    updateJsxSelfClosingElement(node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxSelfClosingElement;
                    createJsxOpeningElement(tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
                    updateJsxOpeningElement(node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes): JsxOpeningElement;
                    createJsxClosingElement(tagName: JsxTagNameExpression): JsxClosingElement;
                    updateJsxClosingElement(node: JsxClosingElement, tagName: JsxTagNameExpression): JsxClosingElement;
                    createJsxFragment(openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
                    createJsxText(text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
                    updateJsxText(node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean): JsxText;
                    createJsxOpeningFragment(): JsxOpeningFragment;
                    createJsxJsxClosingFragment(): JsxClosingFragment;
                    updateJsxFragment(node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment): JsxFragment;
                    createJsxAttribute(name: Identifier, initializer: JsxAttributeValue | undefined): JsxAttribute;
                    updateJsxAttribute(node: JsxAttribute, name: Identifier, initializer: JsxAttributeValue | undefined): JsxAttribute;
                    createJsxAttributes(properties: readonly JsxAttributeLike[]): JsxAttributes;
                    updateJsxAttributes(node: JsxAttributes, properties: readonly JsxAttributeLike[]): JsxAttributes;
                    createJsxSpreadAttribute(expression: Expression): JsxSpreadAttribute;
                    updateJsxSpreadAttribute(node: JsxSpreadAttribute, expression: Expression): JsxSpreadAttribute;
                    createJsxExpression(dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined): JsxExpression;
                    updateJsxExpression(node: JsxExpression, expression: Expression | undefined): JsxExpression;
                    createCaseClause(expression: Expression, statements: readonly Statement[]): CaseClause;
                    updateCaseClause(node: CaseClause, expression: Expression, statements: readonly Statement[]): CaseClause;
                    createDefaultClause(statements: readonly Statement[]): DefaultClause;
                    updateDefaultClause(node: DefaultClause, statements: readonly Statement[]): DefaultClause;
                    createHeritageClause(token: HeritageClause["token"], types: readonly ExpressionWithTypeArguments[]): HeritageClause;
                    updateHeritageClause(node: HeritageClause, types: readonly ExpressionWithTypeArguments[]): HeritageClause;
                    createCatchClause(variableDeclaration: string | BindingName | VariableDeclaration | undefined, block: Block): CatchClause;
                    updateCatchClause(node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block): CatchClause;
                    createPropertyAssignment(name: string | PropertyName, initializer: Expression): PropertyAssignment;
                    updatePropertyAssignment(node: PropertyAssignment, name: PropertyName, initializer: Expression): PropertyAssignment;
                    createShorthandPropertyAssignment(name: string | Identifier, objectAssignmentInitializer?: Expression): ShorthandPropertyAssignment;
                    updateShorthandPropertyAssignment(node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined): ShorthandPropertyAssignment;
                    createSpreadAssignment(expression: Expression): SpreadAssignment;
                    updateSpreadAssignment(node: SpreadAssignment, expression: Expression): SpreadAssignment;
                    createEnumMember(name: string | PropertyName, initializer?: Expression): EnumMember;
                    updateEnumMember(node: EnumMember, name: PropertyName, initializer: Expression | undefined): EnumMember;
                    createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;
                    updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;
                    createNotEmittedStatement(original: Node): NotEmittedStatement;
                    createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;
                    updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;
                    createCommaListExpression(elements: readonly Expression[]): CommaListExpression;
                    updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;
                    createBundle(sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;
                    updateBundle(node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;
                    createComma(left: Expression, right: Expression): BinaryExpression;
                    createAssignment(left: ObjectLiteralExpression | ArrayLiteralExpression, right: Expression): DestructuringAssignment;
                    createAssignment(left: Expression, right: Expression): AssignmentExpression<EqualsToken>;
                    createLogicalOr(left: Expression, right: Expression): BinaryExpression;
                    createLogicalAnd(left: Expression, right: Expression): BinaryExpression;
                    createBitwiseOr(left: Expression, right: Expression): BinaryExpression;
                    createBitwiseXor(left: Expression, right: Expression): BinaryExpression;
                    createBitwiseAnd(left: Expression, right: Expression): BinaryExpression;
                    createStrictEquality(left: Expression, right: Expression): BinaryExpression;
                    createStrictInequality(left: Expression, right: Expression): BinaryExpression;
                    createEquality(left: Expression, right: Expression): BinaryExpression;
                    createInequality(left: Expression, right: Expression): BinaryExpression;
                    createLessThan(left: Expression, right: Expression): BinaryExpression;
                    createLessThanEquals(left: Expression, right: Expression): BinaryExpression;
                    createGreaterThan(left: Expression, right: Expression): BinaryExpression;
                    createGreaterThanEquals(left: Expression, right: Expression): BinaryExpression;
                    createLeftShift(left: Expression, right: Expression): BinaryExpression;
                    createRightShift(left: Expression, right: Expression): BinaryExpression;
                    createUnsignedRightShift(left: Expression, right: Expression): BinaryExpression;
                    createAdd(left: Expression, right: Expression): BinaryExpression;
                    createSubtract(left: Expression, right: Expression): BinaryExpression;
                    createMultiply(left: Expression, right: Expression): BinaryExpression;
                    createDivide(left: Expression, right: Expression): BinaryExpression;
                    createModulo(left: Expression, right: Expression): BinaryExpression;
                    createExponent(left: Expression, right: Expression): BinaryExpression;
                    createPrefixPlus(operand: Expression): PrefixUnaryExpression;
                    createPrefixMinus(operand: Expression): PrefixUnaryExpression;
                    createPrefixIncrement(operand: Expression): PrefixUnaryExpression;
                    createPrefixDecrement(operand: Expression): PrefixUnaryExpression;
                    createBitwiseNot(operand: Expression): PrefixUnaryExpression;
                    createLogicalNot(operand: Expression): PrefixUnaryExpression;
                    createPostfixIncrement(operand: Expression): PostfixUnaryExpression;
                    createPostfixDecrement(operand: Expression): PostfixUnaryExpression;
                    createImmediatelyInvokedFunctionExpression(statements: readonly Statement[]): CallExpression;
                    createImmediatelyInvokedFunctionExpression(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
                    createImmediatelyInvokedArrowFunction(statements: readonly Statement[]): CallExpression;
                    createImmediatelyInvokedArrowFunction(statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
                    createVoidZero(): VoidExpression;
                    createExportDefault(expression: Expression): ExportAssignment;
                    createExternalModuleExport(exportName: Identifier): ExportDeclaration;
                    restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;
                }
                export interface NodeFactory {
                    /** @deprecated Use the overload that accepts 'modifiers' */
                    createConstructorTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
                    /** @deprecated Use the overload that accepts 'modifiers' */
                    updateConstructorTypeNode(node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
                }
                export interface NodeFactory {
                    createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
                    /** @deprecated Use the overload that accepts 'assertions' */
                    createImportTypeNode(argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
                    /** @deprecated Use the overload that accepts 'assertions' */
                    updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
                }
                export interface NodeFactory {
                    /** @deprecated Use the overload that accepts 'modifiers' */
                    createTypeParameterDeclaration(name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
                    /** @deprecated Use the overload that accepts 'modifiers' */
                    updateTypeParameterDeclaration(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
                }
                export interface NodeFactory {
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createParameterDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateParameterDeclaration(node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createPropertyDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updatePropertyDeclaration(node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createMethodDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateMethodDeclaration(node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                    /**
                     * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createConstructorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                    /**
                     * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateConstructorDeclaration(node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createGetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateGetAccessorDeclaration(node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createSetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateSetAccessorDeclaration(node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createIndexSignature(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
                    /**
                     * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
                     */
                    updateIndexSignature(node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
                    /**
                     * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
                     */
                    createClassStaticBlockDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createClassExpression(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateClassExpression(node: ClassExpression, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createFunctionDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateFunctionDeclaration(node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createClassDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                    /**
                     * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateClassDeclaration(node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createInterfaceDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createTypeAliasDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createEnumDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateEnumDeclaration(node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createModuleDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateModuleDeclaration(node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createImportEqualsDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createImportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateImportDeclaration(node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createExportAssignment(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateExportAssignment(node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    createExportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
                    /**
                     * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
                     */
                    updateExportDeclaration(node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
                }
                export interface CoreTransformationContext {
                    readonly factory: NodeFactory;
                    /** Gets the compiler options supplied to the transformer. */
                    getCompilerOptions(): CompilerOptions;
                    /** Starts a new lexical environment. */
                    startLexicalEnvironment(): void;
                    /** Suspends the current lexical environment, usually after visiting a parameter list. */
                    suspendLexicalEnvironment(): void;
                    /** Resumes a suspended lexical environment, usually before visiting a function body. */
                    resumeLexicalEnvironment(): void;
                    /** Ends a lexical environment, returning any declarations. */
                    endLexicalEnvironment(): Statement[] | undefined;
                    /** Hoists a function declaration to the containing scope. */
                    hoistFunctionDeclaration(node: FunctionDeclaration): void;
                    /** Hoists a variable declaration to the containing scope. */
                    hoistVariableDeclaration(node: Identifier): void;
                }
                export interface TransformationContext extends CoreTransformationContext {
                    /** Records a request for a non-scoped emit helper in the current context. */
                    requestEmitHelper(helper: EmitHelper): void;
                    /** Gets and resets the requested non-scoped emit helpers. */
                    readEmitHelpers(): EmitHelper[] | undefined;
                    /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */
                    enableSubstitution(kind: SyntaxKind): void;
                    /** Determines whether expression substitutions are enabled for the provided node. */
                    isSubstitutionEnabled(node: Node): boolean;
                    /**
                     * Hook used by transformers to substitute expressions just before they
                     * are emitted by the pretty printer.
                     *
                     * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
                     * before returning the `NodeTransformer` callback.
                     */
                    onSubstituteNode: (hint: EmitHint, node: Node) => Node;
                    /**
                     * Enables before/after emit notifications in the pretty printer for the provided
                     * SyntaxKind.
                     */
                    enableEmitNotification(kind: SyntaxKind): void;
                    /**
                     * Determines whether before/after emit notifications should be raised in the pretty
                     * printer when it emits a node.
                     */
                    isEmitNotificationEnabled(node: Node): boolean;
                    /**
                     * Hook used to allow transformers to capture state before or after
                     * the printer emits a node.
                     *
                     * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
                     * before returning the `NodeTransformer` callback.
                     */
                    onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
                }
                export interface TransformationResult<T extends Node> {
                    /** Gets the transformed source files. */
                    transformed: T[];
                    /** Gets diagnostics for the transformation. */
                    diagnostics?: DiagnosticWithLocation[];
                    /**
                     * Gets a substitute for a node, if one is available; otherwise, returns the original node.
                     *
                     * @param hint A hint as to the intended usage of the node.
                     * @param node The node to substitute.
                     */
                    substituteNode(hint: EmitHint, node: Node): Node;
                    /**
                     * Emits a node with possible notification.
                     *
                     * @param hint A hint as to the intended usage of the node.
                     * @param node The node to emit.
                     * @param emitCallback A callback used to emit the node.
                     */
                    emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
                    /**
                     * Indicates if a given node needs an emit notification
                     *
                     * @param node The node to emit.
                     */
                    isEmitNotificationEnabled?(node: Node): boolean;
                    /**
                     * Clean up EmitNode entries on any parse-tree nodes.
                     */
                    dispose(): void;
                }
                /**
                 * A function that is used to initialize and return a `Transformer` callback, which in turn
                 * will be used to transform one or more nodes.
                 */
                export type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;
                /**
                 * A function that transforms a node.
                 */
                export type Transformer<T extends Node> = (node: T) => T;
                /**
                 * A function that accepts and possibly transforms a node.
                 */
                export type Visitor = (node: Node) => VisitResult<Node>;
                export interface NodeVisitor {
                    <T extends Node>(nodes: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
                    <T extends Node>(nodes: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
                }
                export interface NodesVisitor {
                    <T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;
                    <T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;
                }
                export type VisitResult<T extends Node> = T | readonly T[] | undefined;
                export interface Printer {
                    /**
                     * Print a node and its subtree as-is, without any emit transformations.
                     * @param hint A value indicating the purpose of a node. This is primarily used to
                     * distinguish between an `Identifier` used in an expression position, versus an
                     * `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you
                     * should just pass `Unspecified`.
                     * @param node The node to print. The node and its subtree are printed as-is, without any
                     * emit transformations.
                     * @param sourceFile A source file that provides context for the node. The source text of
                     * the file is used to emit the original source content for literals and identifiers, while
                     * the identifiers of the source file are used when generating unique names to avoid
                     * collisions.
                     */
                    printNode(hint: EmitHint, node: Node, sourceFile: SourceFile): string;
                    /**
                     * Prints a list of nodes using the given format flags
                     */
                    printList<T extends Node>(format: ListFormat, list: NodeArray<T>, sourceFile: SourceFile): string;
                    /**
                     * Prints a source file as-is, without any emit transformations.
                     */
                    printFile(sourceFile: SourceFile): string;
                    /**
                     * Prints a bundle of source files as-is, without any emit transformations.
                     */
                    printBundle(bundle: Bundle): string;
                }
                export interface PrintHandlers {
                    /**
                     * A hook used by the Printer when generating unique names to avoid collisions with
                     * globally defined names that exist outside of the current source file.
                     */
                    hasGlobalName?(name: string): boolean;
                    /**
                     * A hook used by the Printer to provide notifications prior to emitting a node. A
                     * compatible implementation **must** invoke `emitCallback` with the provided `hint` and
                     * `node` values.
                     * @param hint A hint indicating the intended purpose of the node.
                     * @param node The node to emit.
                     * @param emitCallback A callback that, when invoked, will emit the node.
                     * @example
                     * ```ts
                     * var printer = createPrinter(printerOptions, {
                     *   onEmitNode(hint, node, emitCallback) {
                     *     // set up or track state prior to emitting the node...
                     *     emitCallback(hint, node);
                     *     // restore state after emitting the node...
                     *   }
                     * });
                     * ```
                     */
                    onEmitNode?(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
                    /**
                     * A hook used to check if an emit notification is required for a node.
                     * @param node The node to emit.
                     */
                    isEmitNotificationEnabled?(node: Node): boolean;
                    /**
                     * A hook used by the Printer to perform just-in-time substitution of a node. This is
                     * primarily used by node transformations that need to substitute one node for another,
                     * such as replacing `myExportedVar` with `exports.myExportedVar`.
                     * @param hint A hint indicating the intended purpose of the node.
                     * @param node The node to emit.
                     * @example
                     * ```ts
                     * var printer = createPrinter(printerOptions, {
                     *   substituteNode(hint, node) {
                     *     // perform substitution if necessary...
                     *     return node;
                     *   }
                     * });
                     * ```
                     */
                    substituteNode?(hint: EmitHint, node: Node): Node;
                }
                export interface PrinterOptions {
                    removeComments?: boolean;
                    newLine?: NewLineKind;
                    omitTrailingSemicolon?: boolean;
                    noEmitHelpers?: boolean;
                }
                export interface GetEffectiveTypeRootsHost {
                    directoryExists?(directoryName: string): boolean;
                    getCurrentDirectory?(): string;
                }
                export interface TextSpan {
                    start: number;
                    length: number;
                }
                export interface TextChangeRange {
                    span: TextSpan;
                    newLength: number;
                }
                export interface SyntaxList extends Node {
                    kind: SyntaxKind.SyntaxList;
                    _children: Node[];
                }
                export enum ListFormat {
                    None = 0,
                    SingleLine = 0,
                    MultiLine = 1,
                    PreserveLines = 2,
                    LinesMask = 3,
                    NotDelimited = 0,
                    BarDelimited = 4,
                    AmpersandDelimited = 8,
                    CommaDelimited = 16,
                    AsteriskDelimited = 32,
                    DelimitersMask = 60,
                    AllowTrailingComma = 64,
                    Indented = 128,
                    SpaceBetweenBraces = 256,
                    SpaceBetweenSiblings = 512,
                    Braces = 1024,
                    Parenthesis = 2048,
                    AngleBrackets = 4096,
                    SquareBrackets = 8192,
                    BracketsMask = 15360,
                    OptionalIfUndefined = 16384,
                    OptionalIfEmpty = 32768,
                    Optional = 49152,
                    PreferNewLine = 65536,
                    NoTrailingNewLine = 131072,
                    NoInterveningComments = 262144,
                    NoSpaceIfEmpty = 524288,
                    SingleElement = 1048576,
                    SpaceAfterList = 2097152,
                    Modifiers = 2359808,
                    HeritageClauses = 512,
                    SingleLineTypeLiteralMembers = 768,
                    MultiLineTypeLiteralMembers = 32897,
                    SingleLineTupleTypeElements = 528,
                    MultiLineTupleTypeElements = 657,
                    UnionTypeConstituents = 516,
                    IntersectionTypeConstituents = 520,
                    ObjectBindingPatternElements = 525136,
                    ArrayBindingPatternElements = 524880,
                    ObjectLiteralExpressionProperties = 526226,
                    ImportClauseEntries = 526226,
                    ArrayLiteralExpressionElements = 8914,
                    CommaListElements = 528,
                    CallExpressionArguments = 2576,
                    NewExpressionArguments = 18960,
                    TemplateExpressionSpans = 262144,
                    SingleLineBlockStatements = 768,
                    MultiLineBlockStatements = 129,
                    VariableDeclarationList = 528,
                    SingleLineFunctionBodyStatements = 768,
                    MultiLineFunctionBodyStatements = 1,
                    ClassHeritageClauses = 0,
                    ClassMembers = 129,
                    InterfaceMembers = 129,
                    EnumMembers = 145,
                    CaseBlockClauses = 129,
                    NamedImportsOrExportsElements = 525136,
                    JsxElementOrFragmentChildren = 262144,
                    JsxElementAttributes = 262656,
                    CaseOrDefaultClauseStatements = 163969,
                    HeritageClauseTypes = 528,
                    SourceFileStatements = 131073,
                    Decorators = 2146305,
                    TypeArguments = 53776,
                    TypeParameters = 53776,
                    Parameters = 2576,
                    IndexSignatureParameters = 8848,
                    JSDocComment = 33
                }
                export interface UserPreferences {
                    readonly disableSuggestions?: boolean;
                    readonly quotePreference?: "auto" | "double" | "single";
                    readonly includeCompletionsForModuleExports?: boolean;
                    readonly includeCompletionsForImportStatements?: boolean;
                    readonly includeCompletionsWithSnippetText?: boolean;
                    readonly includeAutomaticOptionalChainCompletions?: boolean;
                    readonly includeCompletionsWithInsertText?: boolean;
                    readonly includeCompletionsWithClassMemberSnippets?: boolean;
                    readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;
                    readonly useLabelDetailsInCompletionEntries?: boolean;
                    readonly allowIncompleteCompletions?: boolean;
                    readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";
                    /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */
                    readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";
                    readonly allowTextChangesInNewFiles?: boolean;
                    readonly providePrefixAndSuffixTextForRename?: boolean;
                    readonly includePackageJsonAutoImports?: "auto" | "on" | "off";
                    readonly provideRefactorNotApplicableReason?: boolean;
                    readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";
                    readonly includeInlayParameterNameHints?: "none" | "literals" | "all";
                    readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
                    readonly includeInlayFunctionParameterTypeHints?: boolean;
                    readonly includeInlayVariableTypeHints?: boolean;
                    readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;
                    readonly includeInlayPropertyDeclarationTypeHints?: boolean;
                    readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
                    readonly includeInlayEnumMemberValueHints?: boolean;
                    readonly allowRenameOfImportPath?: boolean;
                    readonly autoImportFileExcludePatterns?: string[];
                }
                /** Represents a bigint literal value without requiring bigint support */
                export interface PseudoBigInt {
                    negative: boolean;
                    base10Value: string;
                }
                export function getNodeMajorVersion(): number | undefined;
                export enum FileWatcherEventKind {
                    Created = 0,
                    Changed = 1,
                    Deleted = 2
                }
                export type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind, modifiedTime?: Date) => void;
                export type DirectoryWatcherCallback = (fileName: string) => void;
                export interface System {
                    args: string[];
                    newLine: string;
                    useCaseSensitiveFileNames: boolean;
                    write(s: string): void;
                    writeOutputIsTTY?(): boolean;
                    getWidthOfTerminal?(): number;
                    readFile(path: string, encoding?: string): string | undefined;
                    getFileSize?(path: string): number;
                    writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;
                    /**
                     * @pollingInterval - this parameter is used in polling-based watchers and ignored in watchers that
                     * use native OS file watching
                     */
                    watchFile?(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
                    watchDirectory?(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
                    resolvePath(path: string): string;
                    fileExists(path: string): boolean;
                    directoryExists(path: string): boolean;
                    createDirectory(path: string): void;
                    getExecutingFilePath(): string;
                    getCurrentDirectory(): string;
                    getDirectories(path: string): string[];
                    readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
                    getModifiedTime?(path: string): Date | undefined;
                    setModifiedTime?(path: string, time: Date): void;
                    deleteFile?(path: string): void;
                    /**
                     * A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)
                     */
                    createHash?(data: string): string;
                    /** This must be cryptographically secure. Only implement this method using `crypto.createHash("sha256")`. */
                    createSHA256Hash?(data: string): string;
                    getMemoryUsage?(): number;
                    exit(exitCode?: number): void;
                    realpath?(path: string): string;
                    setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
                    clearTimeout?(timeoutId: any): void;
                    clearScreen?(): void;
                    base64decode?(input: string): string;
                    base64encode?(input: string): string;
                }
                export interface FileWatcher {
                    close(): void;
                }
                export let sys: System;
                function tokenToString(t: SyntaxKind): string | undefined;
                function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
                function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
                function isWhiteSpaceLike(ch: number): boolean;
                /** Does not include line breaks. For that, see isWhiteSpaceLike. */
                function isWhiteSpaceSingleLine(ch: number): boolean;
                function isLineBreak(ch: number): boolean;
                function couldStartTrivia(text: string, pos: number): boolean;
                function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
                function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
                function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
                function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
                function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
                function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
                function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
                function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
                /** Optionally, get the shebang */
                function getShebang(text: string): string | undefined;
                function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
                function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
                function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
                export type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
                export interface Scanner {
                    getStartPos(): number;
                    getToken(): SyntaxKind;
                    getTextPos(): number;
                    getTokenPos(): number;
                    getTokenText(): string;
                    getTokenValue(): string;
                    hasUnicodeEscape(): boolean;
                    hasExtendedUnicodeEscape(): boolean;
                    hasPrecedingLineBreak(): boolean;
                    isIdentifier(): boolean;
                    isReservedWord(): boolean;
                    isUnterminated(): boolean;
                    reScanGreaterToken(): SyntaxKind;
                    reScanSlashToken(): SyntaxKind;
                    reScanAsteriskEqualsToken(): SyntaxKind;
                    reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind;
                    reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind;
                    scanJsxIdentifier(): SyntaxKind;
                    scanJsxAttributeValue(): SyntaxKind;
                    reScanJsxAttributeValue(): SyntaxKind;
                    reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind;
                    reScanLessThanToken(): SyntaxKind;
                    reScanHashToken(): SyntaxKind;
                    reScanQuestionToken(): SyntaxKind;
                    reScanInvalidIdentifier(): SyntaxKind;
                    scanJsxToken(): JsxTokenSyntaxKind;
                    scanJsDocToken(): JSDocSyntaxKind;
                    scan(): SyntaxKind;
                    getText(): string;
                    setText(text: string | undefined, start?: number, length?: number): void;
                    setOnError(onError: ErrorCallback | undefined): void;
                    setScriptTarget(scriptTarget: ScriptTarget): void;
                    setLanguageVariant(variant: LanguageVariant): void;
                    setTextPos(textPos: number): void;
                    lookAhead<T>(callback: () => T): T;
                    scanRange<T>(start: number, length: number, callback: () => T): T;
                    tryScan<T>(callback: () => T): T;
                }
                function isExternalModuleNameRelative(moduleName: string): boolean;
                function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
                function getDefaultLibFileName(options: CompilerOptions): string;
                function textSpanEnd(span: TextSpan): number;
                function textSpanIsEmpty(span: TextSpan): boolean;
                function textSpanContainsPosition(span: TextSpan, position: number): boolean;
                function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
                function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
                function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
                function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
                function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
                function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
                function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
                function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
                function createTextSpan(start: number, length: number): TextSpan;
                function createTextSpanFromBounds(start: number, end: number): TextSpan;
                function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
                function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
                function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
                /**
                 * Called to merge all the changes that occurred across several versions of a script snapshot
                 * into a single change.  i.e. if a user keeps making successive edits to a script we will
                 * have a text change from V1 to V2, V2 to V3, ..., Vn.
                 *
                 * This function will then merge those changes into a single change range valid between V1 and
                 * Vn.
                 */
                function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
                function getTypeParameterOwner(d: Declaration): Declaration | undefined;
                function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
                function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
                function isEmptyBindingElement(node: BindingElement): boolean;
                function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
                function getCombinedModifierFlags(node: Declaration): ModifierFlags;
                function getCombinedNodeFlags(node: Node): NodeFlags;
                /**
                 * Checks to see if the locale is in the appropriate format,
                 * and if it is, attempts to set the appropriate language.
                 */
                function validateLocaleAndSetLanguage(locale: string, sys: {
                    getExecutingFilePath(): string;
                    resolvePath(path: string): string;
                    fileExists(fileName: string): boolean;
                    readFile(fileName: string): string | undefined;
                }, errors?: Push<Diagnostic>): void;
                function getOriginalNode(node: Node): Node;
                function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
                function getOriginalNode(node: Node | undefined): Node | undefined;
                function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node | undefined) => node is T): T | undefined;
                /**
                 * Iterates through the parent chain of a node and performs the callback on each parent until the callback
                 * returns a truthy value, then returns that value.
                 * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"
                 * At that point findAncestor returns undefined.
                 */
                function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
                function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
                /**
                 * Gets a value indicating whether a node originated in the parse tree.
                 *
                 * @param node The node to test.
                 */
                function isParseTreeNode(node: Node): boolean;
                /**
                 * Gets the original parse tree node for a node.
                 *
                 * @param node The original node.
                 * @returns The original parse tree node if found; otherwise, undefined.
                 */
                function getParseTreeNode(node: Node | undefined): Node | undefined;
                /**
                 * Gets the original parse tree node for a node.
                 *
                 * @param node The original node.
                 * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
                 * @returns The original parse tree node if found; otherwise, undefined.
                 */
                function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
                /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
                function escapeLeadingUnderscores(identifier: string): __String;
                /**
                 * Remove extra underscore from escaped identifier text content.
                 *
                 * @param identifier The escaped identifier text.
                 * @returns The unescaped identifier text.
                 */
                function unescapeLeadingUnderscores(identifier: __String): string;
                function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
                function symbolName(symbol: Symbol): string;
                function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
                function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
                function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
                function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
                /**
                 * Gets the JSDoc parameter tags for the node if present.
                 *
                 * @remarks Returns any JSDoc param tag whose name matches the provided
                 * parameter, whether a param tag on a containing function
                 * expression, or a param tag on a variable declaration whose
                 * initializer is the containing function. The tags closest to the
                 * node are returned first, so in the previous example, the param
                 * tag on the containing function expression would be first.
                 *
                 * For binding patterns, parameter tags are matched by position.
                 */
                function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
                /**
                 * Gets the JSDoc type parameter tags for the node if present.
                 *
                 * @remarks Returns any JSDoc template tag whose names match the provided
                 * parameter, whether a template tag on a containing function
                 * expression, or a template tag on a variable declaration whose
                 * initializer is the containing function. The tags closest to the
                 * node are returned first, so in the previous example, the template
                 * tag on the containing function expression would be first.
                 */
                function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
                /**
                 * Return true if the node has JSDoc parameter tags.
                 *
                 * @remarks Includes parameter tags that are not directly on the node,
                 * for example on a variable declaration whose initializer is a function expression.
                 */
                function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
                /** Gets the JSDoc augments tag for the node if present */
                function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
                /** Gets the JSDoc implements tags for the node if present */
                function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
                /** Gets the JSDoc class tag for the node if present */
                function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
                /** Gets the JSDoc public tag for the node if present */
                function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
                /** Gets the JSDoc private tag for the node if present */
                function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
                /** Gets the JSDoc protected tag for the node if present */
                function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
                /** Gets the JSDoc protected tag for the node if present */
                function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
                function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
                /** Gets the JSDoc deprecated tag for the node if present */
                function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
                /** Gets the JSDoc enum tag for the node if present */
                function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
                /** Gets the JSDoc this tag for the node if present */
                function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
                /** Gets the JSDoc return tag for the node if present */
                function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
                /** Gets the JSDoc template tag for the node if present */
                function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
                /** Gets the JSDoc type tag for the node if present and valid */
                function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
                /**
                 * Gets the type node for the node if provided via JSDoc.
                 *
                 * @remarks The search includes any JSDoc param tag that relates
                 * to the provided parameter, for example a type tag on the
                 * parameter itself, or a param tag on a containing function
                 * expression, or a param tag on a variable declaration whose
                 * initializer is the containing function. The tags closest to the
                 * node are examined first, so in the previous example, the type
                 * tag directly on the node would be returned.
                 */
                function getJSDocType(node: Node): TypeNode | undefined;
                /**
                 * Gets the return type node for the node if provided via JSDoc return tag or type tag.
                 *
                 * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
                 * gets the type from inside the braces, after the fat arrow, etc.
                 */
                function getJSDocReturnType(node: Node): TypeNode | undefined;
                /** Get all JSDoc tags related to a node, including those on parent nodes. */
                function getJSDocTags(node: Node): readonly JSDocTag[];
                /** Gets all JSDoc tags that match a specified predicate */
                function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
                /** Gets all JSDoc tags of a specified kind */
                function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
                /** Gets the text of a jsdoc comment, flattening links to their text. */
                function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
                /**
                 * Gets the effective type parameters. If the node was parsed in a
                 * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
                 *
                 * This does *not* return type parameters from a jsdoc reference to a generic type, eg
                 *
                 * type Id = <T>(x: T) => T
                 * /** @type {Id} /
                 * function id(x) { return x }
                 */
                function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
                function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
                function isMemberName(node: Node): node is MemberName;
                function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
                function isElementAccessChain(node: Node): node is ElementAccessChain;
                function isCallChain(node: Node): node is CallChain;
                function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
                function isNullishCoalesce(node: Node): boolean;
                function isConstTypeReference(node: Node): boolean;
                function skipPartiallyEmittedExpressions(node: Expression): Expression;
                function skipPartiallyEmittedExpressions(node: Node): Node;
                function isNonNullChain(node: Node): node is NonNullChain;
                function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
                function isNamedExportBindings(node: Node): node is NamedExportBindings;
                function isUnparsedTextLike(node: Node): node is UnparsedTextLike;
                function isUnparsedNode(node: Node): node is UnparsedNode;
                function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
                /**
                 * True if kind is of some token syntax kind.
                 * For example, this is true for an IfKeyword but not for an IfStatement.
                 * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
                 */
                function isTokenKind(kind: SyntaxKind): boolean;
                /**
                 * True if node is of some token syntax kind.
                 * For example, this is true for an IfKeyword but not for an IfStatement.
                 * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
                 */
                function isToken(n: Node): boolean;
                function isLiteralExpression(node: Node): node is LiteralExpression;
                function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
                function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
                function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
                function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
                function isAssertionKey(node: Node): node is AssertionKey;
                function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
                function isModifier(node: Node): node is Modifier;
                function isEntityName(node: Node): node is EntityName;
                function isPropertyName(node: Node): node is PropertyName;
                function isBindingName(node: Node): node is BindingName;
                function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
                function isClassElement(node: Node): node is ClassElement;
                function isClassLike(node: Node): node is ClassLikeDeclaration;
                function isAccessor(node: Node): node is AccessorDeclaration;
                function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
                function isModifierLike(node: Node): node is ModifierLike;
                function isTypeElement(node: Node): node is TypeElement;
                function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
                function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
                /**
                 * Node test that determines whether a node is a valid type node.
                 * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
                 * of a TypeNode.
                 */
                function isTypeNode(node: Node): node is TypeNode;
                function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
                function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
                function isCallLikeExpression(node: Node): node is CallLikeExpression;
                function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
                function isTemplateLiteral(node: Node): node is TemplateLiteral;
                function isAssertionExpression(node: Node): node is AssertionExpression;
                function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
                function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
                function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
                function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
                /** True if node is of a kind that may contain comment text. */
                function isJSDocCommentContainingNode(node: Node): boolean;
                function isSetAccessor(node: Node): node is SetAccessorDeclaration;
                function isGetAccessor(node: Node): node is GetAccessorDeclaration;
                /** True if has initializer node attached to it. */
                function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
                function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
                function isStringLiteralLike(node: Node): node is StringLiteralLike;
                function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
                function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
                function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
                export let unchangedTextChangeRange: TextChangeRange;
                export type ParameterPropertyDeclaration = ParameterDeclaration & {
                    parent: ConstructorDeclaration;
                    name: Identifier;
                };
                function createUnparsedSourceFile(text: string): UnparsedSource;
                function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;
                function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;
                function createInputFiles(javascriptText: string, declarationText: string): InputFiles;
                function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;
                function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;
                /**
                 * Create an external source map source file reference
                 */
                function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
                function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
                export const factory: NodeFactory;
                /**
                 * Clears any `EmitNode` entries from parse-tree nodes.
                 * @param sourceFile A source file.
                 */
                function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
                /**
                 * Sets flags that control emit behavior of a node.
                 */
                function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
                /**
                 * Gets a custom text range to use when emitting source maps.
                 */
                function getSourceMapRange(node: Node): SourceMapRange;
                /**
                 * Sets a custom text range to use when emitting source maps.
                 */
                function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
                /**
                 * Gets the TextRange to use for source maps for a token of a node.
                 */
                function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
                /**
                 * Sets the TextRange to use for source maps for a token of a node.
                 */
                function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
                /**
                 * Gets a custom text range to use when emitting comments.
                 */
                function getCommentRange(node: Node): TextRange;
                /**
                 * Sets a custom text range to use when emitting comments.
                 */
                function setCommentRange<T extends Node>(node: T, range: TextRange): T;
                function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
                function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
                function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
                function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
                function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
                function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
                function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
                /**
                 * Gets the constant value to emit for an expression representing an enum.
                 */
                function getConstantValue(node: AccessExpression): string | number | undefined;
                /**
                 * Sets the constant value to emit for an expression.
                 */
                function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
                /**
                 * Adds an EmitHelper to a node.
                 */
                function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
                /**
                 * Add EmitHelpers to a node.
                 */
                function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
                /**
                 * Removes an EmitHelper from a node.
                 */
                function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
                /**
                 * Gets the EmitHelpers of a node.
                 */
                function getEmitHelpers(node: Node): EmitHelper[] | undefined;
                /**
                 * Moves matching emit helpers from a source node to a target node.
                 */
                function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
                function isNumericLiteral(node: Node): node is NumericLiteral;
                function isBigIntLiteral(node: Node): node is BigIntLiteral;
                function isStringLiteral(node: Node): node is StringLiteral;
                function isJsxText(node: Node): node is JsxText;
                function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
                function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
                function isTemplateHead(node: Node): node is TemplateHead;
                function isTemplateMiddle(node: Node): node is TemplateMiddle;
                function isTemplateTail(node: Node): node is TemplateTail;
                function isDotDotDotToken(node: Node): node is DotDotDotToken;
                function isPlusToken(node: Node): node is PlusToken;
                function isMinusToken(node: Node): node is MinusToken;
                function isAsteriskToken(node: Node): node is AsteriskToken;
                function isIdentifier(node: Node): node is Identifier;
                function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
                function isQualifiedName(node: Node): node is QualifiedName;
                function isComputedPropertyName(node: Node): node is ComputedPropertyName;
                function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
                function isParameter(node: Node): node is ParameterDeclaration;
                function isDecorator(node: Node): node is Decorator;
                function isPropertySignature(node: Node): node is PropertySignature;
                function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
                function isMethodSignature(node: Node): node is MethodSignature;
                function isMethodDeclaration(node: Node): node is MethodDeclaration;
                function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
                function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
                function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
                function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
                function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
                function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
                function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
                function isTypePredicateNode(node: Node): node is TypePredicateNode;
                function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
                function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
                function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
                function isTypeQueryNode(node: Node): node is TypeQueryNode;
                function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
                function isArrayTypeNode(node: Node): node is ArrayTypeNode;
                function isTupleTypeNode(node: Node): node is TupleTypeNode;
                function isNamedTupleMember(node: Node): node is NamedTupleMember;
                function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
                function isRestTypeNode(node: Node): node is RestTypeNode;
                function isUnionTypeNode(node: Node): node is UnionTypeNode;
                function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
                function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
                function isInferTypeNode(node: Node): node is InferTypeNode;
                function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
                function isThisTypeNode(node: Node): node is ThisTypeNode;
                function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
                function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
                function isMappedTypeNode(node: Node): node is MappedTypeNode;
                function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
                function isImportTypeNode(node: Node): node is ImportTypeNode;
                function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
                function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
                function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
                function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
                function isBindingElement(node: Node): node is BindingElement;
                function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
                function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
                function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
                function isElementAccessExpression(node: Node): node is ElementAccessExpression;
                function isCallExpression(node: Node): node is CallExpression;
                function isNewExpression(node: Node): node is NewExpression;
                function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
                function isTypeAssertionExpression(node: Node): node is TypeAssertion;
                function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
                function isFunctionExpression(node: Node): node is FunctionExpression;
                function isArrowFunction(node: Node): node is ArrowFunction;
                function isDeleteExpression(node: Node): node is DeleteExpression;
                function isTypeOfExpression(node: Node): node is TypeOfExpression;
                function isVoidExpression(node: Node): node is VoidExpression;
                function isAwaitExpression(node: Node): node is AwaitExpression;
                function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
                function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
                function isBinaryExpression(node: Node): node is BinaryExpression;
                function isConditionalExpression(node: Node): node is ConditionalExpression;
                function isTemplateExpression(node: Node): node is TemplateExpression;
                function isYieldExpression(node: Node): node is YieldExpression;
                function isSpreadElement(node: Node): node is SpreadElement;
                function isClassExpression(node: Node): node is ClassExpression;
                function isOmittedExpression(node: Node): node is OmittedExpression;
                function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
                function isAsExpression(node: Node): node is AsExpression;
                function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
                function isNonNullExpression(node: Node): node is NonNullExpression;
                function isMetaProperty(node: Node): node is MetaProperty;
                function isSyntheticExpression(node: Node): node is SyntheticExpression;
                function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
                function isCommaListExpression(node: Node): node is CommaListExpression;
                function isTemplateSpan(node: Node): node is TemplateSpan;
                function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
                function isBlock(node: Node): node is Block;
                function isVariableStatement(node: Node): node is VariableStatement;
                function isEmptyStatement(node: Node): node is EmptyStatement;
                function isExpressionStatement(node: Node): node is ExpressionStatement;
                function isIfStatement(node: Node): node is IfStatement;
                function isDoStatement(node: Node): node is DoStatement;
                function isWhileStatement(node: Node): node is WhileStatement;
                function isForStatement(node: Node): node is ForStatement;
                function isForInStatement(node: Node): node is ForInStatement;
                function isForOfStatement(node: Node): node is ForOfStatement;
                function isContinueStatement(node: Node): node is ContinueStatement;
                function isBreakStatement(node: Node): node is BreakStatement;
                function isReturnStatement(node: Node): node is ReturnStatement;
                function isWithStatement(node: Node): node is WithStatement;
                function isSwitchStatement(node: Node): node is SwitchStatement;
                function isLabeledStatement(node: Node): node is LabeledStatement;
                function isThrowStatement(node: Node): node is ThrowStatement;
                function isTryStatement(node: Node): node is TryStatement;
                function isDebuggerStatement(node: Node): node is DebuggerStatement;
                function isVariableDeclaration(node: Node): node is VariableDeclaration;
                function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
                function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
                function isClassDeclaration(node: Node): node is ClassDeclaration;
                function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
                function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
                function isEnumDeclaration(node: Node): node is EnumDeclaration;
                function isModuleDeclaration(node: Node): node is ModuleDeclaration;
                function isModuleBlock(node: Node): node is ModuleBlock;
                function isCaseBlock(node: Node): node is CaseBlock;
                function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
                function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
                function isImportDeclaration(node: Node): node is ImportDeclaration;
                function isImportClause(node: Node): node is ImportClause;
                function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
                function isAssertClause(node: Node): node is AssertClause;
                function isAssertEntry(node: Node): node is AssertEntry;
                function isNamespaceImport(node: Node): node is NamespaceImport;
                function isNamespaceExport(node: Node): node is NamespaceExport;
                function isNamedImports(node: Node): node is NamedImports;
                function isImportSpecifier(node: Node): node is ImportSpecifier;
                function isExportAssignment(node: Node): node is ExportAssignment;
                function isExportDeclaration(node: Node): node is ExportDeclaration;
                function isNamedExports(node: Node): node is NamedExports;
                function isExportSpecifier(node: Node): node is ExportSpecifier;
                function isMissingDeclaration(node: Node): node is MissingDeclaration;
                function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
                function isExternalModuleReference(node: Node): node is ExternalModuleReference;
                function isJsxElement(node: Node): node is JsxElement;
                function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
                function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
                function isJsxClosingElement(node: Node): node is JsxClosingElement;
                function isJsxFragment(node: Node): node is JsxFragment;
                function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
                function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
                function isJsxAttribute(node: Node): node is JsxAttribute;
                function isJsxAttributes(node: Node): node is JsxAttributes;
                function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
                function isJsxExpression(node: Node): node is JsxExpression;
                function isCaseClause(node: Node): node is CaseClause;
                function isDefaultClause(node: Node): node is DefaultClause;
                function isHeritageClause(node: Node): node is HeritageClause;
                function isCatchClause(node: Node): node is CatchClause;
                function isPropertyAssignment(node: Node): node is PropertyAssignment;
                function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
                function isSpreadAssignment(node: Node): node is SpreadAssignment;
                function isEnumMember(node: Node): node is EnumMember;
                function isUnparsedPrepend(node: Node): node is UnparsedPrepend;
                function isSourceFile(node: Node): node is SourceFile;
                function isBundle(node: Node): node is Bundle;
                function isUnparsedSource(node: Node): node is UnparsedSource;
                function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
                function isJSDocNameReference(node: Node): node is JSDocNameReference;
                function isJSDocMemberName(node: Node): node is JSDocMemberName;
                function isJSDocLink(node: Node): node is JSDocLink;
                function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
                function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
                function isJSDocAllType(node: Node): node is JSDocAllType;
                function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
                function isJSDocNullableType(node: Node): node is JSDocNullableType;
                function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
                function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
                function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
                function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
                function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
                function isJSDoc(node: Node): node is JSDoc;
                function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
                function isJSDocSignature(node: Node): node is JSDocSignature;
                function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
                function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
                function isJSDocClassTag(node: Node): node is JSDocClassTag;
                function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
                function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
                function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
                function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
                function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
                function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
                function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
                function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
                function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
                function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
                function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
                function isJSDocThisTag(node: Node): node is JSDocThisTag;
                function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
                function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
                function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
                function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
                function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
                function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
                function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
                function canHaveModifiers(node: Node): node is HasModifiers;
                function canHaveDecorators(node: Node): node is HasDecorators;
                /**
                 * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
                 * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
                 * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
                 * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
                 *
                 * @param node a given node to visit its children
                 * @param cbNode a callback to be invoked for all child nodes
                 * @param cbNodes a callback to be invoked for embedded array
                 *
                 * @remarks `forEachChild` must visit the children of a node in the order
                 * that they appear in the source code. The language service depends on this property to locate nodes by position.
                 */
                export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
                export function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;
                export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;
                /**
                 * Parse json text into SyntaxTree and return node and parse errors if any
                 * @param fileName
                 * @param sourceText
                 */
                export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;
                export function isExternalModule(file: SourceFile): boolean;
                export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
                export interface CreateSourceFileOptions {
                    languageVersion: ScriptTarget;
                    /**
                     * Controls the format the file is detected as - this can be derived from only the path
                     * and files on disk, but needs to be done with a module resolution cache in scope to be performant.
                     * This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.
                     */
                    impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;
                    /**
                     * Controls how module-y-ness is set for the given file. Usually the result of calling
                     * `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default
                     * check specified by `isFileProbablyExternalModule` will be used to set the field.
                     */
                    setExternalModuleIndicator?: (file: SourceFile) => void;
                }
                export function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
                /**
                 * Reads the config file, reports errors if any and exits if the config file cannot be found
                 */
                export function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map<ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;
                /**
                 * Read tsconfig.json file
                 * @param fileName The path to the config file
                 */
                export function readConfigFile(fileName: string, readFile: (path: string) => string | undefined): {
                    config?: any;
                    error?: Diagnostic;
                };
                /**
                 * Parse the text of the tsconfig.json file
                 * @param fileName The path to the config file
                 * @param jsonText The text of the config file
                 */
                export function parseConfigFileTextToJson(fileName: string, jsonText: string): {
                    config?: any;
                    error?: Diagnostic;
                };
                /**
                 * Read tsconfig.json file
                 * @param fileName The path to the config file
                 */
                export function readJsonConfigFile(fileName: string, readFile: (path: string) => string | undefined): TsConfigSourceFile;
                /**
                 * Convert the json syntax tree into the json value
                 */
                export function convertToObject(sourceFile: JsonSourceFile, errors: Push<Diagnostic>): any;
                /**
                 * Parse the contents of a config file (tsconfig.json).
                 * @param json The contents of the config file to parse
                 * @param host Instance of ParseConfigHost used to enumerate files in folder.
                 * @param basePath A root directory to resolve relative path entries in the config
                 *    file to. e.g. outDir
                 */
                export function parseJsonConfigFileContent(json: any, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
                /**
                 * Parse the contents of a config file (tsconfig.json).
                 * @param jsonNode The contents of the config file to parse
                 * @param host Instance of ParseConfigHost used to enumerate files in folder.
                 * @param basePath A root directory to resolve relative path entries in the config
                 *    file to. e.g. outDir
                 */
                export function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
                export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
                    options: CompilerOptions;
                    errors: Diagnostic[];
                };
                export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
                    options: TypeAcquisition;
                    errors: Diagnostic[];
                };
                export type DiagnosticReporter = (diagnostic: Diagnostic) => void;
                /**
                 * Reports config file diagnostics
                 */
                export interface ConfigFileDiagnosticsReporter {
                    /**
                     * Reports unrecoverable error when parsing config file
                     */
                    onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
                }
                /**
                 * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
                 */
                export interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
                    getCurrentDirectory(): string;
                }
                export interface ParsedTsconfig {
                    raw: any;
                    options?: CompilerOptions;
                    watchOptions?: WatchOptions;
                    typeAcquisition?: TypeAcquisition;
                    /**
                     * Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet
                     */
                    extendedConfigPath?: string;
                }
                export interface ExtendedConfigCacheEntry {
                    extendedResult: TsConfigSourceFile;
                    extendedConfig: ParsedTsconfig | undefined;
                }
                export function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;
                /**
                 * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
                 * This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups
                 * is assumed to be the same as root directory of the project.
                 */
                export function resolveTypeReferenceDirective(typeReferenceDirectiveName: string, containingFile: string | undefined, options: CompilerOptions, host: ModuleResolutionHost, redirectedReference?: ResolvedProjectReference, cache?: TypeReferenceDirectiveResolutionCache, resolutionMode?: SourceFile["impliedNodeFormat"]): ResolvedTypeReferenceDirectiveWithFailedLookupLocations;
                /**
                 * Given a set of options, returns the set of type directive names
                 *   that should be included for this program automatically.
                 * This list could either come from the config file,
                 *   or from enumerating the types root + initial secondary types lookup location.
                 * More type directives might appear in the program later as a result of loading actual source files;
                 *   this list is only the set of defaults that are implicitly included.
                 */
                export function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];
                export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;
                export function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
                export function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
                export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations;
                export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
                export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
                export interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {
                }
                export interface ModeAwareCache<T> {
                    get(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined): T | undefined;
                    set(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined, value: T): this;
                    delete(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined): this;
                    has(key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined): boolean;
                    forEach(cb: (elem: T, key: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined) => void): void;
                    size(): number;
                }
                /**
                 * Cached resolutions per containing directory.
                 * This assumes that any module id will have the same resolution for sibling files located in the same folder.
                 */
                export interface PerDirectoryResolutionCache<T> {
                    getOrCreateCacheForDirectory(directoryName: string, redirectedReference?: ResolvedProjectReference): ModeAwareCache<T>;
                    clear(): void;
                    /**
                     *  Updates with the current compilerOptions the cache will operate with.
                     *  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects
                     */
                    update(options: CompilerOptions): void;
                }
                export interface ModuleResolutionCache extends PerDirectoryResolutionCache<ResolvedModuleWithFailedLookupLocations>, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {
                    getPackageJsonInfoCache(): PackageJsonInfoCache;
                }
                /**
                 * Stored map from non-relative module name to a table: directory -> result of module lookup in this directory
                 * We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.
                 */
                export interface NonRelativeModuleNameResolutionCache extends PackageJsonInfoCache {
                    getOrCreateCacheForModuleName(nonRelativeModuleName: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined, redirectedReference?: ResolvedProjectReference): PerModuleNameCache;
                }
                export interface PackageJsonInfoCache {
                    clear(): void;
                }
                export interface PerModuleNameCache {
                    get(directory: string): ResolvedModuleWithFailedLookupLocations | undefined;
                    set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;
                }
                /**
                 * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
                 *
                 * @param node The Node to visit.
                 * @param visitor The callback used to visit the Node.
                 * @param test A callback to execute to verify the Node is valid.
                 * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
                 */
                function visitNode<T extends Node>(node: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
                /**
                 * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
                 *
                 * @param node The Node to visit.
                 * @param visitor The callback used to visit the Node.
                 * @param test A callback to execute to verify the Node is valid.
                 * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
                 */
                function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
                /**
                 * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
                 *
                 * @param nodes The NodeArray to visit.
                 * @param visitor The callback used to visit a Node.
                 * @param test A node test to execute for each node.
                 * @param start An optional value indicating the starting offset at which to start visiting.
                 * @param count An optional value indicating the maximum number of nodes to visit.
                 */
                function visitNodes<T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;
                /**
                 * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
                 *
                 * @param nodes The NodeArray to visit.
                 * @param visitor The callback used to visit a Node.
                 * @param test A node test to execute for each node.
                 * @param start An optional value indicating the starting offset at which to start visiting.
                 * @param count An optional value indicating the maximum number of nodes to visit.
                 */
                function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;
                /**
                 * Starts a new lexical environment and visits a statement list, ending the lexical environment
                 * and merging hoisted declarations upon completion.
                 */
                function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
                /**
                 * Starts a new lexical environment and visits a parameter list, suspending the lexical
                 * environment upon completion.
                 */
                function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
                function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
                /**
                 * Resumes a suspended lexical environment and visits a function body, ending the lexical
                 * environment and merging hoisted declarations upon completion.
                 */
                function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
                /**
                 * Resumes a suspended lexical environment and visits a function body, ending the lexical
                 * environment and merging hoisted declarations upon completion.
                 */
                function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
                /**
                 * Resumes a suspended lexical environment and visits a concise body, ending the lexical
                 * environment and merging hoisted declarations upon completion.
                 */
                function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
                /**
                 * Visits an iteration body, adding any block-scoped variables required by the transformation.
                 */
                function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
                /**
                 * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
                 *
                 * @param node The Node whose children will be visited.
                 * @param visitor The callback used to visit each child.
                 * @param context A lexical environment context for the visitor.
                 */
                function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
                /**
                 * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
                 *
                 * @param node The Node whose children will be visited.
                 * @param visitor The callback used to visit each child.
                 * @param context A lexical environment context for the visitor.
                 */
                function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
                function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
                function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
                function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
                export function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;
                export function resolveTripleslashReference(moduleName: string, containingFile: string): string;
                export function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;
                export function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
                export function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
                export function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;
                export function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
                export function flattenDiagnosticMessageText(diag: string | DiagnosticMessageChain | undefined, newLine: string, indent?: number): string;
                /**
                 * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
                 * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
                 */
                export function getModeForFileReference(ref: FileReference | string, containingFileMode: SourceFile["impliedNodeFormat"]): ModuleKind.CommonJS | ModuleKind.ESNext | undefined;
                /**
                 * Calculates the final resolution mode for an import at some index within a file's imports list. This is generally the explicitly
                 * defined mode of the import if provided, or, if not, the mode of the containing file (with some exceptions: import=require is always commonjs, dynamic import is always esm).
                 * If you have an actual import node, prefer using getModeForUsageLocation on the reference string node.
                 * @param file File to fetch the resolution mode within
                 * @param index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations
                 */
                export function getModeForResolutionAtIndex(file: SourceFile, index: number): ModuleKind.CommonJS | ModuleKind.ESNext | undefined;
                /**
                 * Calculates the final resolution mode for a given module reference node. This is generally the explicitly provided resolution mode, if
                 * one exists, or the mode of the containing source file. (Excepting import=require, which is always commonjs, and dynamic import, which is always esm).
                 * Notably, this function always returns `undefined` if the containing file has an `undefined` `impliedNodeFormat` - this field is only set when
                 * `moduleResolution` is `node16`+.
                 * @param file The file the import or import-like reference is contained within
                 * @param usage The module reference string
                 * @returns The final resolution mode of the import
                 */
                export function getModeForUsageLocation(file: {
                    impliedNodeFormat?: SourceFile["impliedNodeFormat"];
                }, usage: StringLiteralLike): ModuleKind.CommonJS | ModuleKind.ESNext | undefined;
                export function getConfigFileParsingDiagnostics(configFileParseResult: ParsedCommandLine): readonly Diagnostic[];
                /**
                 * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the
                 * `options` parameter.
                 *
                 * @param fileName The normalized absolute path to check the format of (it need not exist on disk)
                 * @param [packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often
                 * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data
                 * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`
                 * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format
                 */
                export function getImpliedNodeFormatForFile(fileName: Path, packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ModuleKind.ESNext | ModuleKind.CommonJS | undefined;
                /**
                 * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
                 * that represent a compilation unit.
                 *
                 * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
                 * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
                 *
                 * @param createProgramOptions - The options for creating a program.
                 * @returns A 'Program' object.
                 */
                export function createProgram(createProgramOptions: CreateProgramOptions): Program;
                /**
                 * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
                 * that represent a compilation unit.
                 *
                 * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
                 * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
                 *
                 * @param rootNames - A set of root files.
                 * @param options - The compiler options which should be used.
                 * @param host - The host interacts with the underlying file system.
                 * @param oldProgram - Reuses an old program structure.
                 * @param configFileParsingDiagnostics - error during config file parsing
                 * @returns A 'Program' object.
                 */
                export function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;
                /**
                 * Returns the target config filename of a project reference.
                 * Note: The file might not exist.
                 */
                export function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;
                /** @deprecated */
                export function resolveProjectReferencePath(host: ResolveProjectReferencePathHost, ref: ProjectReference): ResolvedConfigFileName;
                export interface FormatDiagnosticsHost {
                    getCurrentDirectory(): string;
                    getCanonicalFileName(fileName: string): string;
                    getNewLine(): string;
                }
                /** @deprecated */
                export interface ResolveProjectReferencePathHost {
                    fileExists(fileName: string): boolean;
                }
                export interface EmitOutput {
                    outputFiles: OutputFile[];
                    emitSkipped: boolean;
                }
                export interface OutputFile {
                    name: string;
                    writeByteOrderMark: boolean;
                    text: string;
                }
                /**
                 * Create the builder to manage semantic diagnostics and cache them
                 */
                function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
                function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
                /**
                 * Create the builder that can handle the changes in program and iterate through changed files
                 * to emit the those files and manage semantic diagnostics cache as well
                 */
                function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
                function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
                /**
                 * Creates a builder thats just abstraction over program and can be used with watch
                 */
                function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
                function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
                export type AffectedFileResult<T> = {
                    result: T;
                    affected: SourceFile | Program;
                } | undefined;
                export interface BuilderProgramHost {
                    /**
                     * return true if file names are treated with case sensitivity
                     */
                    useCaseSensitiveFileNames(): boolean;
                    /**
                     * If provided this would be used this hash instead of actual file shape text for detecting changes
                     */
                    createHash?: (data: string) => string;
                    /**
                     * When emit or emitNextAffectedFile are called without writeFile,
                     * this callback if present would be used to write files
                     */
                    writeFile?: WriteFileCallback;
                }
                /**
                 * Builder to manage the program state changes
                 */
                export interface BuilderProgram {
                    /**
                     * Returns current program
                     */
                    getProgram(): Program;
                    /**
                     * Get compiler options of the program
                     */
                    getCompilerOptions(): CompilerOptions;
                    /**
                     * Get the source file in the program with file name
                     */
                    getSourceFile(fileName: string): SourceFile | undefined;
                    /**
                     * Get a list of files in the program
                     */
                    getSourceFiles(): readonly SourceFile[];
                    /**
                     * Get the diagnostics for compiler options
                     */
                    getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
                    /**
                     * Get the diagnostics that dont belong to any file
                     */
                    getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
                    /**
                     * Get the diagnostics from config file parsing
                     */
                    getConfigFileParsingDiagnostics(): readonly Diagnostic[];
                    /**
                     * Get the syntax diagnostics, for all source files if source file is not supplied
                     */
                    getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
                    /**
                     * Get the declaration diagnostics, for all source files if source file is not supplied
                     */
                    getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
                    /**
                     * Get all the dependencies of the file
                     */
                    getAllDependencies(sourceFile: SourceFile): readonly string[];
                    /**
                     * Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program
                     * The semantic diagnostics are cached and managed here
                     * Note that it is assumed that when asked about semantic diagnostics through this API,
                     * the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics
                     * In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,
                     * it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics
                     */
                    getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
                    /**
                     * Emits the JavaScript and declaration files.
                     * When targetSource file is specified, emits the files corresponding to that source file,
                     * otherwise for the whole program.
                     * In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,
                     * it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,
                     * it will only emit all the affected files instead of whole program
                     *
                     * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
                     * in that order would be used to write the files
                     */
                    emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
                    /**
                     * Get the current directory of the program
                     */
                    getCurrentDirectory(): string;
                }
                /**
                 * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files
                 */
                export interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
                    /**
                     * Gets the semantic diagnostics from the program for the next affected file and caches it
                     * Returns undefined if the iteration is complete
                     */
                    getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
                }
                /**
                 * The builder that can handle the changes in program and iterate through changed file to emit the files
                 * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files
                 */
                export interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
                    /**
                     * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
                     * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
                     * in that order would be used to write the files
                     */
                    emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;
                }
                function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;
                function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;
                function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
                /**
                 * Create the watch compiler host for either configFile or fileNames and its options
                 */
                function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
                function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
                /**
                 * Creates the watch from the host for root files and compiler options
                 */
                function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
                /**
                 * Creates the watch from the host for config file
                 */
                function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
                export interface ReadBuildProgramHost {
                    useCaseSensitiveFileNames(): boolean;
                    getCurrentDirectory(): string;
                    readFile(fileName: string): string | undefined;
                }
                export interface IncrementalProgramOptions<T extends BuilderProgram> {
                    rootNames: readonly string[];
                    options: CompilerOptions;
                    configFileParsingDiagnostics?: readonly Diagnostic[];
                    projectReferences?: readonly ProjectReference[];
                    host?: CompilerHost;
                    createProgram?: CreateProgram<T>;
                }
                export type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
                /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */
                export type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
                /** Host that has watch functionality used in --watch mode */
                export interface WatchHost {
                    /** If provided, called with Diagnostic message that informs about change in watch status */
                    onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;
                    /** Used to watch changes in source files, missing files needed to update the program or config file */
                    watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
                    /** Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added */
                    watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
                    /** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */
                    setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
                    /** If provided, will be used to reset existing delayed compilation */
                    clearTimeout?(timeoutId: any): void;
                }
                export interface ProgramHost<T extends BuilderProgram> {
                    /**
                     * Used to create the program when need for program creation or recreation detected
                     */
                    createProgram: CreateProgram<T>;
                    useCaseSensitiveFileNames(): boolean;
                    getNewLine(): string;
                    getCurrentDirectory(): string;
                    getDefaultLibFileName(options: CompilerOptions): string;
                    getDefaultLibLocation?(): string;
                    createHash?(data: string): string;
                    /**
                     * Use to check file presence for source files and
                     * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
                     */
                    fileExists(path: string): boolean;
                    /**
                     * Use to read file text for source files and
                     * if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well
                     */
                    readFile(path: string, encoding?: string): string | undefined;
                    /** If provided, used for module resolution as well as to handle directory structure */
                    directoryExists?(path: string): boolean;
                    /** If provided, used in resolutions as well as handling directory structure */
                    getDirectories?(path: string): string[];
                    /** If provided, used to cache and handle directory structure modifications */
                    readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
                    /** Symbol links resolution */
                    realpath?(path: string): string;
                    /** If provided would be used to write log about compilation */
                    trace?(s: string): void;
                    /** If provided is used to get the environment variable */
                    getEnvironmentVariable?(name: string): string | undefined;
                    /** If provided, used to resolve the module names, otherwise typescript's default module resolution */
                    resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
                    /** If provided, used to resolve type reference directives, otherwise typescript's default resolution */
                    resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: SourceFile["impliedNodeFormat"] | undefined): (ResolvedTypeReferenceDirective | undefined)[];
                    /** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */
                    hasInvalidatedResolutions?(filePath: Path): boolean;
                    /**
                     * Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it
                     */
                    getModuleResolutionCache?(): ModuleResolutionCache | undefined;
                }
                export interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
                    /** Instead of using output d.ts file from project reference, use its source file */
                    useSourceOfProjectReferenceRedirect?(): boolean;
                    /** If provided, use this method to get parsed command lines for referenced projects */
                    getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
                    /** If provided, callback to invoke after every new program creation */
                    afterProgramCreate?(program: T): void;
                }
                /**
                 * Host to create watch with root files and options
                 */
                export interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
                    /** root files to use to generate program */
                    rootFiles: string[];
                    /** Compiler options */
                    options: CompilerOptions;
                    watchOptions?: WatchOptions;
                    /** Project References */
                    projectReferences?: readonly ProjectReference[];
                }
                /**
                 * Host to create watch with config file
                 */
                export interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
                    /** Name of the config file to compile */
                    configFileName: string;
                    /** Options to extend */
                    optionsToExtend?: CompilerOptions;
                    watchOptionsToExtend?: WatchOptions;
                    extraFileExtensions?: readonly FileExtensionInfo[];
                    /**
                     * Used to generate source file names from the config file and its include, exclude, files rules
                     * and also to cache the directory stucture
                     */
                    readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
                }
                export interface Watch<T> {
                    /** Synchronize with host and get updated program */
                    getProgram(): T;
                    /** Closes the watch */
                    close(): void;
                }
                /**
                 * Creates the watch what generates program using the config file
                 */
                export interface WatchOfConfigFile<T> extends Watch<T> {
                }
                /**
                 * Creates the watch that generates program using the root files and compiler options
                 */
                export interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
                    /** Updates the root files in the program, only if this is not config file compilation */
                    updateRootFileNames(fileNames: string[]): void;
                }
                /**
                 * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
                 */
                function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
                function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;
                function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;
                function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
                function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
                export interface BuildOptions {
                    dry?: boolean;
                    force?: boolean;
                    verbose?: boolean;
                    incremental?: boolean;
                    assumeChangesOnlyAffectDirectDependencies?: boolean;
                    traceResolution?: boolean;
                    [option: string]: CompilerOptionsValue | undefined;
                }
                export type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
                export interface ReportFileInError {
                    fileName: string;
                    line: number;
                }
                export interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
                    createDirectory?(path: string): void;
                    /**
                     * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with
                     * writeFileCallback
                     */
                    writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
                    getCustomTransformers?: (project: string) => CustomTransformers | undefined;
                    getModifiedTime(fileName: string): Date | undefined;
                    setModifiedTime(fileName: string, date: Date): void;
                    deleteFile(fileName: string): void;
                    getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
                    reportDiagnostic: DiagnosticReporter;
                    reportSolutionBuilderStatus: DiagnosticReporter;
                    afterProgramEmitAndDiagnostics?(program: T): void;
                }
                export interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
                    reportErrorSummary?: ReportEmitErrorSummary;
                }
                export interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
                }
                export interface SolutionBuilder<T extends BuilderProgram> {
                    build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
                    clean(project?: string): ExitStatus;
                    buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
                    cleanReferences(project?: string): ExitStatus;
                    getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;
                }
                export enum InvalidatedProjectKind {
                    Build = 0,
                    UpdateBundle = 1,
                    UpdateOutputFileStamps = 2
                }
                export interface InvalidatedProjectBase {
                    readonly kind: InvalidatedProjectKind;
                    readonly project: ResolvedConfigFileName;
                    /**
                     *  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly
                     */
                    done(cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): ExitStatus;
                    getCompilerOptions(): CompilerOptions;
                    getCurrentDirectory(): string;
                }
                export interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
                    readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;
                    updateOutputFileStatmps(): void;
                }
                export interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
                    readonly kind: InvalidatedProjectKind.Build;
                    getBuilderProgram(): T | undefined;
                    getProgram(): Program | undefined;
                    getSourceFile(fileName: string): SourceFile | undefined;
                    getSourceFiles(): readonly SourceFile[];
                    getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
                    getGlobalDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
                    getConfigFileParsingDiagnostics(): readonly Diagnostic[];
                    getSyntacticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
                    getAllDependencies(sourceFile: SourceFile): readonly string[];
                    getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
                    getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
                    emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;
                }
                export interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {
                    readonly kind: InvalidatedProjectKind.UpdateBundle;
                    emit(writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): EmitResult | BuildInvalidedProject<T> | undefined;
                }
                export type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;
                export namespace server {
                    export type ActionSet = "action::set";
                    export type ActionInvalidate = "action::invalidate";
                    export type ActionPackageInstalled = "action::packageInstalled";
                    export type EventTypesRegistry = "event::typesRegistry";
                    export type EventBeginInstallTypes = "event::beginInstallTypes";
                    export type EventEndInstallTypes = "event::endInstallTypes";
                    export type EventInitializationFailed = "event::initializationFailed";
                    export interface TypingInstallerResponse {
                        readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;
                    }
                    export interface TypingInstallerRequestWithProjectName {
                        readonly projectName: string;
                    }
                    export interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
                        readonly fileNames: string[];
                        readonly projectRootPath: Path;
                        readonly compilerOptions: CompilerOptions;
                        readonly watchOptions?: WatchOptions;
                        readonly typeAcquisition: TypeAcquisition;
                        readonly unresolvedImports: SortedReadonlyArray<string>;
                        readonly cachePath?: string;
                        readonly kind: "discover";
                    }
                    export interface CloseProject extends TypingInstallerRequestWithProjectName {
                        readonly kind: "closeProject";
                    }
                    export interface TypesRegistryRequest {
                        readonly kind: "typesRegistry";
                    }
                    export interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
                        readonly kind: "installPackage";
                        readonly fileName: Path;
                        readonly packageName: string;
                        readonly projectRootPath: Path;
                    }
                    export interface PackageInstalledResponse extends ProjectResponse {
                        readonly kind: ActionPackageInstalled;
                        readonly success: boolean;
                        readonly message: string;
                    }
                    export interface InitializationFailedResponse extends TypingInstallerResponse {
                        readonly kind: EventInitializationFailed;
                        readonly message: string;
                        readonly stack?: string;
                    }
                    export interface ProjectResponse extends TypingInstallerResponse {
                        readonly projectName: string;
                    }
                    export interface InvalidateCachedTypings extends ProjectResponse {
                        readonly kind: ActionInvalidate;
                    }
                    export interface InstallTypes extends ProjectResponse {
                        readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
                        readonly eventId: number;
                        readonly typingsInstallerVersion: string;
                        readonly packagesToInstall: readonly string[];
                    }
                    export interface BeginInstallTypes extends InstallTypes {
                        readonly kind: EventBeginInstallTypes;
                    }
                    export interface EndInstallTypes extends InstallTypes {
                        readonly kind: EventEndInstallTypes;
                        readonly installSuccess: boolean;
                    }
                    export interface SetTypings extends ProjectResponse {
                        readonly typeAcquisition: TypeAcquisition;
                        readonly compilerOptions: CompilerOptions;
                        readonly typings: string[];
                        readonly unresolvedImports: SortedReadonlyArray<string>;
                        readonly kind: ActionSet;
                    }
                }
                function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
                /**
                 * Represents an immutable snapshot of a script at a specified time.Once acquired, the
                 * snapshot is observably immutable. i.e. the same calls with the same parameters will return
                 * the same values.
                 */
                export interface IScriptSnapshot {
                    /** Gets a portion of the script snapshot specified by [start, end). */
                    getText(start: number, end: number): string;
                    /** Gets the length of this script snapshot. */
                    getLength(): number;
                    /**
                     * Gets the TextChangeRange that describe how the text changed between this text and
                     * an older version.  This information is used by the incremental parser to determine
                     * what sections of the script need to be re-parsed.  'undefined' can be returned if the
                     * change range cannot be determined.  However, in that case, incremental parsing will
                     * not happen and the entire document will be re - parsed.
                     */
                    getChangeRange(oldSnapshot: IScriptSnapshot): TextChangeRange | undefined;
                    /** Releases all resources held by this script snapshot */
                    dispose?(): void;
                }
                export namespace ScriptSnapshot {
                    function fromString(text: string): IScriptSnapshot;
                }
                export interface PreProcessedFileInfo {
                    referencedFiles: FileReference[];
                    typeReferenceDirectives: FileReference[];
                    libReferenceDirectives: FileReference[];
                    importedFiles: FileReference[];
                    ambientExternalModules?: string[];
                    isLibFile: boolean;
                }
                export interface HostCancellationToken {
                    isCancellationRequested(): boolean;
                }
                export interface InstallPackageOptions {
                    fileName: Path;
                    packageName: string;
                }
                export interface PerformanceEvent {
                    kind: "UpdateGraph" | "CreatePackageJsonAutoImportProvider";
                    durationMs: number;
                }
                export enum LanguageServiceMode {
                    Semantic = 0,
                    PartialSemantic = 1,
                    Syntactic = 2
                }
                export interface IncompleteCompletionsCache {
                    get(): CompletionInfo | undefined;
                    set(response: CompletionInfo): void;
                    clear(): void;
                }
                export interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
                    getCompilationSettings(): CompilerOptions;
                    getNewLine?(): string;
                    getProjectVersion?(): string;
                    getScriptFileNames(): string[];
                    getScriptKind?(fileName: string): ScriptKind;
                    getScriptVersion(fileName: string): string;
                    getScriptSnapshot(fileName: string): IScriptSnapshot | undefined;
                    getProjectReferences?(): readonly ProjectReference[] | undefined;
                    getLocalizedDiagnosticMessages?(): any;
                    getCancellationToken?(): HostCancellationToken;
                    getCurrentDirectory(): string;
                    getDefaultLibFileName(options: CompilerOptions): string;
                    log?(s: string): void;
                    trace?(s: string): void;
                    error?(s: string): void;
                    useCaseSensitiveFileNames?(): boolean;
                    readDirectory?(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
                    realpath?(path: string): string;
                    readFile(path: string, encoding?: string): string | undefined;
                    fileExists(path: string): boolean;
                    getTypeRootsVersion?(): number;
                    resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
                    getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
                    resolveTypeReferenceDirectives?(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: SourceFile["impliedNodeFormat"] | undefined): (ResolvedTypeReferenceDirective | undefined)[];
                    getDirectories?(directoryName: string): string[];
                    /**
                     * Gets a set of custom transformers to use during emit.
                     */
                    getCustomTransformers?(): CustomTransformers | undefined;
                    isKnownTypesPackageName?(name: string): boolean;
                    installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
                    writeFile?(fileName: string, content: string): void;
                    getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
                }
                export type WithMetadata<T> = T & {
                    metadata?: unknown;
                };
                export enum SemanticClassificationFormat {
                    Original = "original",
                    TwentyTwenty = "2020"
                }
                export interface LanguageService {
                    /** This is used as a part of restarting the language service. */
                    cleanupSemanticCache(): void;
                    /**
                     * Gets errors indicating invalid syntax in a file.
                     *
                     * In English, "this cdeo have, erorrs" is syntactically invalid because it has typos,
                     * grammatical errors, and misplaced punctuation. Likewise, examples of syntax
                     * errors in TypeScript are missing parentheses in an `if` statement, mismatched
                     * curly braces, and using a reserved keyword as a variable name.
                     *
                     * These diagnostics are inexpensive to compute and don't require knowledge of
                     * other files. Note that a non-empty result increases the likelihood of false positives
                     * from `getSemanticDiagnostics`.
                     *
                     * While these represent the majority of syntax-related diagnostics, there are some
                     * that require the type system, which will be present in `getSemanticDiagnostics`.
                     *
                     * @param fileName A path to the file you want syntactic diagnostics for
                     */
                    getSyntacticDiagnostics(fileName: string): DiagnosticWithLocation[];
                    /**
                     * Gets warnings or errors indicating type system issues in a given file.
                     * Requesting semantic diagnostics may start up the type system and
                     * run deferred work, so the first call may take longer than subsequent calls.
                     *
                     * Unlike the other get*Diagnostics functions, these diagnostics can potentially not
                     * include a reference to a source file. Specifically, the first time this is called,
                     * it will return global diagnostics with no associated location.
                     *
                     * To contrast the differences between semantic and syntactic diagnostics, consider the
                     * sentence: "The sun is green." is syntactically correct; those are real English words with
                     * correct sentence structure. However, it is semantically invalid, because it is not true.
                     *
                     * @param fileName A path to the file you want semantic diagnostics for
                     */
                    getSemanticDiagnostics(fileName: string): Diagnostic[];
                    /**
                     * Gets suggestion diagnostics for a specific file. These diagnostics tend to
                     * proactively suggest refactors, as opposed to diagnostics that indicate
                     * potentially incorrect runtime behavior.
                     *
                     * @param fileName A path to the file you want semantic diagnostics for
                     */
                    getSuggestionDiagnostics(fileName: string): DiagnosticWithLocation[];
                    /**
                     * Gets global diagnostics related to the program configuration and compiler options.
                     */
                    getCompilerOptionsDiagnostics(): Diagnostic[];
                    /** @deprecated Use getEncodedSyntacticClassifications instead. */
                    getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
                    getSyntacticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
                    /** @deprecated Use getEncodedSemanticClassifications instead. */
                    getSemanticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];
                    getSemanticClassifications(fileName: string, span: TextSpan, format: SemanticClassificationFormat): ClassifiedSpan[] | ClassifiedSpan2020[];
                    /** Encoded as triples of [start, length, ClassificationType]. */
                    getEncodedSyntacticClassifications(fileName: string, span: TextSpan): Classifications;
                    /**
                     * Gets semantic highlights information for a particular file. Has two formats, an older
                     * version used by VS and a format used by VS Code.
                     *
                     * @param fileName The path to the file
                     * @param position A text span to return results within
                     * @param format Which format to use, defaults to "original"
                     * @returns a number array encoded as triples of [start, length, ClassificationType, ...].
                     */
                    getEncodedSemanticClassifications(fileName: string, span: TextSpan, format?: SemanticClassificationFormat): Classifications;
                    /**
                     * Gets completion entries at a particular position in a file.
                     *
                     * @param fileName The path to the file
                     * @param position A zero-based index of the character where you want the entries
                     * @param options An object describing how the request was triggered and what kinds
                     * of code actions can be returned with the completions.
                     * @param formattingSettings settings needed for calling formatting functions.
                     */
                    getCompletionsAtPosition(fileName: string, position: number, options: GetCompletionsAtPositionOptions | undefined, formattingSettings?: FormatCodeSettings): WithMetadata<CompletionInfo> | undefined;
                    /**
                     * Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.
                     *
                     * @param fileName The path to the file
                     * @param position A zero based index of the character where you want the entries
                     * @param entryName The `name` from an existing completion which came from `getCompletionsAtPosition`
                     * @param formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility
                     * @param source `source` property from the completion entry
                     * @param preferences User settings, can be undefined for backwards compatibility
                     * @param data `data` property from the completion entry
                     */
                    getCompletionEntryDetails(fileName: string, position: number, entryName: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined, data: CompletionEntryData | undefined): CompletionEntryDetails | undefined;
                    getCompletionEntrySymbol(fileName: string, position: number, name: string, source: string | undefined): Symbol | undefined;
                    /**
                     * Gets semantic information about the identifier at a particular position in a
                     * file. Quick info is what you typically see when you hover in an editor.
                     *
                     * @param fileName The path to the file
                     * @param position A zero-based index of the character where you want the quick info
                     */
                    getQuickInfoAtPosition(fileName: string, position: number): QuickInfo | undefined;
                    getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): TextSpan | undefined;
                    getBreakpointStatementAtPosition(fileName: string, position: number): TextSpan | undefined;
                    getSignatureHelpItems(fileName: string, position: number, options: SignatureHelpItemsOptions | undefined): SignatureHelpItems | undefined;
                    getRenameInfo(fileName: string, position: number, preferences: UserPreferences): RenameInfo;
                    /** @deprecated Use the signature with `UserPreferences` instead. */
                    getRenameInfo(fileName: string, position: number, options?: RenameInfoOptions): RenameInfo;
                    findRenameLocations(fileName: string, position: number, findInStrings: boolean, findInComments: boolean, providePrefixAndSuffixTextForRename?: boolean): readonly RenameLocation[] | undefined;
                    getSmartSelectionRange(fileName: string, position: number): SelectionRange;
                    getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
                    getDefinitionAndBoundSpan(fileName: string, position: number): DefinitionInfoAndBoundSpan | undefined;
                    getTypeDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
                    getImplementationAtPosition(fileName: string, position: number): readonly ImplementationLocation[] | undefined;
                    getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[] | undefined;
                    findReferences(fileName: string, position: number): ReferencedSymbol[] | undefined;
                    getDocumentHighlights(fileName: string, position: number, filesToSearch: string[]): DocumentHighlights[] | undefined;
                    getFileReferences(fileName: string): ReferenceEntry[];
                    /** @deprecated */
                    getOccurrencesAtPosition(fileName: string, position: number): readonly ReferenceEntry[] | undefined;
                    getNavigateToItems(searchValue: string, maxResultCount?: number, fileName?: string, excludeDtsFiles?: boolean): NavigateToItem[];
                    getNavigationBarItems(fileName: string): NavigationBarItem[];
                    getNavigationTree(fileName: string): NavigationTree;
                    prepareCallHierarchy(fileName: string, position: number): CallHierarchyItem | CallHierarchyItem[] | undefined;
                    provideCallHierarchyIncomingCalls(fileName: string, position: number): CallHierarchyIncomingCall[];
                    provideCallHierarchyOutgoingCalls(fileName: string, position: number): CallHierarchyOutgoingCall[];
                    provideInlayHints(fileName: string, span: TextSpan, preferences: UserPreferences | undefined): InlayHint[];
                    getOutliningSpans(fileName: string): OutliningSpan[];
                    getTodoComments(fileName: string, descriptors: TodoCommentDescriptor[]): TodoComment[];
                    getBraceMatchingAtPosition(fileName: string, position: number): TextSpan[];
                    getIndentationAtPosition(fileName: string, position: number, options: EditorOptions | EditorSettings): number;
                    getFormattingEditsForRange(fileName: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
                    getFormattingEditsForDocument(fileName: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
                    getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): TextChange[];
                    getDocCommentTemplateAtPosition(fileName: string, position: number, options?: DocCommentTemplateOptions): TextInsertion | undefined;
                    isValidBraceCompletionAtPosition(fileName: string, position: number, openingBrace: number): boolean;
                    /**
                     * This will return a defined result if the position is after the `>` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.
                     * Editors should call this after `>` is typed.
                     */
                    getJsxClosingTagAtPosition(fileName: string, position: number): JsxClosingTagInfo | undefined;
                    getSpanOfEnclosingComment(fileName: string, position: number, onlyMultiLine: boolean): TextSpan | undefined;
                    toLineColumnOffset?(fileName: string, position: number): LineAndCharacter;
                    getCodeFixesAtPosition(fileName: string, start: number, end: number, errorCodes: readonly number[], formatOptions: FormatCodeSettings, preferences: UserPreferences): readonly CodeFixAction[];
                    getCombinedCodeFix(scope: CombinedCodeFixScope, fixId: {}, formatOptions: FormatCodeSettings, preferences: UserPreferences): CombinedCodeActions;
                    applyCodeActionCommand(action: CodeActionCommand, formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult>;
                    applyCodeActionCommand(action: CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult[]>;
                    applyCodeActionCommand(action: CodeActionCommand | CodeActionCommand[], formatSettings?: FormatCodeSettings): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
                    /** @deprecated `fileName` will be ignored */
                    applyCodeActionCommand(fileName: string, action: CodeActionCommand): Promise<ApplyCodeActionCommandResult>;
                    /** @deprecated `fileName` will be ignored */
                    applyCodeActionCommand(fileName: string, action: CodeActionCommand[]): Promise<ApplyCodeActionCommandResult[]>;
                    /** @deprecated `fileName` will be ignored */
                    applyCodeActionCommand(fileName: string, action: CodeActionCommand | CodeActionCommand[]): Promise<ApplyCodeActionCommandResult | ApplyCodeActionCommandResult[]>;
                    getApplicableRefactors(fileName: string, positionOrRange: number | TextRange, preferences: UserPreferences | undefined, triggerReason?: RefactorTriggerReason, kind?: string): ApplicableRefactorInfo[];
                    getEditsForRefactor(fileName: string, formatOptions: FormatCodeSettings, positionOrRange: number | TextRange, refactorName: string, actionName: string, preferences: UserPreferences | undefined): RefactorEditInfo | undefined;
                    organizeImports(args: OrganizeImportsArgs, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
                    getEditsForFileRename(oldFilePath: string, newFilePath: string, formatOptions: FormatCodeSettings, preferences: UserPreferences | undefined): readonly FileTextChanges[];
                    getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;
                    getProgram(): Program | undefined;
                    toggleLineComment(fileName: string, textRange: TextRange): TextChange[];
                    toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];
                    commentSelection(fileName: string, textRange: TextRange): TextChange[];
                    uncommentSelection(fileName: string, textRange: TextRange): TextChange[];
                    dispose(): void;
                }
                export interface JsxClosingTagInfo {
                    readonly newText: string;
                }
                export interface CombinedCodeFixScope {
                    type: "file";
                    fileName: string;
                }
                export enum OrganizeImportsMode {
                    All = "All",
                    SortAndCombine = "SortAndCombine",
                    RemoveUnused = "RemoveUnused"
                }
                export interface OrganizeImportsArgs extends CombinedCodeFixScope {
                    /** @deprecated Use `mode` instead */
                    skipDestructiveCodeActions?: boolean;
                    mode?: OrganizeImportsMode;
                }
                export type CompletionsTriggerCharacter = "." | "\"" | "'" | "`" | "/" | "@" | "<" | "#" | " ";
                export enum CompletionTriggerKind {
                    /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
                    Invoked = 1,
                    /** Completion was triggered by a trigger character. */
                    TriggerCharacter = 2,
                    /** Completion was re-triggered as the current completion list is incomplete. */
                    TriggerForIncompleteCompletions = 3
                }
                export interface GetCompletionsAtPositionOptions extends UserPreferences {
                    /**
                     * If the editor is asking for completions because a certain character was typed
                     * (as opposed to when the user explicitly requested them) this should be set.
                     */
                    triggerCharacter?: CompletionsTriggerCharacter;
                    triggerKind?: CompletionTriggerKind;
                    /** @deprecated Use includeCompletionsForModuleExports */
                    includeExternalModuleExports?: boolean;
                    /** @deprecated Use includeCompletionsWithInsertText */
                    includeInsertTextCompletions?: boolean;
                }
                export type SignatureHelpTriggerCharacter = "," | "(" | "<";
                export type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
                export interface SignatureHelpItemsOptions {
                    triggerReason?: SignatureHelpTriggerReason;
                }
                export type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
                /**
                 * Signals that the user manually requested signature help.
                 * The language service will unconditionally attempt to provide a result.
                 */
                export interface SignatureHelpInvokedReason {
                    kind: "invoked";
                    triggerCharacter?: undefined;
                }
                /**
                 * Signals that the signature help request came from a user typing a character.
                 * Depending on the character and the syntactic context, the request may or may not be served a result.
                 */
                export interface SignatureHelpCharacterTypedReason {
                    kind: "characterTyped";
                    /**
                     * Character that was responsible for triggering signature help.
                     */
                    triggerCharacter: SignatureHelpTriggerCharacter;
                }
                /**
                 * Signals that this signature help request came from typing a character or moving the cursor.
                 * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.
                 * The language service will unconditionally attempt to provide a result.
                 * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
                 */
                export interface SignatureHelpRetriggeredReason {
                    kind: "retrigger";
                    /**
                     * Character that was responsible for triggering signature help.
                     */
                    triggerCharacter?: SignatureHelpRetriggerCharacter;
                }
                export interface ApplyCodeActionCommandResult {
                    successMessage: string;
                }
                export interface Classifications {
                    spans: number[];
                    endOfLineState: EndOfLineState;
                }
                export interface ClassifiedSpan {
                    textSpan: TextSpan;
                    classificationType: ClassificationTypeNames;
                }
                export interface ClassifiedSpan2020 {
                    textSpan: TextSpan;
                    classificationType: number;
                }
                /**
                 * Navigation bar interface designed for visual studio's dual-column layout.
                 * This does not form a proper tree.
                 * The navbar is returned as a list of top-level items, each of which has a list of child items.
                 * Child items always have an empty array for their `childItems`.
                 */
                export interface NavigationBarItem {
                    text: string;
                    kind: ScriptElementKind;
                    kindModifiers: string;
                    spans: TextSpan[];
                    childItems: NavigationBarItem[];
                    indent: number;
                    bolded: boolean;
                    grayed: boolean;
                }
                /**
                 * Node in a tree of nested declarations in a file.
                 * The top node is always a script or module node.
                 */
                export interface NavigationTree {
                    /** Name of the declaration, or a short description, e.g. "<class>". */
                    text: string;
                    kind: ScriptElementKind;
                    /** ScriptElementKindModifier separated by commas, e.g. "public,abstract" */
                    kindModifiers: string;
                    /**
                     * Spans of the nodes that generated this declaration.
                     * There will be more than one if this is the result of merging.
                     */
                    spans: TextSpan[];
                    nameSpan: TextSpan | undefined;
                    /** Present if non-empty */
                    childItems?: NavigationTree[];
                }
                export interface CallHierarchyItem {
                    name: string;
                    kind: ScriptElementKind;
                    kindModifiers?: string;
                    file: string;
                    span: TextSpan;
                    selectionSpan: TextSpan;
                    containerName?: string;
                }
                export interface CallHierarchyIncomingCall {
                    from: CallHierarchyItem;
                    fromSpans: TextSpan[];
                }
                export interface CallHierarchyOutgoingCall {
                    to: CallHierarchyItem;
                    fromSpans: TextSpan[];
                }
                export enum InlayHintKind {
                    Type = "Type",
                    Parameter = "Parameter",
                    Enum = "Enum"
                }
                export interface InlayHint {
                    text: string;
                    position: number;
                    kind: InlayHintKind;
                    whitespaceBefore?: boolean;
                    whitespaceAfter?: boolean;
                }
                export interface TodoCommentDescriptor {
                    text: string;
                    priority: number;
                }
                export interface TodoComment {
                    descriptor: TodoCommentDescriptor;
                    message: string;
                    position: number;
                }
                export interface TextChange {
                    span: TextSpan;
                    newText: string;
                }
                export interface FileTextChanges {
                    fileName: string;
                    textChanges: readonly TextChange[];
                    isNewFile?: boolean;
                }
                export interface CodeAction {
                    /** Description of the code action to display in the UI of the editor */
                    description: string;
                    /** Text changes to apply to each file as part of the code action */
                    changes: FileTextChanges[];
                    /**
                     * If the user accepts the code fix, the editor should send the action back in a `applyAction` request.
                     * This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.
                     */
                    commands?: CodeActionCommand[];
                }
                export interface CodeFixAction extends CodeAction {
                    /** Short name to identify the fix, for use by telemetry. */
                    fixName: string;
                    /**
                     * If present, one may call 'getCombinedCodeFix' with this fixId.
                     * This may be omitted to indicate that the code fix can't be applied in a group.
                     */
                    fixId?: {};
                    fixAllDescription?: string;
                }
                export interface CombinedCodeActions {
                    changes: readonly FileTextChanges[];
                    commands?: readonly CodeActionCommand[];
                }
                export type CodeActionCommand = InstallPackageAction;
                export interface InstallPackageAction {
                }
                /**
                 * A set of one or more available refactoring actions, grouped under a parent refactoring.
                 */
                export interface ApplicableRefactorInfo {
                    /**
                     * The programmatic name of the refactoring
                     */
                    name: string;
                    /**
                     * A description of this refactoring category to show to the user.
                     * If the refactoring gets inlined (see below), this text will not be visible.
                     */
                    description: string;
                    /**
                     * Inlineable refactorings can have their actions hoisted out to the top level
                     * of a context menu. Non-inlineanable refactorings should always be shown inside
                     * their parent grouping.
                     *
                     * If not specified, this value is assumed to be 'true'
                     */
                    inlineable?: boolean;
                    actions: RefactorActionInfo[];
                }
                /**
                 * Represents a single refactoring action - for example, the "Extract Method..." refactor might
                 * offer several actions, each corresponding to a surround class or closure to extract into.
                 */
                export interface RefactorActionInfo {
                    /**
                     * The programmatic name of the refactoring action
                     */
                    name: string;
                    /**
                     * A description of this refactoring action to show to the user.
                     * If the parent refactoring is inlined away, this will be the only text shown,
                     * so this description should make sense by itself if the parent is inlineable=true
                     */
                    description: string;
                    /**
                     * A message to show to the user if the refactoring cannot be applied in
                     * the current context.
                     */
                    notApplicableReason?: string;
                    /**
                     * The hierarchical dotted name of the refactor action.
                     */
                    kind?: string;
                }
                /**
                 * A set of edits to make in response to a refactor action, plus an optional
                 * location where renaming should be invoked from
                 */
                export interface RefactorEditInfo {
                    edits: FileTextChanges[];
                    renameFilename?: string;
                    renameLocation?: number;
                    commands?: CodeActionCommand[];
                }
                export type RefactorTriggerReason = "implicit" | "invoked";
                export interface TextInsertion {
                    newText: string;
                    /** The position in newText the caret should point to after the insertion. */
                    caretOffset: number;
                }
                export interface DocumentSpan {
                    textSpan: TextSpan;
                    fileName: string;
                    /**
                     * If the span represents a location that was remapped (e.g. via a .d.ts.map file),
                     * then the original filename and span will be specified here
                     */
                    originalTextSpan?: TextSpan;
                    originalFileName?: string;
                    /**
                     * If DocumentSpan.textSpan is the span for name of the declaration,
                     * then this is the span for relevant declaration
                     */
                    contextSpan?: TextSpan;
                    originalContextSpan?: TextSpan;
                }
                export interface RenameLocation extends DocumentSpan {
                    readonly prefixText?: string;
                    readonly suffixText?: string;
                }
                export interface ReferenceEntry extends DocumentSpan {
                    isWriteAccess: boolean;
                    isInString?: true;
                }
                export interface ImplementationLocation extends DocumentSpan {
                    kind: ScriptElementKind;
                    displayParts: SymbolDisplayPart[];
                }
                export enum HighlightSpanKind {
                    none = "none",
                    definition = "definition",
                    reference = "reference",
                    writtenReference = "writtenReference"
                }
                export interface HighlightSpan {
                    fileName?: string;
                    isInString?: true;
                    textSpan: TextSpan;
                    contextSpan?: TextSpan;
                    kind: HighlightSpanKind;
                }
                export interface NavigateToItem {
                    name: string;
                    kind: ScriptElementKind;
                    kindModifiers: string;
                    matchKind: "exact" | "prefix" | "substring" | "camelCase";
                    isCaseSensitive: boolean;
                    fileName: string;
                    textSpan: TextSpan;
                    containerName: string;
                    containerKind: ScriptElementKind;
                }
                export enum IndentStyle {
                    None = 0,
                    Block = 1,
                    Smart = 2
                }
                export enum SemicolonPreference {
                    Ignore = "ignore",
                    Insert = "insert",
                    Remove = "remove"
                }
                /** @deprecated - consider using EditorSettings instead */
                export interface EditorOptions {
                    BaseIndentSize?: number;
                    IndentSize: number;
                    TabSize: number;
                    NewLineCharacter: string;
                    ConvertTabsToSpaces: boolean;
                    IndentStyle: IndentStyle;
                }
                export interface EditorSettings {
                    baseIndentSize?: number;
                    indentSize?: number;
                    tabSize?: number;
                    newLineCharacter?: string;
                    convertTabsToSpaces?: boolean;
                    indentStyle?: IndentStyle;
                    trimTrailingWhitespace?: boolean;
                }
                /** @deprecated - consider using FormatCodeSettings instead */
                export interface FormatCodeOptions extends EditorOptions {
                    InsertSpaceAfterCommaDelimiter: boolean;
                    InsertSpaceAfterSemicolonInForStatements: boolean;
                    InsertSpaceBeforeAndAfterBinaryOperators: boolean;
                    InsertSpaceAfterConstructor?: boolean;
                    InsertSpaceAfterKeywordsInControlFlowStatements: boolean;
                    InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;
                    InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;
                    InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: boolean;
                    InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
                    InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: boolean;
                    InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
                    InsertSpaceAfterTypeAssertion?: boolean;
                    InsertSpaceBeforeFunctionParenthesis?: boolean;
                    PlaceOpenBraceOnNewLineForFunctions: boolean;
                    PlaceOpenBraceOnNewLineForControlBlocks: boolean;
                    insertSpaceBeforeTypeAnnotation?: boolean;
                }
                export interface FormatCodeSettings extends EditorSettings {
                    readonly insertSpaceAfterCommaDelimiter?: boolean;
                    readonly insertSpaceAfterSemicolonInForStatements?: boolean;
                    readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;
                    readonly insertSpaceAfterConstructor?: boolean;
                    readonly insertSpaceAfterKeywordsInControlFlowStatements?: boolean;
                    readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;
                    readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;
                    readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;
                    readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
                    readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;
                    readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;
                    readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
                    readonly insertSpaceAfterTypeAssertion?: boolean;
                    readonly insertSpaceBeforeFunctionParenthesis?: boolean;
                    readonly placeOpenBraceOnNewLineForFunctions?: boolean;
                    readonly placeOpenBraceOnNewLineForControlBlocks?: boolean;
                    readonly insertSpaceBeforeTypeAnnotation?: boolean;
                    readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;
                    readonly semicolons?: SemicolonPreference;
                }
                export interface DefinitionInfo extends DocumentSpan {
                    kind: ScriptElementKind;
                    name: string;
                    containerKind: ScriptElementKind;
                    containerName: string;
                    unverified?: boolean;
                }
                export interface DefinitionInfoAndBoundSpan {
                    definitions?: readonly DefinitionInfo[];
                    textSpan: TextSpan;
                }
                export interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
                    displayParts: SymbolDisplayPart[];
                }
                export interface ReferencedSymbol {
                    definition: ReferencedSymbolDefinitionInfo;
                    references: ReferencedSymbolEntry[];
                }
                export interface ReferencedSymbolEntry extends ReferenceEntry {
                    isDefinition?: boolean;
                }
                export enum SymbolDisplayPartKind {
                    aliasName = 0,
                    className = 1,
                    enumName = 2,
                    fieldName = 3,
                    interfaceName = 4,
                    keyword = 5,
                    lineBreak = 6,
                    numericLiteral = 7,
                    stringLiteral = 8,
                    localName = 9,
                    methodName = 10,
                    moduleName = 11,
                    operator = 12,
                    parameterName = 13,
                    propertyName = 14,
                    punctuation = 15,
                    space = 16,
                    text = 17,
                    typeParameterName = 18,
                    enumMemberName = 19,
                    functionName = 20,
                    regularExpressionLiteral = 21,
                    link = 22,
                    linkName = 23,
                    linkText = 24
                }
                export interface SymbolDisplayPart {
                    text: string;
                    kind: string;
                }
                export interface JSDocLinkDisplayPart extends SymbolDisplayPart {
                    target: DocumentSpan;
                }
                export interface JSDocTagInfo {
                    name: string;
                    text?: SymbolDisplayPart[];
                }
                export interface QuickInfo {
                    kind: ScriptElementKind;
                    kindModifiers: string;
                    textSpan: TextSpan;
                    displayParts?: SymbolDisplayPart[];
                    documentation?: SymbolDisplayPart[];
                    tags?: JSDocTagInfo[];
                }
                export type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
                export interface RenameInfoSuccess {
                    canRename: true;
                    /**
                     * File or directory to rename.
                     * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.
                     */
                    fileToRename?: string;
                    displayName: string;
                    fullDisplayName: string;
                    kind: ScriptElementKind;
                    kindModifiers: string;
                    triggerSpan: TextSpan;
                }
                export interface RenameInfoFailure {
                    canRename: false;
                    localizedErrorMessage: string;
                }
                /**
                 * @deprecated Use `UserPreferences` instead.
                 */
                export interface RenameInfoOptions {
                    readonly allowRenameOfImportPath?: boolean;
                }
                export interface DocCommentTemplateOptions {
                    readonly generateReturnInDocTemplate?: boolean;
                }
                export interface SignatureHelpParameter {
                    name: string;
                    documentation: SymbolDisplayPart[];
                    displayParts: SymbolDisplayPart[];
                    isOptional: boolean;
                    isRest?: boolean;
                }
                export interface SelectionRange {
                    textSpan: TextSpan;
                    parent?: SelectionRange;
                }
                /**
                 * Represents a single signature to show in signature help.
                 * The id is used for subsequent calls into the language service to ask questions about the
                 * signature help item in the context of any documents that have been updated.  i.e. after
                 * an edit has happened, while signature help is still active, the host can ask important
                 * questions like 'what parameter is the user currently contained within?'.
                 */
                export interface SignatureHelpItem {
                    isVariadic: boolean;
                    prefixDisplayParts: SymbolDisplayPart[];
                    suffixDisplayParts: SymbolDisplayPart[];
                    separatorDisplayParts: SymbolDisplayPart[];
                    parameters: SignatureHelpParameter[];
                    documentation: SymbolDisplayPart[];
                    tags: JSDocTagInfo[];
                }
                /**
                 * Represents a set of signature help items, and the preferred item that should be selected.
                 */
                export interface SignatureHelpItems {
                    items: SignatureHelpItem[];
                    applicableSpan: TextSpan;
                    selectedItemIndex: number;
                    argumentIndex: number;
                    argumentCount: number;
                }
                export enum CompletionInfoFlags {
                    None = 0,
                    MayIncludeAutoImports = 1,
                    IsImportStatementCompletion = 2,
                    IsContinuation = 4,
                    ResolvedModuleSpecifiers = 8,
                    ResolvedModuleSpecifiersBeyondLimit = 16,
                    MayIncludeMethodSnippets = 32
                }
                export interface CompletionInfo {
                    /** For performance telemetry. */
                    flags?: CompletionInfoFlags;
                    /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */
                    isGlobalCompletion: boolean;
                    isMemberCompletion: boolean;
                    /**
                     * In the absence of `CompletionEntry["replacementSpan"]`, the editor may choose whether to use
                     * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span
                     * must be used to commit that completion entry.
                     */
                    optionalReplacementSpan?: TextSpan;
                    /**
                     * true when the current location also allows for a new identifier
                     */
                    isNewIdentifierLocation: boolean;
                    /**
                     * Indicates to client to continue requesting completions on subsequent keystrokes.
                     */
                    isIncomplete?: true;
                    entries: CompletionEntry[];
                }
                export interface CompletionEntryDataAutoImport {
                    /**
                     * The name of the property or export in the module's symbol table. Differs from the completion name
                     * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.
                     */
                    exportName: string;
                    moduleSpecifier?: string;
                    /** The file name declaring the export's module symbol, if it was an external module */
                    fileName?: string;
                    /** The module name (with quotes stripped) of the export's module symbol, if it was an ambient module */
                    ambientModuleName?: string;
                    /** True if the export was found in the package.json AutoImportProvider */
                    isPackageJsonImport?: true;
                }
                export interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
                    /** The key in the `ExportMapCache` where the completion entry's `SymbolExportInfo[]` is found */
                    exportMapKey: string;
                }
                export interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
                    moduleSpecifier: string;
                }
                export type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
                export interface CompletionEntry {
                    name: string;
                    kind: ScriptElementKind;
                    kindModifiers?: string;
                    sortText: string;
                    insertText?: string;
                    isSnippet?: true;
                    /**
                     * An optional span that indicates the text to be replaced by this completion item.
                     * If present, this span should be used instead of the default one.
                     * It will be set if the required span differs from the one generated by the default replacement behavior.
                     */
                    replacementSpan?: TextSpan;
                    hasAction?: true;
                    source?: string;
                    sourceDisplay?: SymbolDisplayPart[];
                    labelDetails?: CompletionEntryLabelDetails;
                    isRecommended?: true;
                    isFromUncheckedFile?: true;
                    isPackageJsonImport?: true;
                    isImportStatementCompletion?: true;
                    /**
                     * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,
                     * that allows TS Server to look up the symbol represented by the completion item, disambiguating
                     * items with the same name. Currently only defined for auto-import completions, but the type is
                     * `unknown` in the protocol, so it can be changed as needed to support other kinds of completions.
                     * The presence of this property should generally not be used to assume that this completion entry
                     * is an auto-import.
                     */
                    data?: CompletionEntryData;
                }
                export interface CompletionEntryLabelDetails {
                    detail?: string;
                    description?: string;
                }
                export interface CompletionEntryDetails {
                    name: string;
                    kind: ScriptElementKind;
                    kindModifiers: string;
                    displayParts: SymbolDisplayPart[];
                    documentation?: SymbolDisplayPart[];
                    tags?: JSDocTagInfo[];
                    codeActions?: CodeAction[];
                    /** @deprecated Use `sourceDisplay` instead. */
                    source?: SymbolDisplayPart[];
                    sourceDisplay?: SymbolDisplayPart[];
                }
                export interface OutliningSpan {
                    /** The span of the document to actually collapse. */
                    textSpan: TextSpan;
                    /** The span of the document to display when the user hovers over the collapsed span. */
                    hintSpan: TextSpan;
                    /** The text to display in the editor for the collapsed region. */
                    bannerText: string;
                    /**
                     * Whether or not this region should be automatically collapsed when
                     * the 'Collapse to Definitions' command is invoked.
                     */
                    autoCollapse: boolean;
                    /**
                     * Classification of the contents of the span
                     */
                    kind: OutliningSpanKind;
                }
                export enum OutliningSpanKind {
                    /** Single or multi-line comments */
                    Comment = "comment",
                    /** Sections marked by '// #region' and '// #endregion' comments */
                    Region = "region",
                    /** Declarations and expressions */
                    Code = "code",
                    /** Contiguous blocks of import declarations */
                    Imports = "imports"
                }
                export enum OutputFileType {
                    JavaScript = 0,
                    SourceMap = 1,
                    Declaration = 2
                }
                export enum EndOfLineState {
                    None = 0,
                    InMultiLineCommentTrivia = 1,
                    InSingleQuoteStringLiteral = 2,
                    InDoubleQuoteStringLiteral = 3,
                    InTemplateHeadOrNoSubstitutionTemplate = 4,
                    InTemplateMiddleOrTail = 5,
                    InTemplateSubstitutionPosition = 6
                }
                export enum TokenClass {
                    Punctuation = 0,
                    Keyword = 1,
                    Operator = 2,
                    Comment = 3,
                    Whitespace = 4,
                    Identifier = 5,
                    NumberLiteral = 6,
                    BigIntLiteral = 7,
                    StringLiteral = 8,
                    RegExpLiteral = 9
                }
                export interface ClassificationResult {
                    finalLexState: EndOfLineState;
                    entries: ClassificationInfo[];
                }
                export interface ClassificationInfo {
                    length: number;
                    classification: TokenClass;
                }
                export interface Classifier {
                    /**
                     * Gives lexical classifications of tokens on a line without any syntactic context.
                     * For instance, a token consisting of the text 'string' can be either an identifier
                     * named 'string' or the keyword 'string', however, because this classifier is not aware,
                     * it relies on certain heuristics to give acceptable results. For classifications where
                     * speed trumps accuracy, this function is preferable; however, for true accuracy, the
                     * syntactic classifier is ideal. In fact, in certain editing scenarios, combining the
                     * lexical, syntactic, and semantic classifiers may issue the best user experience.
                     *
                     * @param text                      The text of a line to classify.
                     * @param lexState                  The state of the lexical classifier at the end of the previous line.
                     * @param syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.
                     *                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),
                     *                                  certain heuristics may be used in its place; however, if there is a
                     *                                  syntactic classifier (syntacticClassifierAbsent=false), certain
                     *                                  classifications which may be incorrectly categorized will be given
                     *                                  back as Identifiers in order to allow the syntactic classifier to
                     *                                  subsume the classification.
                     * @deprecated Use getLexicalClassifications instead.
                     */
                    getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;
                    getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;
                }
                export enum ScriptElementKind {
                    unknown = "",
                    warning = "warning",
                    /** predefined type (void) or keyword (class) */
                    keyword = "keyword",
                    /** top level script node */
                    scriptElement = "script",
                    /** module foo {} */
                    moduleElement = "module",
                    /** class X {} */
                    classElement = "class",
                    /** var x = class X {} */
                    localClassElement = "local class",
                    /** interface Y {} */
                    interfaceElement = "interface",
                    /** type T = ... */
                    typeElement = "type",
                    /** enum E */
                    enumElement = "enum",
                    enumMemberElement = "enum member",
                    /**
                     * Inside module and script only
                     * const v = ..
                     */
                    variableElement = "var",
                    /** Inside function */
                    localVariableElement = "local var",
                    /**
                     * Inside module and script only
                     * function f() { }
                     */
                    functionElement = "function",
                    /** Inside function */
                    localFunctionElement = "local function",
                    /** class X { [public|private]* foo() {} } */
                    memberFunctionElement = "method",
                    /** class X { [public|private]* [get|set] foo:number; } */
                    memberGetAccessorElement = "getter",
                    memberSetAccessorElement = "setter",
                    /**
                     * class X { [public|private]* foo:number; }
                     * interface Y { foo:number; }
                     */
                    memberVariableElement = "property",
                    /** class X { [public|private]* accessor foo: number; } */
                    memberAccessorVariableElement = "accessor",
                    /**
                     * class X { constructor() { } }
                     * class X { static { } }
                     */
                    constructorImplementationElement = "constructor",
                    /** interface Y { ():number; } */
                    callSignatureElement = "call",
                    /** interface Y { []:number; } */
                    indexSignatureElement = "index",
                    /** interface Y { new():Y; } */
                    constructSignatureElement = "construct",
                    /** function foo(*Y*: string) */
                    parameterElement = "parameter",
                    typeParameterElement = "type parameter",
                    primitiveType = "primitive type",
                    label = "label",
                    alias = "alias",
                    constElement = "const",
                    letElement = "let",
                    directory = "directory",
                    externalModuleName = "external module name",
                    /**
                     * <JsxTagName attribute1 attribute2={0} />
                     * @deprecated
                     */
                    jsxAttribute = "JSX attribute",
                    /** String literal */
                    string = "string",
                    /** Jsdoc @link: in `{@link C link text}`, the before and after text "{@link " and "}" */
                    link = "link",
                    /** Jsdoc @link: in `{@link C link text}`, the entity name "C" */
                    linkName = "link name",
                    /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */
                    linkText = "link text"
                }
                export enum ScriptElementKindModifier {
                    none = "",
                    publicMemberModifier = "public",
                    privateMemberModifier = "private",
                    protectedMemberModifier = "protected",
                    exportedModifier = "export",
                    ambientModifier = "declare",
                    staticModifier = "static",
                    abstractModifier = "abstract",
                    optionalModifier = "optional",
                    deprecatedModifier = "deprecated",
                    dtsModifier = ".d.ts",
                    tsModifier = ".ts",
                    tsxModifier = ".tsx",
                    jsModifier = ".js",
                    jsxModifier = ".jsx",
                    jsonModifier = ".json",
                    dmtsModifier = ".d.mts",
                    mtsModifier = ".mts",
                    mjsModifier = ".mjs",
                    dctsModifier = ".d.cts",
                    ctsModifier = ".cts",
                    cjsModifier = ".cjs"
                }
                export enum ClassificationTypeNames {
                    comment = "comment",
                    identifier = "identifier",
                    keyword = "keyword",
                    numericLiteral = "number",
                    bigintLiteral = "bigint",
                    operator = "operator",
                    stringLiteral = "string",
                    whiteSpace = "whitespace",
                    text = "text",
                    punctuation = "punctuation",
                    className = "class name",
                    enumName = "enum name",
                    interfaceName = "interface name",
                    moduleName = "module name",
                    typeParameterName = "type parameter name",
                    typeAliasName = "type alias name",
                    parameterName = "parameter name",
                    docCommentTagName = "doc comment tag name",
                    jsxOpenTagName = "jsx open tag name",
                    jsxCloseTagName = "jsx close tag name",
                    jsxSelfClosingTagName = "jsx self closing tag name",
                    jsxAttribute = "jsx attribute",
                    jsxText = "jsx text",
                    jsxAttributeStringLiteralValue = "jsx attribute string literal value"
                }
                export enum ClassificationType {
                    comment = 1,
                    identifier = 2,
                    keyword = 3,
                    numericLiteral = 4,
                    operator = 5,
                    stringLiteral = 6,
                    regularExpressionLiteral = 7,
                    whiteSpace = 8,
                    text = 9,
                    punctuation = 10,
                    className = 11,
                    enumName = 12,
                    interfaceName = 13,
                    moduleName = 14,
                    typeParameterName = 15,
                    typeAliasName = 16,
                    parameterName = 17,
                    docCommentTagName = 18,
                    jsxOpenTagName = 19,
                    jsxCloseTagName = 20,
                    jsxSelfClosingTagName = 21,
                    jsxAttribute = 22,
                    jsxText = 23,
                    jsxAttributeStringLiteralValue = 24,
                    bigintLiteral = 25
                }
                export interface InlayHintsContext {
                    file: SourceFile;
                    program: Program;
                    cancellationToken: CancellationToken;
                    host: LanguageServiceHost;
                    span: TextSpan;
                    preferences: UserPreferences;
                }
                /** The classifier is used for syntactic highlighting in editors via the TSServer */
                function createClassifier(): Classifier;
                export interface DocumentHighlights {
                    fileName: string;
                    highlightSpans: HighlightSpan[];
                }
                function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;
                /**
                 * The document registry represents a store of SourceFile objects that can be shared between
                 * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
                 * of files in the context.
                 * SourceFile objects account for most of the memory usage by the language service. Sharing
                 * the same DocumentRegistry instance between different instances of LanguageService allow
                 * for more efficient memory utilization since all projects will share at least the library
                 * file (lib.d.ts).
                 *
                 * A more advanced use of the document registry is to serialize sourceFile objects to disk
                 * and re-hydrate them when needed.
                 *
                 * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
                 * to all subsequent createLanguageService calls.
                 */
                export interface DocumentRegistry {
                    /**
                     * Request a stored SourceFile with a given fileName and compilationSettings.
                     * The first call to acquire will call createLanguageServiceSourceFile to generate
                     * the SourceFile if was not found in the registry.
                     *
                     * @param fileName The name of the file requested
                     * @param compilationSettingsOrHost Some compilation settings like target affects the
                     * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
                     * multiple copies of the same file for different compilation settings. A minimal
                     * resolution cache is needed to fully define a source file's shape when
                     * the compilation settings include `module: node16`+, so providing a cache host
                     * object should be preferred. A common host is a language service `ConfiguredProject`.
                     * @param scriptSnapshot Text of the file. Only used if the file was not found
                     * in the registry and a new one was created.
                     * @param version Current version of the file. Only used if the file was not found
                     * in the registry and a new one was created.
                     */
                    acquireDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
                    acquireDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
                    /**
                     * Request an updated version of an already existing SourceFile with a given fileName
                     * and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile
                     * to get an updated SourceFile.
                     *
                     * @param fileName The name of the file requested
                     * @param compilationSettingsOrHost Some compilation settings like target affects the
                     * shape of a the resulting SourceFile. This allows the DocumentRegistry to store
                     * multiple copies of the same file for different compilation settings. A minimal
                     * resolution cache is needed to fully define a source file's shape when
                     * the compilation settings include `module: node16`+, so providing a cache host
                     * object should be preferred. A common host is a language service `ConfiguredProject`.
                     * @param scriptSnapshot Text of the file.
                     * @param version Current version of the file.
                     */
                    updateDocument(fileName: string, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
                    updateDocumentWithKey(fileName: string, path: Path, compilationSettingsOrHost: CompilerOptions | MinimalResolutionCacheHost, key: DocumentRegistryBucketKey, scriptSnapshot: IScriptSnapshot, version: string, scriptKind?: ScriptKind, sourceFileOptions?: CreateSourceFileOptions | ScriptTarget): SourceFile;
                    getKeyForCompilationSettings(settings: CompilerOptions): DocumentRegistryBucketKey;
                    /**
                     * Informs the DocumentRegistry that a file is not needed any longer.
                     *
                     * Note: It is not allowed to call release on a SourceFile that was not acquired from
                     * this registry originally.
                     *
                     * @param fileName The name of the file to be released
                     * @param compilationSettings The compilation settings used to acquire the file
                     * @param scriptKind The script kind of the file to be released
                     */
                    /**@deprecated pass scriptKind and impliedNodeFormat for correctness */
                    releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): void;
                    /**
                     * Informs the DocumentRegistry that a file is not needed any longer.
                     *
                     * Note: It is not allowed to call release on a SourceFile that was not acquired from
                     * this registry originally.
                     *
                     * @param fileName The name of the file to be released
                     * @param compilationSettings The compilation settings used to acquire the file
                     * @param scriptKind The script kind of the file to be released
                     * @param impliedNodeFormat The implied source file format of the file to be released
                     */
                    releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind: ScriptKind, impliedNodeFormat: SourceFile["impliedNodeFormat"]): void;
                    /**
                     * @deprecated pass scriptKind for and impliedNodeFormat correctness */
                    releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind?: ScriptKind): void;
                    releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: SourceFile["impliedNodeFormat"]): void;
                    reportStats(): string;
                }
                export type DocumentRegistryBucketKey = string & {
                    __bucketKey: any;
                };
                function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
                function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
                function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
                export interface TranspileOptions {
                    compilerOptions?: CompilerOptions;
                    fileName?: string;
                    reportDiagnostics?: boolean;
                    moduleName?: string;
                    renamedDependencies?: MapLike<string>;
                    transformers?: CustomTransformers;
                }
                export interface TranspileOutput {
                    outputText: string;
                    diagnostics?: Diagnostic[];
                    sourceMapText?: string;
                }
                function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
                function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
                function getDefaultCompilerOptions(): CompilerOptions;
                function getSupportedCodeFixes(): string[];
                function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
                function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
                function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
                /**
                 * Get the path of the default library files (lib.d.ts) as distributed with the typescript
                 * node package.
                 * The functionality is not supported if the ts module is consumed outside of a node module.
                 */
                function getDefaultLibFilePath(options: CompilerOptions): string;
                /** The version of the language service API */
                export const servicesVersion = "0.8";
                /**
                 * Transform one or more nodes using the supplied transformers.
                 * @param source A single `Node` or an array of `Node` objects.
                 * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
                 * @param compilerOptions Optional compiler options.
                 */
                function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
                /** @deprecated Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */
                export const createNodeArray: <T extends Node>(elements?: readonly T[] | undefined, hasTrailingComma?: boolean | undefined) => NodeArray<T>;
                /** @deprecated Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */
                export const createNumericLiteral: (value: string | number, numericLiteralFlags?: TokenFlags | undefined) => NumericLiteral;
                /** @deprecated Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */
                export const createBigIntLiteral: (value: string | PseudoBigInt) => BigIntLiteral;
                /** @deprecated Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */
                export const createStringLiteral: {
                    (text: string, isSingleQuote?: boolean | undefined): StringLiteral;
                    (text: string, isSingleQuote?: boolean | undefined, hasExtendedUnicodeEscape?: boolean | undefined): StringLiteral;
                };
                /** @deprecated Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */
                export const createStringLiteralFromNode: (sourceNode: PrivateIdentifier | PropertyNameLiteral, isSingleQuote?: boolean | undefined) => StringLiteral;
                /** @deprecated Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */
                export const createRegularExpressionLiteral: (text: string) => RegularExpressionLiteral;
                /** @deprecated Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */
                export const createLoopVariable: (reservedInNestedScopes?: boolean | undefined) => Identifier;
                /** @deprecated Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */
                export const createUniqueName: (text: string, flags?: GeneratedIdentifierFlags | undefined) => Identifier;
                /** @deprecated Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */
                export const createPrivateIdentifier: (text: string) => PrivateIdentifier;
                /** @deprecated Use `factory.createSuper` or the factory supplied by your transformation context instead. */
                export const createSuper: () => SuperExpression;
                /** @deprecated Use `factory.createThis` or the factory supplied by your transformation context instead. */
                export const createThis: () => ThisExpression;
                /** @deprecated Use `factory.createNull` or the factory supplied by your transformation context instead. */
                export const createNull: () => NullLiteral;
                /** @deprecated Use `factory.createTrue` or the factory supplied by your transformation context instead. */
                export const createTrue: () => TrueLiteral;
                /** @deprecated Use `factory.createFalse` or the factory supplied by your transformation context instead. */
                export const createFalse: () => FalseLiteral;
                /** @deprecated Use `factory.createModifier` or the factory supplied by your transformation context instead. */
                export const createModifier: <T extends ModifierSyntaxKind>(kind: T) => ModifierToken<T>;
                /** @deprecated Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */
                export const createModifiersFromModifierFlags: (flags: ModifierFlags) => Modifier[] | undefined;
                /** @deprecated Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */
                export const createQualifiedName: (left: EntityName, right: string | Identifier) => QualifiedName;
                /** @deprecated Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */
                export const updateQualifiedName: (node: QualifiedName, left: EntityName, right: Identifier) => QualifiedName;
                /** @deprecated Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */
                export const createComputedPropertyName: (expression: Expression) => ComputedPropertyName;
                /** @deprecated Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */
                export const updateComputedPropertyName: (node: ComputedPropertyName, expression: Expression) => ComputedPropertyName;
                /** @deprecated Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
                export const createTypeParameterDeclaration: {
                    (modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode | undefined, defaultType?: TypeNode | undefined): TypeParameterDeclaration;
                    (name: string | Identifier, constraint?: TypeNode | undefined, defaultType?: TypeNode | undefined): TypeParameterDeclaration;
                };
                /** @deprecated Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
                export const updateTypeParameterDeclaration: {
                    (node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
                    (node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
                };
                /** @deprecated Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */
                export const createParameter: {
                    (modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken | undefined, type?: TypeNode | undefined, initializer?: Expression | undefined): ParameterDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken | undefined, type?: TypeNode | undefined, initializer?: Expression | undefined): ParameterDeclaration;
                };
                /** @deprecated Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */
                export const updateParameter: {
                    (node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
                    (node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
                };
                /** @deprecated Use `factory.createDecorator` or the factory supplied by your transformation context instead. */
                export const createDecorator: (expression: Expression) => Decorator;
                /** @deprecated Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */
                export const updateDecorator: (node: Decorator, expression: Expression) => Decorator;
                /** @deprecated Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */
                export const createProperty: {
                    (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                };
                /** @deprecated Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */
                export const updateProperty: {
                    (node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                    (node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
                };
                /** @deprecated Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */
                export const createMethod: {
                    (modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                };
                /** @deprecated Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */
                export const updateMethod: {
                    (node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                    (node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
                };
                /** @deprecated Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */
                export const createConstructor: {
                    (modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                };
                /** @deprecated Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */
                export const updateConstructor: {
                    (node: ConstructorDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                    (node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
                };
                /** @deprecated Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
                export const createGetAccessor: {
                    (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                };
                /** @deprecated Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
                export const updateGetAccessor: {
                    (node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                    (node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
                };
                /** @deprecated Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
                export const createSetAccessor: {
                    (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                };
                /** @deprecated Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
                export const updateSetAccessor: {
                    (node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                    (node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
                };
                /** @deprecated Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */
                export const createCallSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => CallSignatureDeclaration;
                /** @deprecated Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */
                export const updateCallSignature: (node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => CallSignatureDeclaration;
                /** @deprecated Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */
                export const createConstructSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => ConstructSignatureDeclaration;
                /** @deprecated Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */
                export const updateConstructSignature: (node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => ConstructSignatureDeclaration;
                /** @deprecated Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */
                export const updateIndexSignature: {
                    (node: IndexSignatureDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
                    (node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
                };
                /** @deprecated Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */
                export const createKeywordTypeNode: <TKind extends KeywordTypeSyntaxKind>(kind: TKind) => KeywordTypeNode<TKind>;
                /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
                export const createTypePredicateNodeWithModifier: (assertsModifier: AssertsKeyword | undefined, parameterName: string | Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;
                /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
                export const updateTypePredicateNodeWithModifier: (node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;
                /** @deprecated Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */
                export const createTypeReferenceNode: (typeName: string | EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeReferenceNode;
                /** @deprecated Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */
                export const updateTypeReferenceNode: (node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined) => TypeReferenceNode;
                /** @deprecated Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */
                export const createFunctionTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => FunctionTypeNode;
                /** @deprecated Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */
                export const updateFunctionTypeNode: (node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => FunctionTypeNode;
                /** @deprecated Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */
                export const createConstructorTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => ConstructorTypeNode;
                /** @deprecated Use `factory.updateConstructorTypeNode` or the factory supplied by your transformation context instead. */
                export const updateConstructorTypeNode: (node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => ConstructorTypeNode;
                /** @deprecated Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */
                export const createTypeQueryNode: (exprName: EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeQueryNode;
                /** @deprecated Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */
                export const updateTypeQueryNode: (node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeQueryNode;
                /** @deprecated Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */
                export const createTypeLiteralNode: (members: readonly TypeElement[] | undefined) => TypeLiteralNode;
                /** @deprecated Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */
                export const updateTypeLiteralNode: (node: TypeLiteralNode, members: NodeArray<TypeElement>) => TypeLiteralNode;
                /** @deprecated Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */
                export const createArrayTypeNode: (elementType: TypeNode) => ArrayTypeNode;
                /** @deprecated Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */
                export const updateArrayTypeNode: (node: ArrayTypeNode, elementType: TypeNode) => ArrayTypeNode;
                /** @deprecated Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */
                export const createTupleTypeNode: (elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;
                /** @deprecated Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */
                export const updateTupleTypeNode: (node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;
                /** @deprecated Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */
                export const createOptionalTypeNode: (type: TypeNode) => OptionalTypeNode;
                /** @deprecated Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */
                export const updateOptionalTypeNode: (node: OptionalTypeNode, type: TypeNode) => OptionalTypeNode;
                /** @deprecated Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */
                export const createRestTypeNode: (type: TypeNode) => RestTypeNode;
                /** @deprecated Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */
                export const updateRestTypeNode: (node: RestTypeNode, type: TypeNode) => RestTypeNode;
                /** @deprecated Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */
                export const createUnionTypeNode: (types: readonly TypeNode[]) => UnionTypeNode;
                /** @deprecated Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */
                export const updateUnionTypeNode: (node: UnionTypeNode, types: NodeArray<TypeNode>) => UnionTypeNode;
                /** @deprecated Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */
                export const createIntersectionTypeNode: (types: readonly TypeNode[]) => IntersectionTypeNode;
                /** @deprecated Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */
                export const updateIntersectionTypeNode: (node: IntersectionTypeNode, types: NodeArray<TypeNode>) => IntersectionTypeNode;
                /** @deprecated Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */
                export const createConditionalTypeNode: (checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;
                /** @deprecated Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */
                export const updateConditionalTypeNode: (node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;
                /** @deprecated Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */
                export const createInferTypeNode: (typeParameter: TypeParameterDeclaration) => InferTypeNode;
                /** @deprecated Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */
                export const updateInferTypeNode: (node: InferTypeNode, typeParameter: TypeParameterDeclaration) => InferTypeNode;
                /** @deprecated Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */
                export const createImportTypeNode: {
                    (argument: TypeNode, assertions?: ImportTypeAssertionContainer | undefined, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
                    (argument: TypeNode, assertions?: ImportTypeAssertionContainer | undefined, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
                    (argument: TypeNode, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
                };
                /** @deprecated Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */
                export const updateImportTypeNode: {
                    (node: ImportTypeNode, argument: TypeNode, assertions: ImportTypeAssertionContainer | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
                    (node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
                };
                /** @deprecated Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */
                export const createParenthesizedType: (type: TypeNode) => ParenthesizedTypeNode;
                /** @deprecated Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */
                export const updateParenthesizedType: (node: ParenthesizedTypeNode, type: TypeNode) => ParenthesizedTypeNode;
                /** @deprecated Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */
                export const createThisTypeNode: () => ThisTypeNode;
                /** @deprecated Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */
                export const updateTypeOperatorNode: (node: TypeOperatorNode, type: TypeNode) => TypeOperatorNode;
                /** @deprecated Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
                export const createIndexedAccessTypeNode: (objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;
                /** @deprecated Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
                export const updateIndexedAccessTypeNode: (node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;
                /** @deprecated Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */
                export const createMappedTypeNode: (readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;
                /** @deprecated Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */
                export const updateMappedTypeNode: (node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;
                /** @deprecated Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */
                export const createLiteralTypeNode: (literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;
                /** @deprecated Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */
                export const updateLiteralTypeNode: (node: LiteralTypeNode, literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;
                /** @deprecated Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */
                export const createObjectBindingPattern: (elements: readonly BindingElement[]) => ObjectBindingPattern;
                /** @deprecated Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */
                export const updateObjectBindingPattern: (node: ObjectBindingPattern, elements: readonly BindingElement[]) => ObjectBindingPattern;
                /** @deprecated Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */
                export const createArrayBindingPattern: (elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;
                /** @deprecated Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */
                export const updateArrayBindingPattern: (node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;
                /** @deprecated Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */
                export const createBindingElement: (dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression | undefined) => BindingElement;
                /** @deprecated Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */
                export const updateBindingElement: (node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined) => BindingElement;
                /** @deprecated Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */
                export const createArrayLiteral: (elements?: readonly Expression[] | undefined, multiLine?: boolean | undefined) => ArrayLiteralExpression;
                /** @deprecated Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */
                export const updateArrayLiteral: (node: ArrayLiteralExpression, elements: readonly Expression[]) => ArrayLiteralExpression;
                /** @deprecated Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */
                export const createObjectLiteral: (properties?: readonly ObjectLiteralElementLike[] | undefined, multiLine?: boolean | undefined) => ObjectLiteralExpression;
                /** @deprecated Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */
                export const updateObjectLiteral: (node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]) => ObjectLiteralExpression;
                /** @deprecated Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */
                export const createPropertyAccess: (expression: Expression, name: string | MemberName) => PropertyAccessExpression;
                /** @deprecated Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */
                export const updatePropertyAccess: (node: PropertyAccessExpression, expression: Expression, name: MemberName) => PropertyAccessExpression;
                /** @deprecated Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */
                export const createPropertyAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName) => PropertyAccessChain;
                /** @deprecated Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */
                export const updatePropertyAccessChain: (node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName) => PropertyAccessChain;
                /** @deprecated Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */
                export const createElementAccess: (expression: Expression, index: number | Expression) => ElementAccessExpression;
                /** @deprecated Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */
                export const updateElementAccess: (node: ElementAccessExpression, expression: Expression, argumentExpression: Expression) => ElementAccessExpression;
                /** @deprecated Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */
                export const createElementAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression) => ElementAccessChain;
                /** @deprecated Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */
                export const updateElementAccessChain: (node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression) => ElementAccessChain;
                /** @deprecated Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */
                export const createCall: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallExpression;
                /** @deprecated Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */
                export const updateCall: (node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallExpression;
                /** @deprecated Use `factory.createCallChain` or the factory supplied by your transformation context instead. */
                export const createCallChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallChain;
                /** @deprecated Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */
                export const updateCallChain: (node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallChain;
                /** @deprecated Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */
                export const createNew: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;
                /** @deprecated Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */
                export const updateNew: (node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;
                /** @deprecated Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */
                export const createTypeAssertion: (type: TypeNode, expression: Expression) => TypeAssertion;
                /** @deprecated Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */
                export const updateTypeAssertion: (node: TypeAssertion, type: TypeNode, expression: Expression) => TypeAssertion;
                /** @deprecated Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */
                export const createParen: (expression: Expression) => ParenthesizedExpression;
                /** @deprecated Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */
                export const updateParen: (node: ParenthesizedExpression, expression: Expression) => ParenthesizedExpression;
                /** @deprecated Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */
                export const createFunctionExpression: (modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block) => FunctionExpression;
                /** @deprecated Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */
                export const updateFunctionExpression: (node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block) => FunctionExpression;
                /** @deprecated Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */
                export const createDelete: (expression: Expression) => DeleteExpression;
                /** @deprecated Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */
                export const updateDelete: (node: DeleteExpression, expression: Expression) => DeleteExpression;
                /** @deprecated Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */
                export const createTypeOf: (expression: Expression) => TypeOfExpression;
                /** @deprecated Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */
                export const updateTypeOf: (node: TypeOfExpression, expression: Expression) => TypeOfExpression;
                /** @deprecated Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */
                export const createVoid: (expression: Expression) => VoidExpression;
                /** @deprecated Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */
                export const updateVoid: (node: VoidExpression, expression: Expression) => VoidExpression;
                /** @deprecated Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */
                export const createAwait: (expression: Expression) => AwaitExpression;
                /** @deprecated Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */
                export const updateAwait: (node: AwaitExpression, expression: Expression) => AwaitExpression;
                /** @deprecated Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */
                export const createPrefix: (operator: PrefixUnaryOperator, operand: Expression) => PrefixUnaryExpression;
                /** @deprecated Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */
                export const updatePrefix: (node: PrefixUnaryExpression, operand: Expression) => PrefixUnaryExpression;
                /** @deprecated Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */
                export const createPostfix: (operand: Expression, operator: PostfixUnaryOperator) => PostfixUnaryExpression;
                /** @deprecated Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */
                export const updatePostfix: (node: PostfixUnaryExpression, operand: Expression) => PostfixUnaryExpression;
                /** @deprecated Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */
                export const createBinary: (left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */
                export const updateConditional: (node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression) => ConditionalExpression;
                /** @deprecated Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */
                export const createTemplateExpression: (head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;
                /** @deprecated Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */
                export const updateTemplateExpression: (node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;
                /** @deprecated Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */
                export const createTemplateHead: {
                    (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateHead;
                    (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateHead;
                };
                /** @deprecated Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */
                export const createTemplateMiddle: {
                    (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateMiddle;
                    (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateMiddle;
                };
                /** @deprecated Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */
                export const createTemplateTail: {
                    (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateTail;
                    (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateTail;
                };
                /** @deprecated Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */
                export const createNoSubstitutionTemplateLiteral: {
                    (text: string, rawText?: string | undefined): NoSubstitutionTemplateLiteral;
                    (text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
                };
                /** @deprecated Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */
                export const updateYield: (node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined) => YieldExpression;
                /** @deprecated Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */
                export const createSpread: (expression: Expression) => SpreadElement;
                /** @deprecated Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */
                export const updateSpread: (node: SpreadElement, expression: Expression) => SpreadElement;
                /** @deprecated Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */
                export const createOmittedExpression: () => OmittedExpression;
                /** @deprecated Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */
                export const createAsExpression: (expression: Expression, type: TypeNode) => AsExpression;
                /** @deprecated Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */
                export const updateAsExpression: (node: AsExpression, expression: Expression, type: TypeNode) => AsExpression;
                /** @deprecated Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */
                export const createNonNullExpression: (expression: Expression) => NonNullExpression;
                /** @deprecated Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */
                export const updateNonNullExpression: (node: NonNullExpression, expression: Expression) => NonNullExpression;
                /** @deprecated Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */
                export const createNonNullChain: (expression: Expression) => NonNullChain;
                /** @deprecated Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */
                export const updateNonNullChain: (node: NonNullChain, expression: Expression) => NonNullChain;
                /** @deprecated Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */
                export const createMetaProperty: (keywordToken: SyntaxKind.ImportKeyword | SyntaxKind.NewKeyword, name: Identifier) => MetaProperty;
                /** @deprecated Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */
                export const updateMetaProperty: (node: MetaProperty, name: Identifier) => MetaProperty;
                /** @deprecated Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */
                export const createTemplateSpan: (expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;
                /** @deprecated Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */
                export const updateTemplateSpan: (node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;
                /** @deprecated Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */
                export const createSemicolonClassElement: () => SemicolonClassElement;
                /** @deprecated Use `factory.createBlock` or the factory supplied by your transformation context instead. */
                export const createBlock: (statements: readonly Statement[], multiLine?: boolean | undefined) => Block;
                /** @deprecated Use `factory.updateBlock` or the factory supplied by your transformation context instead. */
                export const updateBlock: (node: Block, statements: readonly Statement[]) => Block;
                /** @deprecated Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */
                export const createVariableStatement: (modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]) => VariableStatement;
                /** @deprecated Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */
                export const updateVariableStatement: (node: VariableStatement, modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList) => VariableStatement;
                /** @deprecated Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */
                export const createEmptyStatement: () => EmptyStatement;
                /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
                export const createExpressionStatement: (expression: Expression) => ExpressionStatement;
                /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
                export const updateExpressionStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;
                /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
                export const createStatement: (expression: Expression) => ExpressionStatement;
                /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
                export const updateStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;
                /** @deprecated Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */
                export const createIf: (expression: Expression, thenStatement: Statement, elseStatement?: Statement | undefined) => IfStatement;
                /** @deprecated Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */
                export const updateIf: (node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined) => IfStatement;
                /** @deprecated Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */
                export const createDo: (statement: Statement, expression: Expression) => DoStatement;
                /** @deprecated Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */
                export const updateDo: (node: DoStatement, statement: Statement, expression: Expression) => DoStatement;
                /** @deprecated Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */
                export const createWhile: (expression: Expression, statement: Statement) => WhileStatement;
                /** @deprecated Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */
                export const updateWhile: (node: WhileStatement, expression: Expression, statement: Statement) => WhileStatement;
                /** @deprecated Use `factory.createForStatement` or the factory supplied by your transformation context instead. */
                export const createFor: (initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;
                /** @deprecated Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */
                export const updateFor: (node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;
                /** @deprecated Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */
                export const createForIn: (initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;
                /** @deprecated Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */
                export const updateForIn: (node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;
                /** @deprecated Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */
                export const createForOf: (awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;
                /** @deprecated Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */
                export const updateForOf: (node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;
                /** @deprecated Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */
                export const createContinue: (label?: string | Identifier | undefined) => ContinueStatement;
                /** @deprecated Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */
                export const updateContinue: (node: ContinueStatement, label: Identifier | undefined) => ContinueStatement;
                /** @deprecated Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */
                export const createBreak: (label?: string | Identifier | undefined) => BreakStatement;
                /** @deprecated Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */
                export const updateBreak: (node: BreakStatement, label: Identifier | undefined) => BreakStatement;
                /** @deprecated Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */
                export const createReturn: (expression?: Expression | undefined) => ReturnStatement;
                /** @deprecated Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */
                export const updateReturn: (node: ReturnStatement, expression: Expression | undefined) => ReturnStatement;
                /** @deprecated Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */
                export const createWith: (expression: Expression, statement: Statement) => WithStatement;
                /** @deprecated Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */
                export const updateWith: (node: WithStatement, expression: Expression, statement: Statement) => WithStatement;
                /** @deprecated Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */
                export const createSwitch: (expression: Expression, caseBlock: CaseBlock) => SwitchStatement;
                /** @deprecated Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */
                export const updateSwitch: (node: SwitchStatement, expression: Expression, caseBlock: CaseBlock) => SwitchStatement;
                /** @deprecated Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */
                export const createLabel: (label: string | Identifier, statement: Statement) => LabeledStatement;
                /** @deprecated Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */
                export const updateLabel: (node: LabeledStatement, label: Identifier, statement: Statement) => LabeledStatement;
                /** @deprecated Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */
                export const createThrow: (expression: Expression) => ThrowStatement;
                /** @deprecated Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */
                export const updateThrow: (node: ThrowStatement, expression: Expression) => ThrowStatement;
                /** @deprecated Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */
                export const createTry: (tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;
                /** @deprecated Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */
                export const updateTry: (node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;
                /** @deprecated Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */
                export const createDebuggerStatement: () => DebuggerStatement;
                /** @deprecated Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */
                export const createVariableDeclarationList: (declarations: readonly VariableDeclaration[], flags?: NodeFlags | undefined) => VariableDeclarationList;
                /** @deprecated Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */
                export const updateVariableDeclarationList: (node: VariableDeclarationList, declarations: readonly VariableDeclaration[]) => VariableDeclarationList;
                /** @deprecated Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */
                export const createFunctionDeclaration: {
                    (modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                };
                /** @deprecated Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */
                export const updateFunctionDeclaration: {
                    (node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                    (node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
                };
                /** @deprecated Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */
                export const createClassDeclaration: {
                    (modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                };
                /** @deprecated Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */
                export const updateClassDeclaration: {
                    (node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                    (node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
                };
                /** @deprecated Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */
                export const createInterfaceDeclaration: {
                    (modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                };
                /** @deprecated Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */
                export const updateInterfaceDeclaration: {
                    (node: InterfaceDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                    (node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
                };
                /** @deprecated Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
                export const createTypeAliasDeclaration: {
                    (modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                };
                /** @deprecated Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
                export const updateTypeAliasDeclaration: {
                    (node: TypeAliasDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                    (node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
                };
                /** @deprecated Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */
                export const createEnumDeclaration: {
                    (modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
                };
                /** @deprecated Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */
                export const updateEnumDeclaration: {
                    (node: EnumDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
                    (node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
                };
                /** @deprecated Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */
                export const createModuleDeclaration: {
                    (modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags | undefined): ModuleDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags | undefined): ModuleDeclaration;
                };
                /** @deprecated Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */
                export const updateModuleDeclaration: {
                    (node: ModuleDeclaration, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
                    (node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
                };
                /** @deprecated Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */
                export const createModuleBlock: (statements: readonly Statement[]) => ModuleBlock;
                /** @deprecated Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */
                export const updateModuleBlock: (node: ModuleBlock, statements: readonly Statement[]) => ModuleBlock;
                /** @deprecated Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */
                export const createCaseBlock: (clauses: readonly CaseOrDefaultClause[]) => CaseBlock;
                /** @deprecated Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */
                export const updateCaseBlock: (node: CaseBlock, clauses: readonly CaseOrDefaultClause[]) => CaseBlock;
                /** @deprecated Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
                export const createNamespaceExportDeclaration: (name: string | Identifier) => NamespaceExportDeclaration;
                /** @deprecated Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
                export const updateNamespaceExportDeclaration: (node: NamespaceExportDeclaration, name: Identifier) => NamespaceExportDeclaration;
                /** @deprecated Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
                export const createImportEqualsDeclaration: {
                    (modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                };
                /** @deprecated Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
                export const updateImportEqualsDeclaration: {
                    (node: ImportEqualsDeclaration, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                    (node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
                };
                /** @deprecated Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */
                export const createImportDeclaration: {
                    (modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause | undefined): ImportDeclaration;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause | undefined): ImportDeclaration;
                };
                /** @deprecated Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */
                export const updateImportDeclaration: {
                    (node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
                    (node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
                };
                /** @deprecated Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */
                export const createNamespaceImport: (name: Identifier) => NamespaceImport;
                /** @deprecated Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */
                export const updateNamespaceImport: (node: NamespaceImport, name: Identifier) => NamespaceImport;
                /** @deprecated Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */
                export const createNamedImports: (elements: readonly ImportSpecifier[]) => NamedImports;
                /** @deprecated Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */
                export const updateNamedImports: (node: NamedImports, elements: readonly ImportSpecifier[]) => NamedImports;
                /** @deprecated Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */
                export const createImportSpecifier: (isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;
                /** @deprecated Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */
                export const updateImportSpecifier: (node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;
                /** @deprecated Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */
                export const createExportAssignment: {
                    (modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
                    (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
                };
                /** @deprecated Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */
                export const updateExportAssignment: {
                    (node: ExportAssignment, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
                    (node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
                };
                /** @deprecated Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */
                export const createNamedExports: (elements: readonly ExportSpecifier[]) => NamedExports;
                /** @deprecated Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */
                export const updateNamedExports: (node: NamedExports, elements: readonly ExportSpecifier[]) => NamedExports;
                /** @deprecated Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */
                export const createExportSpecifier: (isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier) => ExportSpecifier;
                /** @deprecated Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */
                export const updateExportSpecifier: (node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ExportSpecifier;
                /** @deprecated Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */
                export const createExternalModuleReference: (expression: Expression) => ExternalModuleReference;
                /** @deprecated Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */
                export const updateExternalModuleReference: (node: ExternalModuleReference, expression: Expression) => ExternalModuleReference;
                /** @deprecated Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */
                export const createJSDocTypeExpression: (type: TypeNode) => JSDocTypeExpression;
                /** @deprecated Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */
                export const createJSDocTypeTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypeTag;
                /** @deprecated Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */
                export const createJSDocReturnTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReturnTag;
                /** @deprecated Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */
                export const createJSDocThisTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocThisTag;
                /** @deprecated Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */
                export const createJSDocComment: (comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined) => JSDoc;
                /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
                export const createJSDocParameterTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocParameterTag;
                /** @deprecated Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */
                export const createJSDocClassTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocClassTag;
                /** @deprecated Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */
                export const createJSDocAugmentsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {
                    readonly expression: Identifier | PropertyAccessEntityNameExpression;
                }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAugmentsTag;
                /** @deprecated Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */
                export const createJSDocEnumTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocEnumTag;
                /** @deprecated Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */
                export const createJSDocTemplateTag: (tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTemplateTag;
                /** @deprecated Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */
                export const createJSDocTypedefTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeLiteral | JSDocTypeExpression | undefined, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypedefTag;
                /** @deprecated Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */
                export const createJSDocCallbackTag: (tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocCallbackTag;
                /** @deprecated Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */
                export const createJSDocSignature: (typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag | undefined) => JSDocSignature;
                /** @deprecated Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */
                export const createJSDocPropertyTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPropertyTag;
                /** @deprecated Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */
                export const createJSDocTypeLiteral: (jsDocPropertyTags?: readonly JSDocPropertyLikeTag[] | undefined, isArrayType?: boolean | undefined) => JSDocTypeLiteral;
                /** @deprecated Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */
                export const createJSDocImplementsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {
                    readonly expression: Identifier | PropertyAccessEntityNameExpression;
                }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocImplementsTag;
                /** @deprecated Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */
                export const createJSDocAuthorTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAuthorTag;
                /** @deprecated Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */
                export const createJSDocPublicTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPublicTag;
                /** @deprecated Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */
                export const createJSDocPrivateTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPrivateTag;
                /** @deprecated Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */
                export const createJSDocProtectedTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocProtectedTag;
                /** @deprecated Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */
                export const createJSDocReadonlyTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReadonlyTag;
                /** @deprecated Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */
                export const createJSDocTag: (tagName: Identifier, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocUnknownTag;
                /** @deprecated Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */
                export const createJsxElement: (openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;
                /** @deprecated Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */
                export const updateJsxElement: (node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;
                /** @deprecated Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
                export const createJsxSelfClosingElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;
                /** @deprecated Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
                export const updateJsxSelfClosingElement: (node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;
                /** @deprecated Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */
                export const createJsxOpeningElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;
                /** @deprecated Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */
                export const updateJsxOpeningElement: (node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;
                /** @deprecated Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */
                export const createJsxClosingElement: (tagName: JsxTagNameExpression) => JsxClosingElement;
                /** @deprecated Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */
                export const updateJsxClosingElement: (node: JsxClosingElement, tagName: JsxTagNameExpression) => JsxClosingElement;
                /** @deprecated Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */
                export const createJsxFragment: (openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;
                /** @deprecated Use `factory.createJsxText` or the factory supplied by your transformation context instead. */
                export const createJsxText: (text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;
                /** @deprecated Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */
                export const updateJsxText: (node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;
                /** @deprecated Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */
                export const createJsxOpeningFragment: () => JsxOpeningFragment;
                /** @deprecated Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */
                export const createJsxJsxClosingFragment: () => JsxClosingFragment;
                /** @deprecated Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */
                export const updateJsxFragment: (node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;
                /** @deprecated Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */
                export const createJsxAttribute: (name: Identifier, initializer: JsxAttributeValue | undefined) => JsxAttribute;
                /** @deprecated Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */
                export const updateJsxAttribute: (node: JsxAttribute, name: Identifier, initializer: JsxAttributeValue | undefined) => JsxAttribute;
                /** @deprecated Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */
                export const createJsxAttributes: (properties: readonly JsxAttributeLike[]) => JsxAttributes;
                /** @deprecated Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */
                export const updateJsxAttributes: (node: JsxAttributes, properties: readonly JsxAttributeLike[]) => JsxAttributes;
                /** @deprecated Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
                export const createJsxSpreadAttribute: (expression: Expression) => JsxSpreadAttribute;
                /** @deprecated Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
                export const updateJsxSpreadAttribute: (node: JsxSpreadAttribute, expression: Expression) => JsxSpreadAttribute;
                /** @deprecated Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */
                export const createJsxExpression: (dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined) => JsxExpression;
                /** @deprecated Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */
                export const updateJsxExpression: (node: JsxExpression, expression: Expression | undefined) => JsxExpression;
                /** @deprecated Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */
                export const createCaseClause: (expression: Expression, statements: readonly Statement[]) => CaseClause;
                /** @deprecated Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */
                export const updateCaseClause: (node: CaseClause, expression: Expression, statements: readonly Statement[]) => CaseClause;
                /** @deprecated Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */
                export const createDefaultClause: (statements: readonly Statement[]) => DefaultClause;
                /** @deprecated Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */
                export const updateDefaultClause: (node: DefaultClause, statements: readonly Statement[]) => DefaultClause;
                /** @deprecated Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */
                export const createHeritageClause: (token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;
                /** @deprecated Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */
                export const updateHeritageClause: (node: HeritageClause, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;
                /** @deprecated Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */
                export const createCatchClause: (variableDeclaration: string | VariableDeclaration | BindingName | undefined, block: Block) => CatchClause;
                /** @deprecated Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */
                export const updateCatchClause: (node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block) => CatchClause;
                /** @deprecated Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */
                export const createPropertyAssignment: (name: string | PropertyName, initializer: Expression) => PropertyAssignment;
                /** @deprecated Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */
                export const updatePropertyAssignment: (node: PropertyAssignment, name: PropertyName, initializer: Expression) => PropertyAssignment;
                /** @deprecated Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
                export const createShorthandPropertyAssignment: (name: string | Identifier, objectAssignmentInitializer?: Expression | undefined) => ShorthandPropertyAssignment;
                /** @deprecated Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
                export const updateShorthandPropertyAssignment: (node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined) => ShorthandPropertyAssignment;
                /** @deprecated Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */
                export const createSpreadAssignment: (expression: Expression) => SpreadAssignment;
                /** @deprecated Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */
                export const updateSpreadAssignment: (node: SpreadAssignment, expression: Expression) => SpreadAssignment;
                /** @deprecated Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */
                export const createEnumMember: (name: string | PropertyName, initializer?: Expression | undefined) => EnumMember;
                /** @deprecated Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */
                export const updateEnumMember: (node: EnumMember, name: PropertyName, initializer: Expression | undefined) => EnumMember;
                /** @deprecated Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */
                export const updateSourceFileNode: (node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean | undefined, referencedFiles?: readonly FileReference[] | undefined, typeReferences?: readonly FileReference[] | undefined, hasNoDefaultLib?: boolean | undefined, libReferences?: readonly FileReference[] | undefined) => SourceFile;
                /** @deprecated Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */
                export const createNotEmittedStatement: (original: Node) => NotEmittedStatement;
                /** @deprecated Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
                export const createPartiallyEmittedExpression: (expression: Expression, original?: Node | undefined) => PartiallyEmittedExpression;
                /** @deprecated Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
                export const updatePartiallyEmittedExpression: (node: PartiallyEmittedExpression, expression: Expression) => PartiallyEmittedExpression;
                /** @deprecated Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */
                export const createCommaList: (elements: readonly Expression[]) => CommaListExpression;
                /** @deprecated Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */
                export const updateCommaList: (node: CommaListExpression, elements: readonly Expression[]) => CommaListExpression;
                /** @deprecated Use `factory.createBundle` or the factory supplied by your transformation context instead. */
                export const createBundle: (sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;
                /** @deprecated Use `factory.updateBundle` or the factory supplied by your transformation context instead. */
                export const updateBundle: (node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;
                /** @deprecated Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */
                export const createImmediatelyInvokedFunctionExpression: {
                    (statements: readonly Statement[]): CallExpression;
                    (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
                };
                /** @deprecated Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */
                export const createImmediatelyInvokedArrowFunction: {
                    (statements: readonly Statement[]): CallExpression;
                    (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
                };
                /** @deprecated Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */
                export const createVoidZero: () => VoidExpression;
                /** @deprecated Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */
                export const createExportDefault: (expression: Expression) => ExportAssignment;
                /** @deprecated Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */
                export const createExternalModuleExport: (exportName: Identifier) => ExportDeclaration;
                /** @deprecated Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */
                export const createNamespaceExport: (name: Identifier) => NamespaceExport;
                /** @deprecated Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */
                export const updateNamespaceExport: (node: NamespaceExport, name: Identifier) => NamespaceExport;
                /** @deprecated Use `factory.createToken` or the factory supplied by your transformation context instead. */
                export const createToken: <TKind extends SyntaxKind>(kind: TKind) => Token<TKind>;
                /** @deprecated Use `factory.createIdentifier` or the factory supplied by your transformation context instead. */
                export const createIdentifier: (text: string) => Identifier;
                /** @deprecated Use `factory.createTempVariable` or the factory supplied by your transformation context instead. */
                export const createTempVariable: (recordTempVariable: ((node: Identifier) => void) | undefined) => Identifier;
                /** @deprecated Use `factory.getGeneratedNameForNode` or the factory supplied by your transformation context instead. */
                export const getGeneratedNameForNode: (node: Node | undefined) => Identifier;
                /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic)` or the factory supplied by your transformation context instead. */
                export const createOptimisticUniqueName: (text: string) => Identifier;
                /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic | GeneratedIdentifierFlags.FileLevel)` or the factory supplied by your transformation context instead. */
                export const createFileLevelUniqueName: (text: string) => Identifier;
                /** @deprecated Use `factory.createIndexSignature` or the factory supplied by your transformation context instead. */
                export const createIndexSignature: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => IndexSignatureDeclaration;
                /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
                export const createTypePredicateNode: (parameterName: Identifier | ThisTypeNode | string, type: TypeNode) => TypePredicateNode;
                /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
                export const updateTypePredicateNode: (node: TypePredicateNode, parameterName: Identifier | ThisTypeNode, type: TypeNode) => TypePredicateNode;
                /** @deprecated Use `factory.createStringLiteral`, `factory.createStringLiteralFromNode`, `factory.createNumericLiteral`, `factory.createBigIntLiteral`, `factory.createTrue`, `factory.createFalse`, or the factory supplied by your transformation context instead. */
                export const createLiteral: {
                    (value: string | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | Identifier): StringLiteral;
                    (value: number | PseudoBigInt): NumericLiteral;
                    (value: boolean): BooleanLiteral;
                    (value: string | number | PseudoBigInt | boolean): PrimaryExpression;
                };
                /** @deprecated Use `factory.createMethodSignature` or the factory supplied by your transformation context instead. */
                export const createMethodSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
                /** @deprecated Use `factory.updateMethodSignature` or the factory supplied by your transformation context instead. */
                export const updateMethodSignature: (node: MethodSignature, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined, name: PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
                /** @deprecated Use `factory.createTypeOperatorNode` or the factory supplied by your transformation context instead. */
                export const createTypeOperatorNode: {
                    (type: TypeNode): TypeOperatorNode;
                    (operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;
                };
                /** @deprecated Use `factory.createTaggedTemplate` or the factory supplied by your transformation context instead. */
                export const createTaggedTemplate: {
                    (tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;
                    (tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
                };
                /** @deprecated Use `factory.updateTaggedTemplate` or the factory supplied by your transformation context instead. */
                export const updateTaggedTemplate: {
                    (node: TaggedTemplateExpression, tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;
                    (node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
                };
                /** @deprecated Use `factory.updateBinary` or the factory supplied by your transformation context instead. */
                export const updateBinary: (node: BinaryExpression, left: Expression, right: Expression, operator?: BinaryOperator | BinaryOperatorToken) => BinaryExpression;
                /** @deprecated Use `factory.createConditional` or the factory supplied by your transformation context instead. */
                export const createConditional: {
                    (condition: Expression, whenTrue: Expression, whenFalse: Expression): ConditionalExpression;
                    (condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;
                };
                /** @deprecated Use `factory.createYield` or the factory supplied by your transformation context instead. */
                export const createYield: {
                    (expression?: Expression | undefined): YieldExpression;
                    (asteriskToken: AsteriskToken | undefined, expression: Expression): YieldExpression;
                };
                /** @deprecated Use `factory.createClassExpression` or the factory supplied by your transformation context instead. */
                export const createClassExpression: (modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
                /** @deprecated Use `factory.updateClassExpression` or the factory supplied by your transformation context instead. */
                export const updateClassExpression: (node: ClassExpression, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
                /** @deprecated Use `factory.createPropertySignature` or the factory supplied by your transformation context instead. */
                export const createPropertySignature: (modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer?: Expression | undefined) => PropertySignature;
                /** @deprecated Use `factory.updatePropertySignature` or the factory supplied by your transformation context instead. */
                export const updatePropertySignature: (node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertySignature;
                /** @deprecated Use `factory.createExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */
                export const createExpressionWithTypeArguments: (typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
                /** @deprecated Use `factory.updateExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */
                export const updateExpressionWithTypeArguments: (node: ExpressionWithTypeArguments, typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
                /** @deprecated Use `factory.createArrowFunction` or the factory supplied by your transformation context instead. */
                export const createArrowFunction: {
                    (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;
                    (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;
                };
                /** @deprecated Use `factory.updateArrowFunction` or the factory supplied by your transformation context instead. */
                export const updateArrowFunction: {
                    (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;
                    (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;
                };
                /** @deprecated Use `factory.createVariableDeclaration` or the factory supplied by your transformation context instead. */
                export const createVariableDeclaration: {
                    (name: string | BindingName, type?: TypeNode | undefined, initializer?: Expression | undefined): VariableDeclaration;
                    (name: string | BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
                };
                /** @deprecated Use `factory.updateVariableDeclaration` or the factory supplied by your transformation context instead. */
                export const updateVariableDeclaration: {
                    (node: VariableDeclaration, name: BindingName, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
                    (node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
                };
                /** @deprecated Use `factory.createImportClause` or the factory supplied by your transformation context instead. */
                export const createImportClause: (name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly?: any) => ImportClause;
                /** @deprecated Use `factory.updateImportClause` or the factory supplied by your transformation context instead. */
                export const updateImportClause: (node: ImportClause, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly: boolean) => ImportClause;
                /** @deprecated Use `factory.createExportDeclaration` or the factory supplied by your transformation context instead. */
                export const createExportDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression | undefined, isTypeOnly?: any) => ExportDeclaration;
                /** @deprecated Use `factory.updateExportDeclaration` or the factory supplied by your transformation context instead. */
                export const updateExportDeclaration: (node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, isTypeOnly: boolean) => ExportDeclaration;
                /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
                export const createJSDocParamTag: (name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, comment?: string | undefined) => JSDocParameterTag;
                /** @deprecated Use `factory.createComma` or the factory supplied by your transformation context instead. */
                export const createComma: (left: Expression, right: Expression) => Expression;
                /** @deprecated Use `factory.createLessThan` or the factory supplied by your transformation context instead. */
                export const createLessThan: (left: Expression, right: Expression) => Expression;
                /** @deprecated Use `factory.createAssignment` or the factory supplied by your transformation context instead. */
                export const createAssignment: (left: Expression, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.createStrictEquality` or the factory supplied by your transformation context instead. */
                export const createStrictEquality: (left: Expression, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.createStrictInequality` or the factory supplied by your transformation context instead. */
                export const createStrictInequality: (left: Expression, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.createAdd` or the factory supplied by your transformation context instead. */
                export const createAdd: (left: Expression, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.createSubtract` or the factory supplied by your transformation context instead. */
                export const createSubtract: (left: Expression, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.createLogicalAnd` or the factory supplied by your transformation context instead. */
                export const createLogicalAnd: (left: Expression, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.createLogicalOr` or the factory supplied by your transformation context instead. */
                export const createLogicalOr: (left: Expression, right: Expression) => BinaryExpression;
                /** @deprecated Use `factory.createPostfixIncrement` or the factory supplied by your transformation context instead. */
                export const createPostfixIncrement: (operand: Expression) => PostfixUnaryExpression;
                /** @deprecated Use `factory.createLogicalNot` or the factory supplied by your transformation context instead. */
                export const createLogicalNot: (operand: Expression) => PrefixUnaryExpression;
                /** @deprecated Use an appropriate `factory` method instead. */
                export const createNode: (kind: SyntaxKind, pos?: any, end?: any) => Node;
                /**
                 * Creates a shallow, memberwise clone of a node ~for mutation~ with its `pos`, `end`, and `parent` set.
                 *
                 * NOTE: It is unsafe to change any properties of a `Node` that relate to its AST children, as those changes won't be
                 * captured with respect to transformations.
                 *
                 * @deprecated Use an appropriate `factory.update...` method instead, use `setCommentRange` or `setSourceMapRange`, and avoid setting `parent`.
                 */
                export const getMutableClone: <T extends Node>(node: T) => T;
                /** @deprecated Use `isTypeAssertionExpression` instead. */
                export const isTypeAssertion: (node: Node) => node is TypeAssertion;
                /**
                 * @deprecated Use `isMemberName` instead.
                 */
                export const isIdentifierOrPrivateIdentifier: (node: Node) => node is MemberName;
            }
        }
    }
    export namespace Bundler {
        export namespace rollup {
            export namespace core {
                export function rollup(options: RollupOptions): Promise<RollupBuild>;
                export function watch(config: RollupWatchOptions | RollupWatchOptions[]): RollupWatcher;
                export function defineConfig(options: RollupOptions): RollupOptions;
                export function defineConfig(options: RollupOptions[]): RollupOptions[];
                export const VERSION: string;
                export interface RollupError extends RollupLogProps {
                    parserError?: Error;
                    stack?: string;
                    watchFiles?: string[];
                }
                export interface RollupWarning extends RollupLogProps {
                    chunkName?: string;
                    cycle?: string[];
                    exportName?: string;
                    exporter?: string;
                    guess?: string;
                    importer?: string;
                    missing?: string;
                    modules?: string[];
                    names?: string[];
                    reexporter?: string;
                    source?: string;
                    sources?: string[];
                }
                export interface RollupLogProps {
                    code?: string;
                    frame?: string;
                    hook?: string;
                    id?: string;
                    loc?: {
                        column: number;
                        file?: string;
                        line: number;
                    };
                    message: string;
                    name?: string;
                    plugin?: string;
                    pluginCode?: string;
                    pos?: number;
                    url?: string;
                }
                export type SourceMapSegment = [
                    number
                ] | [
                    number,
                    number,
                    number,
                    number
                ] | [
                    number,
                    number,
                    number,
                    number,
                    number
                ];
                export interface ExistingDecodedSourceMap {
                    file?: string;
                    mappings: SourceMapSegment[][];
                    names: string[];
                    sourceRoot?: string;
                    sources: string[];
                    sourcesContent?: string[];
                    version: number;
                }
                export interface ExistingRawSourceMap {
                    file?: string;
                    mappings: string;
                    names: string[];
                    sourceRoot?: string;
                    sources: string[];
                    sourcesContent?: string[];
                    version: number;
                }
                export type DecodedSourceMapOrMissing = {
                    mappings?: never;
                    missing: true;
                    plugin: string;
                } | ExistingDecodedSourceMap;
                export interface SourceMap {
                    file: string;
                    mappings: string;
                    names: string[];
                    sources: string[];
                    sourcesContent: string[];
                    version: number;
                    toString(): string;
                    toUrl(): string;
                }
                export type SourceMapInput = ExistingRawSourceMap | string | null | {
                    mappings: "";
                };
                export type PartialNull<T> = {
                    [P in keyof T]: T[P] | null;
                };
                export interface ModuleOptions {
                    meta: CustomPluginOptions;
                    moduleSideEffects: boolean | "no-treeshake";
                    syntheticNamedExports: boolean | string;
                }
                export interface SourceDescription extends Partial<PartialNull<ModuleOptions>> {
                    ast?: AcornNode;
                    code: string;
                    map?: SourceMapInput;
                }
                export interface TransformModuleJSON {
                    ast?: AcornNode;
                    code: string;
                    // note if plugins use new this.cache to opt-out auto transform cache
                    customTransformCache: boolean;
                    originalCode: string;
                    originalSourcemap: ExistingDecodedSourceMap | null;
                    sourcemapChain: DecodedSourceMapOrMissing[];
                    transformDependencies: string[];
                }
                export interface ModuleJSON extends TransformModuleJSON, ModuleOptions {
                    ast: AcornNode;
                    dependencies: string[];
                    id: string;
                    resolvedIds: ResolvedIdMap;
                    transformFiles: EmittedFile[] | undefined;
                }
                export interface PluginCache {
                    delete(id: string): boolean;
                    get<T = any>(id: string): T;
                    has(id: string): boolean;
                    set<T = any>(id: string, value: T): void;
                }
                export interface MinimalPluginContext {
                    meta: PluginContextMeta;
                }
                export interface EmittedAsset {
                    fileName?: string;
                    name?: string;
                    source?: string | Uint8Array;
                    type: "asset";
                }
                export interface EmittedChunk {
                    fileName?: string;
                    id: string;
                    implicitlyLoadedAfterOneOf?: string[];
                    importer?: string;
                    name?: string;
                    preserveSignature?: PreserveEntrySignaturesOption;
                    type: "chunk";
                }
                export type EmittedFile = EmittedAsset | EmittedChunk;
                export type EmitAsset = (name: string, source?: string | Uint8Array) => string;
                export type EmitChunk = (id: string, options?: {
                    name?: string;
                }) => string;
                export type EmitFile = (emittedFile: EmittedFile) => string;
                export interface ModuleInfo extends ModuleOptions {
                    ast: AcornNode | null;
                    code: string | null;
                    dynamicImporters: readonly string[];
                    dynamicallyImportedIdResolutions: readonly ResolvedId[];
                    dynamicallyImportedIds: readonly string[];
                    hasDefaultExport: boolean | null;
                    /** @deprecated Use `moduleSideEffects` instead */
                    hasModuleSideEffects: boolean | "no-treeshake";
                    id: string;
                    implicitlyLoadedAfterOneOf: readonly string[];
                    implicitlyLoadedBefore: readonly string[];
                    importedIdResolutions: readonly ResolvedId[];
                    importedIds: readonly string[];
                    importers: readonly string[];
                    isEntry: boolean;
                    isExternal: boolean;
                    isIncluded: boolean | null;
                }
                export type GetModuleInfo = (moduleId: string) => ModuleInfo | null;
                export interface CustomPluginOptions {
                    [plugin: string]: any;
                }
                export interface PluginContext extends MinimalPluginContext {
                    addWatchFile: (id: string) => void;
                    cache: PluginCache;
                    /** @deprecated Use `this.emitFile` instead */
                    emitAsset: EmitAsset;
                    /** @deprecated Use `this.emitFile` instead */
                    emitChunk: EmitChunk;
                    emitFile: EmitFile;
                    error: (err: RollupError | string, pos?: number | {
                        column: number;
                        line: number;
                    }) => never;
                    /** @deprecated Use `this.getFileName` instead */
                    getAssetFileName: (assetReferenceId: string) => string;
                    /** @deprecated Use `this.getFileName` instead */
                    getChunkFileName: (chunkReferenceId: string) => string;
                    getFileName: (fileReferenceId: string) => string;
                    getModuleIds: () => IterableIterator<string>;
                    getModuleInfo: GetModuleInfo;
                    getWatchFiles: () => string[];
                    /** @deprecated Use `this.resolve` instead */
                    isExternal: IsExternal;
                    load: (options: {
                        id: string;
                        resolveDependencies?: boolean;
                    } & Partial<PartialNull<ModuleOptions>>) => Promise<ModuleInfo>;
                    /** @deprecated Use `this.getModuleIds` instead */
                    moduleIds: IterableIterator<string>;
                    parse: (input: string, options?: any) => AcornNode;
                    resolve: (source: string, importer?: string, options?: {
                        custom?: CustomPluginOptions;
                        isEntry?: boolean;
                        skipSelf?: boolean;
                    }) => Promise<ResolvedId | null>;
                    /** @deprecated Use `this.resolve` instead */
                    resolveId: (source: string, importer?: string) => Promise<string | null>;
                    setAssetSource: (assetReferenceId: string, source: string | Uint8Array) => void;
                    warn: (warning: RollupWarning | string, pos?: number | {
                        column: number;
                        line: number;
                    }) => void;
                }
                export interface PluginContextMeta {
                    rollupVersion: string;
                    watchMode: boolean;
                }
                export interface ResolvedId extends ModuleOptions {
                    external: boolean | "absolute";
                    id: string;
                }
                export interface ResolvedIdMap {
                    [key: string]: ResolvedId;
                }
                export interface PartialResolvedId extends Partial<PartialNull<ModuleOptions>> {
                    external?: boolean | "absolute" | "relative";
                    id: string;
                }
                export type ResolveIdResult = string | false | null | void | PartialResolvedId;
                export type ResolveIdHook = (this: PluginContext, source: string, importer: string | undefined, options: {
                    custom?: CustomPluginOptions;
                    isEntry: boolean;
                }) => ResolveIdResult;
                export type ShouldTransformCachedModuleHook = (this: PluginContext, options: {
                    ast: AcornNode;
                    code: string;
                    id: string;
                    meta: CustomPluginOptions;
                    moduleSideEffects: boolean | "no-treeshake";
                    resolvedSources: ResolvedIdMap;
                    syntheticNamedExports: boolean | string;
                }) => boolean;
                export type IsExternal = (source: string, importer: string | undefined, isResolved: boolean) => boolean;
                export type IsPureModule = (id: string) => boolean | null | void;
                export type HasModuleSideEffects = (id: string, external: boolean) => boolean;
                export type LoadResult = SourceDescription | string | null | void;
                export type LoadHook = (this: PluginContext, id: string) => LoadResult;
                export interface TransformPluginContext extends PluginContext {
                    getCombinedSourcemap: () => SourceMap;
                }
                export type TransformResult = string | null | void | Partial<SourceDescription>;
                export type TransformHook = (this: TransformPluginContext, code: string, id: string) => TransformResult;
                export type ModuleParsedHook = (this: PluginContext, info: ModuleInfo) => void;
                export type RenderChunkHook = (this: PluginContext, code: string, chunk: RenderedChunk, options: NormalizedOutputOptions) => {
                    code: string;
                    map?: SourceMapInput;
                } | string | null | undefined;
                export type ResolveDynamicImportHook = (this: PluginContext, specifier: string | AcornNode, importer: string) => ResolveIdResult;
                export type ResolveImportMetaHook = (this: PluginContext, prop: string | null, options: {
                    chunkId: string;
                    format: InternalModuleFormat;
                    moduleId: string;
                }) => string | null | void;
                export type ResolveAssetUrlHook = (this: PluginContext, options: {
                    assetFileName: string;
                    chunkId: string;
                    format: InternalModuleFormat;
                    moduleId: string;
                    relativeAssetPath: string;
                }) => string | null | void;
                export type ResolveFileUrlHook = (this: PluginContext, options: {
                    assetReferenceId: string | null;
                    chunkId: string;
                    chunkReferenceId: string | null;
                    fileName: string;
                    format: InternalModuleFormat;
                    moduleId: string;
                    referenceId: string;
                    relativePath: string;
                }) => string | null | void;
                export type AddonHookFunction = (this: PluginContext) => string | Promise<string>;
                export type AddonHook = string | AddonHookFunction;
                export type ChangeEvent = "create" | "update" | "delete";
                export type WatchChangeHook = (this: PluginContext, id: string, change: {
                    event: ChangeEvent;
                }) => void;
                /**
                 * use this type for plugin annotation
                 * @example
                 * ```ts
                 * interface Options {
                 * ...
                 * }
                 * const myPlugin: PluginImpl<Options> = (options = {}) => { ... }
                 * ```
                 */
                // eslint-disable-next-line @typescript-eslint/ban-types
                export type PluginImpl<O extends object = object> = (options?: O) => Plugin;
                export interface OutputBundle {
                    [fileName: string]: OutputAsset | OutputChunk;
                }
                export interface FunctionPluginHooks {
                    augmentChunkHash: (this: PluginContext, chunk: PreRenderedChunk) => string | void;
                    buildEnd: (this: PluginContext, err?: Error) => void;
                    buildStart: (this: PluginContext, options: NormalizedInputOptions) => void;
                    closeBundle: (this: PluginContext) => void;
                    closeWatcher: (this: PluginContext) => void;
                    generateBundle: (this: PluginContext, options: NormalizedOutputOptions, bundle: OutputBundle, isWrite: boolean) => void;
                    load: LoadHook;
                    moduleParsed: ModuleParsedHook;
                    options: (this: MinimalPluginContext, options: InputOptions) => InputOptions | null | void;
                    outputOptions: (this: PluginContext, options: OutputOptions) => OutputOptions | null | void;
                    renderChunk: RenderChunkHook;
                    renderDynamicImport: (this: PluginContext, options: {
                        customResolution: string | null;
                        format: InternalModuleFormat;
                        moduleId: string;
                        targetModuleId: string | null;
                    }) => {
                        left: string;
                        right: string;
                    } | null | void;
                    renderError: (this: PluginContext, err?: Error) => void;
                    renderStart: (this: PluginContext, outputOptions: NormalizedOutputOptions, inputOptions: NormalizedInputOptions) => void;
                    /** @deprecated Use `resolveFileUrl` instead */
                    resolveAssetUrl: ResolveAssetUrlHook;
                    resolveDynamicImport: ResolveDynamicImportHook;
                    resolveFileUrl: ResolveFileUrlHook;
                    resolveId: ResolveIdHook;
                    resolveImportMeta: ResolveImportMetaHook;
                    shouldTransformCachedModule: ShouldTransformCachedModuleHook;
                    transform: TransformHook;
                    watchChange: WatchChangeHook;
                    writeBundle: (this: PluginContext, options: NormalizedOutputOptions, bundle: OutputBundle) => void;
                }
                export type OutputPluginHooks = "augmentChunkHash" | "generateBundle" | "outputOptions" | "renderChunk" | "renderDynamicImport" | "renderError" | "renderStart" | "resolveAssetUrl" | "resolveFileUrl" | "resolveImportMeta" | "writeBundle";
                export type InputPluginHooks = Exclude<keyof FunctionPluginHooks, OutputPluginHooks>;
                export type SyncPluginHooks = "augmentChunkHash" | "outputOptions" | "renderDynamicImport" | "resolveAssetUrl" | "resolveFileUrl" | "resolveImportMeta";
                export type AsyncPluginHooks = Exclude<keyof FunctionPluginHooks, SyncPluginHooks>;
                export type FirstPluginHooks = "load" | "renderDynamicImport" | "resolveAssetUrl" | "resolveDynamicImport" | "resolveFileUrl" | "resolveId" | "resolveImportMeta" | "shouldTransformCachedModule";
                export type SequentialPluginHooks = "augmentChunkHash" | "generateBundle" | "options" | "outputOptions" | "renderChunk" | "transform";
                export type ParallelPluginHooks = Exclude<keyof FunctionPluginHooks | AddonHooks, FirstPluginHooks | SequentialPluginHooks>;
                export type AddonHooks = "banner" | "footer" | "intro" | "outro";
                export type MakeAsync<Fn> = Fn extends (this: infer This, ...args: infer Args) => infer Return ? (this: This, ...args: Args) => Return | Promise<Return> : never;
                // eslint-disable-next-line @typescript-eslint/ban-types
                export type ObjectHook<T, O = {}> = T | ({
                    handler: T;
                    order?: "pre" | "post" | null;
                } & O);
                export type PluginHooks = {
                    [K in keyof FunctionPluginHooks]: ObjectHook<K extends AsyncPluginHooks ? MakeAsync<FunctionPluginHooks[K]> : FunctionPluginHooks[K], K extends ParallelPluginHooks ? {
                        sequential?: boolean;
                    } : {}>;
                };
                export interface OutputPlugin extends Partial<{
                    [K in OutputPluginHooks]: PluginHooks[K];
                }>, Partial<{
                    [K in AddonHooks]: ObjectHook<AddonHook>;
                }> {
                    cacheKey?: string;
                    name: string;
                }
                export interface Plugin extends OutputPlugin, Partial<PluginHooks> {
                    // for inter-plugin communication
                    api?: any;
                }
                export type TreeshakingPreset = "smallest" | "safest" | "recommended";
                export interface NormalizedTreeshakingOptions {
                    annotations: boolean;
                    correctVarValueBeforeDeclaration: boolean;
                    moduleSideEffects: HasModuleSideEffects;
                    propertyReadSideEffects: boolean | "always";
                    tryCatchDeoptimization: boolean;
                    unknownGlobalSideEffects: boolean;
                }
                export interface TreeshakingOptions extends Partial<Omit<NormalizedTreeshakingOptions, "moduleSideEffects">> {
                    moduleSideEffects?: ModuleSideEffectsOption;
                    preset?: TreeshakingPreset;
                    /** @deprecated Use `moduleSideEffects` instead */
                    pureExternalModules?: PureModulesOption;
                }
                export interface GetManualChunkApi {
                    getModuleIds: () => IterableIterator<string>;
                    getModuleInfo: GetModuleInfo;
                }
                export type GetManualChunk = (id: string, api: GetManualChunkApi) => string | null | void;
                export type ExternalOption = (string | RegExp)[] | string | RegExp | ((source: string, importer: string | undefined, isResolved: boolean) => boolean | null | void);
                export type PureModulesOption = boolean | string[] | IsPureModule;
                export type GlobalsOption = {
                    [name: string]: string;
                } | ((name: string) => string);
                export type InputOption = string | string[] | {
                    [entryAlias: string]: string;
                };
                export type ManualChunksOption = {
                    [chunkAlias: string]: string[];
                } | GetManualChunk;
                export type ModuleSideEffectsOption = boolean | "no-external" | string[] | HasModuleSideEffects;
                export type PreserveEntrySignaturesOption = false | "strict" | "allow-extension" | "exports-only";
                export type SourcemapPathTransformOption = (relativeSourcePath: string, sourcemapPath: string) => string;
                export interface InputOptions {
                    acorn?: Record<string, unknown>;
                    acornInjectPlugins?: (() => unknown)[] | (() => unknown);
                    cache?: false | RollupCache;
                    context?: string;
                    experimentalCacheExpiry?: number;
                    external?: ExternalOption;
                    /** @deprecated Use the "inlineDynamicImports" output option instead. */
                    inlineDynamicImports?: boolean;
                    input?: InputOption;
                    makeAbsoluteExternalsRelative?: boolean | "ifRelativeSource";
                    /** @deprecated Use the "manualChunks" output option instead. */
                    manualChunks?: ManualChunksOption;
                    maxParallelFileOps?: number;
                    /** @deprecated Use the "maxParallelFileOps" option instead. */
                    maxParallelFileReads?: number;
                    moduleContext?: ((id: string) => string | null | void) | {
                        [id: string]: string;
                    };
                    onwarn?: WarningHandlerWithDefault;
                    perf?: boolean;
                    plugins?: (Plugin | null | false | undefined)[];
                    preserveEntrySignatures?: PreserveEntrySignaturesOption;
                    /** @deprecated Use the "preserveModules" output option instead. */
                    preserveModules?: boolean;
                    preserveSymlinks?: boolean;
                    shimMissingExports?: boolean;
                    strictDeprecations?: boolean;
                    treeshake?: boolean | TreeshakingPreset | TreeshakingOptions;
                    watch?: WatcherOptions | false;
                }
                export interface NormalizedInputOptions {
                    acorn: Record<string, unknown>;
                    acornInjectPlugins: (() => unknown)[];
                    cache: false | undefined | RollupCache;
                    context: string;
                    experimentalCacheExpiry: number;
                    external: IsExternal;
                    /** @deprecated Use the "inlineDynamicImports" output option instead. */
                    inlineDynamicImports: boolean | undefined;
                    input: string[] | {
                        [entryAlias: string]: string;
                    };
                    makeAbsoluteExternalsRelative: boolean | "ifRelativeSource";
                    /** @deprecated Use the "manualChunks" output option instead. */
                    manualChunks: ManualChunksOption | undefined;
                    maxParallelFileOps: number;
                    /** @deprecated Use the "maxParallelFileOps" option instead. */
                    maxParallelFileReads: number;
                    moduleContext: (id: string) => string;
                    onwarn: WarningHandler;
                    perf: boolean;
                    plugins: Plugin[];
                    preserveEntrySignatures: PreserveEntrySignaturesOption;
                    /** @deprecated Use the "preserveModules" output option instead. */
                    preserveModules: boolean | undefined;
                    preserveSymlinks: boolean;
                    shimMissingExports: boolean;
                    strictDeprecations: boolean;
                    treeshake: false | NormalizedTreeshakingOptions;
                }
                export type InternalModuleFormat = "amd" | "cjs" | "es" | "iife" | "system" | "umd";
                export type ModuleFormat = InternalModuleFormat | "commonjs" | "esm" | "module" | "systemjs";
                export type GeneratedCodePreset = "es5" | "es2015";
                export interface NormalizedGeneratedCodeOptions {
                    arrowFunctions: boolean;
                    constBindings: boolean;
                    objectShorthand: boolean;
                    reservedNamesAsProps: boolean;
                    symbols: boolean;
                }
                export interface GeneratedCodeOptions extends Partial<NormalizedGeneratedCodeOptions> {
                    preset?: GeneratedCodePreset;
                }
                export type OptionsPaths = Record<string, string> | ((id: string) => string);
                export type InteropType = boolean | "auto" | "esModule" | "default" | "defaultOnly";
                export type GetInterop = (id: string | null) => InteropType;
                export type AmdOptions = ({
                    autoId?: false;
                    id: string;
                } | {
                    autoId: true;
                    basePath?: string;
                    id?: undefined;
                } | {
                    autoId?: false;
                    id?: undefined;
                }) & {
                    define?: string;
                    forceJsExtensionForImports?: boolean;
                };
                export type NormalizedAmdOptions = ({
                    autoId: false;
                    id?: string;
                } | {
                    autoId: true;
                    basePath: string;
                }) & {
                    define: string;
                    forceJsExtensionForImports: boolean;
                };
                export interface OutputOptions {
                    amd?: AmdOptions;
                    assetFileNames?: string | ((chunkInfo: PreRenderedAsset) => string);
                    banner?: string | (() => string | Promise<string>);
                    chunkFileNames?: string | ((chunkInfo: PreRenderedChunk) => string);
                    compact?: boolean;
                    // only required for bundle.write
                    dir?: string;
                    /** @deprecated Use the "renderDynamicImport" plugin hook instead. */
                    dynamicImportFunction?: string;
                    entryFileNames?: string | ((chunkInfo: PreRenderedChunk) => string);
                    esModule?: boolean;
                    exports?: "default" | "named" | "none" | "auto";
                    extend?: boolean;
                    externalLiveBindings?: boolean;
                    // only required for bundle.write
                    file?: string;
                    footer?: string | (() => string | Promise<string>);
                    format?: ModuleFormat;
                    freeze?: boolean;
                    generatedCode?: GeneratedCodePreset | GeneratedCodeOptions;
                    globals?: GlobalsOption;
                    hoistTransitiveImports?: boolean;
                    indent?: string | boolean;
                    inlineDynamicImports?: boolean;
                    interop?: InteropType | GetInterop;
                    intro?: string | (() => string | Promise<string>);
                    manualChunks?: ManualChunksOption;
                    minifyInternalExports?: boolean;
                    name?: string;
                    /** @deprecated Use "generatedCode.symbols" instead. */
                    namespaceToStringTag?: boolean;
                    noConflict?: boolean;
                    outro?: string | (() => string | Promise<string>);
                    paths?: OptionsPaths;
                    plugins?: (OutputPlugin | null | false | undefined)[];
                    /** @deprecated Use "generatedCode.constBindings" instead. */
                    preferConst?: boolean;
                    preserveModules?: boolean;
                    preserveModulesRoot?: string;
                    sanitizeFileName?: boolean | ((fileName: string) => string);
                    sourcemap?: boolean | "inline" | "hidden";
                    sourcemapBaseUrl?: string;
                    sourcemapExcludeSources?: boolean;
                    sourcemapFile?: string;
                    sourcemapPathTransform?: SourcemapPathTransformOption;
                    strict?: boolean;
                    systemNullSetters?: boolean;
                    validate?: boolean;
                }
                export interface NormalizedOutputOptions {
                    amd: NormalizedAmdOptions;
                    assetFileNames: string | ((chunkInfo: PreRenderedAsset) => string);
                    banner: () => string | Promise<string>;
                    chunkFileNames: string | ((chunkInfo: PreRenderedChunk) => string);
                    compact: boolean;
                    dir: string | undefined;
                    /** @deprecated Use the "renderDynamicImport" plugin hook instead. */
                    dynamicImportFunction: string | undefined;
                    entryFileNames: string | ((chunkInfo: PreRenderedChunk) => string);
                    esModule: boolean;
                    exports: "default" | "named" | "none" | "auto";
                    extend: boolean;
                    externalLiveBindings: boolean;
                    file: string | undefined;
                    footer: () => string | Promise<string>;
                    format: InternalModuleFormat;
                    freeze: boolean;
                    generatedCode: NormalizedGeneratedCodeOptions;
                    globals: GlobalsOption;
                    hoistTransitiveImports: boolean;
                    indent: true | string;
                    inlineDynamicImports: boolean;
                    interop: GetInterop;
                    intro: () => string | Promise<string>;
                    manualChunks: ManualChunksOption;
                    minifyInternalExports: boolean;
                    name: string | undefined;
                    namespaceToStringTag: boolean;
                    noConflict: boolean;
                    outro: () => string | Promise<string>;
                    paths: OptionsPaths;
                    plugins: OutputPlugin[];
                    /** @deprecated Use the "renderDynamicImport" plugin hook instead. */
                    preferConst: boolean;
                    preserveModules: boolean;
                    preserveModulesRoot: string | undefined;
                    sanitizeFileName: (fileName: string) => string;
                    sourcemap: boolean | "inline" | "hidden";
                    sourcemapBaseUrl: string | undefined;
                    sourcemapExcludeSources: boolean;
                    sourcemapFile: string | undefined;
                    sourcemapPathTransform: SourcemapPathTransformOption | undefined;
                    strict: boolean;
                    systemNullSetters: boolean;
                    validate: boolean;
                }
                export type WarningHandlerWithDefault = (warning: RollupWarning, defaultHandler: WarningHandler) => void;
                export type WarningHandler = (warning: RollupWarning) => void;
                export interface SerializedTimings {
                    [label: string]: [
                        number,
                        number,
                        number
                    ];
                }
                export interface PreRenderedAsset {
                    name: string | undefined;
                    source: string | Uint8Array;
                    type: "asset";
                }
                export interface OutputAsset extends PreRenderedAsset {
                    fileName: string;
                    /** @deprecated Accessing "isAsset" on files in the bundle is deprecated, please use "type === \'asset\'" instead */
                    isAsset: true;
                }
                export interface RenderedModule {
                    code: string | null;
                    originalLength: number;
                    removedExports: string[];
                    renderedExports: string[];
                    renderedLength: number;
                }
                export interface PreRenderedChunk {
                    exports: string[];
                    facadeModuleId: string | null;
                    isDynamicEntry: boolean;
                    isEntry: boolean;
                    isImplicitEntry: boolean;
                    modules: {
                        [id: string]: RenderedModule;
                    };
                    name: string;
                    type: "chunk";
                }
                export interface RenderedChunk extends PreRenderedChunk {
                    code?: string;
                    dynamicImports: string[];
                    fileName: string;
                    implicitlyLoadedBefore: string[];
                    importedBindings: {
                        [imported: string]: string[];
                    };
                    imports: string[];
                    map?: SourceMap;
                    referencedFiles: string[];
                }
                export interface OutputChunk extends RenderedChunk {
                    code: string;
                }
                export interface SerializablePluginCache {
                    [key: string]: [
                        number,
                        any
                    ];
                }
                export interface RollupCache {
                    modules: ModuleJSON[];
                    plugins?: Record<string, SerializablePluginCache>;
                }
                export interface RollupOutput {
                    output: [
                        OutputChunk,
                        ...(OutputChunk | OutputAsset)[]
                    ];
                }
                export interface RollupBuild {
                    cache: RollupCache | undefined;
                    close: () => Promise<void>;
                    closed: boolean;
                    generate: (outputOptions: OutputOptions) => Promise<RollupOutput>;
                    getTimings?: () => SerializedTimings;
                    watchFiles: string[];
                    write: (options: OutputOptions) => Promise<RollupOutput>;
                }
                export interface RollupOptions extends InputOptions {
                    // This is included for compatibility with config files but ignored by rollup.rollup
                    output?: OutputOptions | OutputOptions[];
                }
                export interface MergedRollupOptions extends InputOptions {
                    output: OutputOptions[];
                }
                export interface ChokidarOptions {
                    alwaysStat?: boolean;
                    atomic?: boolean | number;
                    awaitWriteFinish?: {
                        pollInterval?: number;
                        stabilityThreshold?: number;
                    } | boolean;
                    binaryInterval?: number;
                    cwd?: string;
                    depth?: number;
                    disableGlobbing?: boolean;
                    followSymlinks?: boolean;
                    ignoreInitial?: boolean;
                    ignorePermissionErrors?: boolean;
                    ignored?: any;
                    interval?: number;
                    persistent?: boolean;
                    useFsEvents?: boolean;
                    usePolling?: boolean;
                }
                export type RollupWatchHooks = "onError" | "onStart" | "onBundleStart" | "onBundleEnd" | "onEnd";
                export interface WatcherOptions {
                    buildDelay?: number;
                    chokidar?: ChokidarOptions;
                    clearScreen?: boolean;
                    exclude?: string | RegExp | (string | RegExp)[];
                    include?: string | RegExp | (string | RegExp)[];
                    skipWrite?: boolean;
                }
                export interface RollupWatchOptions extends InputOptions {
                    output?: OutputOptions | OutputOptions[];
                    watch?: WatcherOptions | false;
                }
                export interface TypedEventEmitter<T extends {
                    [event: string]: (...args: any) => any;
                }> {
                    addListener<K extends keyof T>(event: K, listener: T[K]): this;
                    emit<K extends keyof T>(event: K, ...args: Parameters<T[K]>): boolean;
                    eventNames(): Array<keyof T>;
                    getMaxListeners(): number;
                    listenerCount(type: keyof T): number;
                    listeners<K extends keyof T>(event: K): Array<T[K]>;
                    off<K extends keyof T>(event: K, listener: T[K]): this;
                    on<K extends keyof T>(event: K, listener: T[K]): this;
                    once<K extends keyof T>(event: K, listener: T[K]): this;
                    prependListener<K extends keyof T>(event: K, listener: T[K]): this;
                    prependOnceListener<K extends keyof T>(event: K, listener: T[K]): this;
                    rawListeners<K extends keyof T>(event: K): Array<T[K]>;
                    removeAllListeners<K extends keyof T>(event?: K): this;
                    removeListener<K extends keyof T>(event: K, listener: T[K]): this;
                    setMaxListeners(n: number): this;
                }
                export interface RollupAwaitingEmitter<T extends {
                    [event: string]: (...args: any) => any;
                }> extends TypedEventEmitter<T> {
                    close(): Promise<void>;
                    emitAndAwait<K extends keyof T>(event: K, ...args: Parameters<T[K]>): Promise<ReturnType<T[K]>[]>;
                    /**
                     * Registers an event listener that will be awaited before Rollup continues
                     * for events emitted via emitAndAwait. All listeners will be awaited in
                     * parallel while rejections are tracked via Promise.all.
                     * Listeners are removed automatically when removeAwaited is called, which
                     * happens automatically after each run.
                     */
                    onCurrentAwaited<K extends keyof T>(event: K, listener: (...args: Parameters<T[K]>) => Promise<ReturnType<T[K]>>): this;
                    removeAwaited(): this;
                }
                export type RollupWatcherEvent = {
                    code: "START";
                } | {
                    code: "BUNDLE_START";
                    input?: InputOption;
                    output: readonly string[];
                } | {
                    code: "BUNDLE_END";
                    duration: number;
                    input?: InputOption;
                    output: readonly string[];
                    result: RollupBuild;
                } | {
                    code: "END";
                } | {
                    code: "ERROR";
                    error: RollupError;
                    result: RollupBuild | null;
                };
                export type RollupWatcher = RollupAwaitingEmitter<{
                    change: (id: string, change: {
                        event: ChangeEvent;
                    }) => void;
                    close: () => void;
                    event: (event: RollupWatcherEvent) => void;
                    restart: () => void;
                }>;
                export interface AcornNode {
                    end: number;
                    start: number;
                    type: string;
                }
            }
            export namespace plugins {
                export namespace babel {
                    /**
                     * A Rollup plugin for seamless integration between Rollup and Babel.
                     * @param options - Plugin options.
                     * @returns Plugin instance.
                     */
                    export function getBabelInputPlugin(options?: RollupBabelInputPluginOptions): core.Plugin;
                    export function getBabelOutputPlugin(options?: RollupBabelOutputPluginOptions): core.Plugin;
                    export function createBabelInputPluginFactory(customCallback?: RollupBabelCustomInputPluginBuilder): typeof getBabelInputPlugin;
                    export function createBabelOutputPluginFactory(customCallback?: RollupBabelCustomOutputPluginBuilder): typeof getBabelOutputPlugin;
                    /**
                     * A Rollup plugin for seamless integration between Rollup and Babel.
                     * @param options - Plugin options.
                     * @returns Plugin instance.
                     */
                    export function babel(options?: RollupBabelInputPluginOptions): core.Plugin;
                    export interface RollupBabelInputPluginOptions extends Omit<Transformer.babel.core.TransformOptions, "include" | "exclude"> {
                        /**
                         * A picomatch pattern, or array of patterns, which specifies the files in the build the plugin should operate on. When relying on Babel configuration files you cannot include files already excluded there.
                         * @default undefined;
                         */
                        include?: FilterPattern;
                        /**
                         * A picomatch pattern, or array of patterns, which specifies the files in the build the plugin should ignore. When relaying on Babel configuration files you can only exclude additional files with this option, you cannot override what you have configured for Babel itself.
                         * @default undefined;
                         */
                        exclude?: FilterPattern;
                        /**
                         * Custom filter function can be used to determine whether or not certain modules should be operated upon.
                         * Example:
                         *   import { createFilter } from '@rollup/pluginutils';
                         *   const include = 'include/**.js';
                         *   const exclude = 'exclude/**.js';
                         *   const filter = createFilter(include, exclude, {});
                         * @default undefined;
                         */
                        filter?: ReturnType<CreateFilter>;
                        /**
                         * An array of file extensions that Babel should transpile. If you want to transpile TypeScript files with this plugin it's essential to include .ts and .tsx in this option.
                         * @default ['.js', '.jsx', '.es6', '.es', '.mjs']
                         */
                        extensions?: string[];
                        /**
                         * It is recommended to configure this option explicitly (even if with its default value) so an informed decision is taken on how those babel helpers are inserted into the code.
                         * @default 'bundled'
                         */
                        babelHelpers?: "bundled" | "runtime" | "inline" | "external";
                        /**
                         * Before transpiling your input files this plugin also transpile a short piece of code for each input file. This is used to validate some misconfiguration errors, but for sufficiently big projects it can slow your build times so if you are confident about your configuration then you might disable those checks with this option.
                         * @default false
                         */
                        skipPreflightCheck?: boolean;
                    }
                    export interface RollupBabelOutputPluginOptions extends Omit<Transformer.babel.core.TransformOptions, "include" | "exclude"> {
                        /**
                         * Use with other formats than UMD/IIFE.
                         * @default false
                         */
                        allowAllFormats?: boolean;
                    }
                    export type RollupBabelCustomInputPluginOptions = (options: RollupBabelInputPluginOptions & Record<string, any>) => {
                        customOptions: Record<string, any>;
                        pluginOptions: RollupBabelInputPluginOptions;
                    };
                    export type RollupBabelCustomOutputPluginOptions = (options: RollupBabelOutputPluginOptions & Record<string, any>) => {
                        customOptions: Record<string, any>;
                        pluginOptions: RollupBabelOutputPluginOptions;
                    };
                    export interface RollupBabelCustomPluginConfigOptions {
                        code: string;
                        customOptions: Record<string, any>;
                    }
                    export interface RollupBabelCustomPluginResultOptions {
                        code: string;
                        customOptions: Record<string, any>;
                        config: Transformer.babel.core.PartialConfig;
                        transformOptions: Transformer.babel.core.TransformOptions;
                    }
                    export type RollupBabelCustomInputPluginConfig = (this: core.TransformPluginContext, cfg: Transformer.babel.core.PartialConfig, options: RollupBabelCustomPluginConfigOptions) => Transformer.babel.core.TransformOptions;
                    export type RollupBabelCustomInputPluginResult = (this: core.TransformPluginContext, result: Transformer.babel.core.BabelFileResult, options: RollupBabelCustomPluginResultOptions) => Transformer.babel.core.BabelFileResult;
                    export type RollupBabelCustomOutputPluginConfig = (this: core.PluginContext, cfg: Transformer.babel.core.PartialConfig, options: RollupBabelCustomPluginConfigOptions) => Transformer.babel.core.TransformOptions;
                    export type RollupBabelCustomOutputPluginResult = (this: core.PluginContext, result: Transformer.babel.core.BabelFileResult, options: RollupBabelCustomPluginResultOptions) => Transformer.babel.core.BabelFileResult;
                    export interface RollupBabelCustomInputPlugin {
                        options?: RollupBabelCustomInputPluginOptions;
                        config?: RollupBabelCustomInputPluginConfig;
                        result?: RollupBabelCustomInputPluginResult;
                    }
                    export interface RollupBabelCustomOutputPlugin {
                        options?: RollupBabelCustomOutputPluginOptions;
                        config?: RollupBabelCustomOutputPluginConfig;
                        result?: RollupBabelCustomOutputPluginResult;
                    }
                    export type RollupBabelCustomInputPluginBuilder = (babel: typeof Transformer.babel.core) => RollupBabelCustomInputPlugin;
                    export type RollupBabelCustomOutputPluginBuilder = (babel: typeof Transformer.babel.core) => RollupBabelCustomOutputPlugin;
                    export import default = babel.babel;
                }
                /**
                 * Convert .json files to ES6 modules
                 */
                export function json(options?: RollupJsonOptions): core.Plugin;
                /**
                 * Locate modules using the Node resolution algorithm, for using third party modules in node_modules
                 */
                export function nodeResolve(options?: Options): core.Plugin;
                /**
                 * Convert CommonJS modules to ES6, so they can be included in a Rollup bundle
                 */
                export function commonjs(options?: RollupCommonJSOptions): core.Plugin;
                /**
                 * A Rollup plugin which loads virtual modules from memory.
                 */
                export function virtual(modules: RollupVirtualOptions): core.Plugin;
                /**
                 * Seamless integration between Rollup and Typescript.
                 */
                export function typescript(options?: RollupTypescriptOptions): core.Plugin;
            }
        }
    }
    export namespace Modularize {
        export type MinigamePlatformConfig = {
            [key in Lowercase<keyof typeof MinigamePlatform>]?: string;
        };
        export type NativePlatformConfig = {
            [key in Lowercase<keyof typeof NativePlatform>]?: string;
        };
        export type WebPlatformConfig = {
            [key in Lowercase<keyof typeof WebPlatform>]?: string;
        };
        export type PlatformType = Uppercase<keyof typeof WebPlatform | keyof typeof MinigamePlatform | keyof typeof NativePlatform> | "HTML5" | "NATIVE";
        export interface ModuleConfig {
            [key: string]: unknown;
            /**
             * The module name.
             */
            name: string;
            /**
             * The version of module.
             * It is useful when we change the module config, then we need to make some migration.
             * This usually comes with the `cc.migrations` field.
             */
            version: string;
            /**
             * The config for conditional exports.
             */
            exports: ConditionalExports;
            /**
             * Specify the module dependencies is required if this module import another one.
             * We need this field to generate the module dependency graph.
             */
            dependencies?: Record<string, string>;
            /**
             * Specify the dev dependencies, these dependencies are always used in `scripts` folder.
             */
            devDependencies?: Record<string, string>;
            /**
             * The dependencies between modules form a tree-structured dependency graph.
             * The correct dependency relationship should be that the upper module depends on the lower module one-way, and the reverse is wrong.
             * However, it is normal for modules at the same layer to depend on each other, and such dependencies should be declared as `peerDependencies`.
             * Otherwise the Turbo pipeline will report an error due to module circular dependencies.
             * see: https://github.com/vercel/turbo/issues/1480
             */
            peerDependencies?: Record<string, string>;
            /**
             * This is a CC-specific item difference from the node package.json standard specification.
             */
            cc?: {
                /**
                 * The module asset dependencies, which is an array of asset uuid.
                 */
                assetDependencies?: string[];
                /**
                 * This is different with conditional exports.
                 * Sometimes we just want to override a script file instead of the whole module.
                 * Module override could support to do this job.
                 * - eg. { "test": "context.mode === 'BUILD'", "overrides": { "/path/to/dev.ts": "/path/to/build.ts" } }
                 */
                moduleOverrides?: ModuleOverride[];
            };
        }
        export interface ModuleQueryContext {
            /**
             * The engine root path.
             */
            engine: string;
            /**
             * The platform to resolve conditional export.
             */
            platform: PlatformType;
            /**
             * The custom export condition.
             * The higher the array is sorted, the higher the priority is.
             *
             * @example
             * ```ts
             * [ 'webgl1',  'cannon' ]  // the backend of 'gfx' and 'physics' modules.
             * ```
             */
            customExportConditions?: string[];
        }
        /**
         * The module info manager.
         */
        export class ModuleQuery {
            constructor(context: ModuleQueryContext);
            /**
             * Get all modules' name defined in engine workspaces.
             */
            getAllModules(): Promise<string[]>;
            /**
             * Resolve module package.json path by module name.
             */
            resolvePackageJson(moduleName: string): string;
            /**
             * Get module config by module name.
             */
            getConfig(moduleName: string): Promise<ModuleConfig>;
            /**
             * Resolve module entry path by import source.
             */
            resolveExport(source: string): Promise<string | void>;
        }
        export enum MinigamePlatform {
            WECHAT = 0,
            WECHAT_MINI_PROGRAM = 1,
            /**
             * @deprecated this platform has been removed.
             */
            BAIDU = 2,
            BYTEDANCE = 3,
            XIAOMI = 4,
            ALIPAY = 5,
            TAOBAO = 6,
            TAOBAO_MINIGAME = 7,
            OPPO = 8,
            VIVO = 9,
            HUAWEI = 10,
            /**
             * @deprecated this platform has been removed.
             */
            COCOSPLAY = 11,
            /**
             * @deprecated this platform has been removed.
             */
            QTT = 12,
            /**
             * @deprecated this platform has been removed.
             */
            LINKSURE = 13
        }
        export enum NativePlatform {
            NATIVE_EDITOR = 0,
            ANDROID = 1,
            WINDOWS = 2,
            IOS = 3,
            MAC = 4,
            OHOS = 5,
            OPEN_HARMONY = 6,
            LINUX = 7
        }
        export enum WebPlatform {
            WEB_EDITOR = 0,
            WEB_MOBILE = 1,
            WEB_DESKTOP = 2
        }
    }
    export namespace dtsBundler {
        export function build(options: Options): Promise<boolean>;
        export interface Options {
            engine: string;
            outDir: string;
            withIndex: boolean;
            withExports: boolean;
            withEditorExports: boolean;
        }
    }
    export {};
}
